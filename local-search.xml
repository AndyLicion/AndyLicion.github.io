<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>实习一月的自我反思</title>
    <link href="/2023/12/15/%E5%AE%9E%E4%B9%A0%E4%B8%80%E6%9C%88%E8%87%AA%E6%88%91%E5%8F%8D%E6%80%9D/"/>
    <url>/2023/12/15/%E5%AE%9E%E4%B9%A0%E4%B8%80%E6%9C%88%E8%87%AA%E6%88%91%E5%8F%8D%E6%80%9D/</url>
    
    <content type="html"><![CDATA[<p>​我失去一份实习的工作。这件事情对我的触动很大，便想讲述一下其中的经过也算是能为我的将来做一个准备吧。</p><h2 id="我的开始">我的开始</h2><p>最最最开始我是本着能够找到一份与我未来发展方向比较契合的实习工作去的，因为我准备想在游戏行业做准备，并且python也是可以作为做游戏的语言的一种去做的（当时我也没多想，也有赌的成分在，既然人家公司愿意提供了这份机会我想事不宜迟直接就去了），而且在其他应聘的一些岗位里面很少是python用来做游戏的，一般来说python都是用来做数据分析，数据处理之类的工作的。最后综合考虑之后还是选择了这家公司去上班（因为当时也就只有这家公司给我发了实习offer，其实到今天为止也就这家公司给了我offer），在11月13号便正式开始了我这一个月的旅程。</p><h2 id="我的中旬">我的中旬</h2><p>最开始的那一个星期，发现开始有些吃力便有问题就去找部门主管咨询（它是专门带开发实习生的）。说句实话，我本身对python的了解也是一知半解。而且在是遇上需要一步步通过查询文档来理解实现逻辑的方式去开发我也算是比较陌生（本身自己专业就不是开发出身的，而且过往有问题都是通过csdn一点一点查询出来，这个地方说起来也有些可笑有些东西查询过了之后却没有内化为自己的理解导致自己很多时候一问再问仍不能理解！），做的确实非常的慢，现在回想起来当时那个任务的逻辑和开发流程怎么可能用的了10天的时间（确实可笑啊，现在说来也意义不大了毕竟人总是在挫败后进步的。任何知识的学习都是要经历一遍这样的过程从陌生到熟悉再到熟练的过程，其实这本就是人生的学习方式）。这个任务大概持续了两周的时间才结束，这远远低于主管给我的任务完成的预期。主管在验收的时候是有些失落的，失落可能不仅仅是对于我的能力方面的更可能是在我是否符合业务发展方面上的吧毕竟公司还是要从个人发展是否与公司相吻合为重。但是主管没有一次就放弃我，他说，“再看吧，这次就先这样了如果下次还是制作的时间比较长的话我们只能跟你的实习叫停了”，我听到这句话的时候说实话情绪是很低落的，“那就下次看你在项目中的表现如何了，如果还是这样的话，我们就没办法了只能说再见了。”，它补充道。我抓紧开始准备下一次需要看的内容（在我来的时候，其他两个实习生已经开始做这个项目了，同时我也了解到下一个项目会做些什么）此时再写文章的我发现，这才是我的真正的<strong>第一次的机会</strong>，我敢肯定主管没有跟来老板谈过我的第一个任务做的太慢，远低于预期。否则这里我可能就要去被做第一次谈话了但是并没有，说明主管没有跟老板说过（这里仅仅是我的揣测，但是就请当作我的<strong>第一次机会</strong>）。我毫无计划，没有多余的想法只是想着第二个任务一定要尽快完成（其实这里我想的没错的，只是用错了方式），在接收了第二份任务之后主管帮助了我很多地方，开始的模型开始的材质开始的一些建立方式都给我解释了一些（奈何我一遍确实吸收不完，我相信所有人都一样），便是边做边问也想着这样会更快一些完成这一次的任务。大概做了四五天的样子，中途真的是有问题就去问主管，可能主管也真的反感了，也确实我真的太没有自主思考的能力了竟然误以为调好的一个大任务就相当于任务快要完成了而急于抓紧做完最后一项小实现就想去紧接着开启另一个任务。我真确实不够善始善终而问了一个触发主管想要辞退我导火索的问题，这个问题本应该就是在第一个任务的制作中得到学习理解的但是此时我还是再次问了主管一遍（实际上我第一次没有真真正正的看完所要求的文档的全部内容）。我被老板约去会议室<strong>谈话了</strong>，这一次确确实实是主管跟老板做了结合对公司人才培养等方面对我提出相关劝退说法了。但是这是我第二次被警告吧，老板人很好，他可能并不直到主管给了我第一次机会因此他也说明情况再次给我<strong>一次机会</strong>再看一看我的表现如何！这里可以说是我的<strong>第二次机会</strong>了，老板那天详细的跟我阐明了我的进度情况确实很慢，他说，“我能够理解因为，你第一个demo的时候身体状况不适发烧了而且提到你人态度很不多“，他说，”比较来说一个人的发展，他更加看重的是一个人的态度问题，速度慢最后熟悉了总会速度快的，同时你速度慢你也要知道你<strong>需要比别人花更多的时间学习</strong>去赶上进度，多去交流多去提问向你身边的人提问去<strong>找到思路</strong>而不是一个本应该文档就能解决的问题你去问别人别人会以为你把他当做了文档来看，这样显然不合适了。我还是相信你能够做好的”。当时跟我谈话这次我自己竟然大胆的自己另开了一个分支做第三个任务，后面主管问我的时候我才开始修复第二个任务的错误，后面发现越是修复越多错误！自己的轻率，自以为是犯了一个难以补全的错误。开始修复第二个任务就开始了，我再一次错误的以为修复好一个很大的bug就是很成功的事情其实不然bug在开发过程中比比皆是，一两个bug修复成功确实能够带来不少的喜悦感但是还是有很多地方需要完善。做任务我并没有做到<strong>有始有终</strong>！主管再一次确认我的任务出错，“很多地方都没有理解清楚怎么能说这个任务你就做完了呢？”，我哑了，没有解释。“这个就先这样，后面有些细节整理完成后在跟我说验收吧。”，说完回到自己的工位上。</p><h2 id="我的结束">我的结束</h2><p>转眼间就是最后一周了，时间过的确实很快，快到我没法儿意识到自己即将就要被迫离开这里了。没有人知道我未来打算干什么，也就只有人知道我不能在这公司留下去了。最后一天接近于要下班了前一小时，与我比较熟的实习生和我身边的同事接连被叫去了会议室，我就意识到事情有些不对劲了。他们俩在我在的这一个月的时间里都没有被叫去谈过话却在那一刻都叫到了会议室。他们出来之后我就收到了老板约我谈话的消息，果不其然这就是准备与我结束实习工作的通知。紧张、复杂的心情让我当时不知道怎么去挽回。但我们很和平地结束了这次的实习安排，他们也要去寻找更加契合公司培养发展的人了，我也要在这段时间好好的思考、沉淀一下自己的想法并再次对于未来规划重新做一下修整了。那天晚上收拾完所有的物品，整理好所有的手头工作，书包是满当当的因为一个月以来带过去的东西在那一刻全部都聚在了一起。出了工作大楼以后跟同行的实习生聊着，反而确实有一种如释重负的感觉，也丝毫感觉不到一种事情没有办成的罪恶感吧就感觉这样也挺好的有一种时间受自己控制的<strong>自由</strong>，但是也只有<strong>现在</strong>会有这种可贵的<strong>自由</strong>可以<strong>享受</strong>了吧。这两天我开始回溯，这或许就是我的<strong>第三次机会</strong>了有些事情<strong>事不过三</strong>是铁打的定律，有些事情事刚好到第三次却可能会是另一个<strong>再出发</strong>方向的出现方式。沉淀知识吧，展望未来吧，我始终相信事情总不是一蹴而就的，人总不是一口吃成胖子的！</p><h2 id="我的总结反思">我的总结反思</h2><p>刚开始嘛，难免会有一些不太适应。可能是公司的环境吧，也有可能我是初入职场工作中确实有些不喜欢。虽然公司做的业务方向是与我预期很契合的但是囿于个人能力、沟通交涉能力的欠缺、职场经验的匮乏最终这份工作还是没能做满两个月整。</p><p>于此，我总结一下点，为自己警醒：</p><p><strong>工作方面：</strong> -职场并不是学校，每个人都在把我自我的时间和工作。你主动请求帮助，帮你是他们热心肠应该感谢，不帮你也不用气馁，不要忘记自我学习。-公司不是游击队，团队协作能力是很可贵的品质，作为学习者应当更加遵从指导人员的任务执行方式。- 做一样事情，爱一样事情。动力可以帮助你快速从陌生、熟悉、到熟练的转变。- 跟同事做好朋友关系，路子会走得更轻松一些</p><p><strong>个人方面：</strong> -不要环境因素而唯唯诺诺，你就是你不应让别人去定义你，你应该努力做真实的自己- 多锻炼自己的专业知识，这将会是跟随你一生的本领，不局限，不妥协。 -提高自主学习能力是关键，好的学习能力是你解决所有一切位置问题自信的关键 -一切的一切都是要建立在有一副健康的身体上的</p><p>最后的最后，希望未来的自己能够看得起现在的我。2023年就快要结束了，这一年其实有着一个月的经历也算是没有白过了，人生总在摸索道路的过程中也别忘记多回头看看自己走过的路。也祝自己早日找到女朋友吧 (￣﹃￣)</p>]]></content>
    
    
    <categories>
      
      <category>感想</category>
      
      <category>工作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
      <tag>工作</tag>
      
      <tag>实习</tag>
      
      <tag>自我反思</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>补11月24日小记一篇</title>
    <link href="/2023/11/26/%E8%A1%A511%E6%9C%8824%E6%97%A5%E5%B0%8F%E8%AE%B0%E4%B8%80%E7%AF%87/"/>
    <url>/2023/11/26/%E8%A1%A511%E6%9C%8824%E6%97%A5%E5%B0%8F%E8%AE%B0%E4%B8%80%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<p>这听来会非常的普通大众，但这极其有效地敲醒了我在很多我以前一般不以为意的点上面。</p><p>是这样的，这天是我大四下学期实习工作第二周工作日最后一天，不，我应该从前一天晚上开始说起也就是11月23号晚上。在还没有出公司大楼的时候我感觉自身状况良好，实际上可能当时我的身体已经被发烧发的透支挺严重了而我并没有很大的感觉而已。当到了公司楼下，这天晚上风大了许多，很清楚地能够听到树枝被吹地疯狂的沙沙声。出门的机动车道两侧还是跟往常一样拍了这些小摊铺，不知觉时就吸了一口冷风，我开始嗑，开始止不住地嗑我边嗑边寻找昨天那家买小笼包的小摊铺。走了几步，小摊铺在一艘警车摩托后便没了连续——没找到那家。还在咳转头望回走，买下了一烤红薯吃了边急急与工友招呼后便走了。</p><p>地铁上的步伐越走越是缓慢，身体转而越发滚烫。坚持了几站后还是败下阵来找个座位赶紧坐下，很是抱歉的是当时地铁三号线有一对老年人。其中一位原本在座位上的年轻人主动让座了而我却没有，我浑身发烫浑身发冷，我并不知道我是否当时能再站下几站？</p><p>刚到学校，直奔医务室。没有多少犹豫，到了医务室简单说明了一下情况后告诉我当时体温已经烧到39.5度了。我真的惊到了，我已经很久没有听到自己发烧到如此高的温度了当时那一瞬间是恍惚的。过后医生立马建议我去西溪医院看一下，说我少的这么高最好到医院看一看。我看当时是也不是很晚，才八点多。那位医生很好给了我一包6粒的退烧药让我赶紧去医院看，服下两粒之后我就拎上包就走了打了个车就到了医院。赶下车还好问了一下门口的保安，挂号去哪里哇？他指了指里面，前面那个门口进去就可以了，我照着他指的方向看了去，说到：“好咧，谢谢啦”。医院几乎都没什么灯开着了，唯有极个别的门诊室开着灯接一些深夜的病人。杭州市西溪医院大字一列竖下来红色的，没有其他光线映衬显得很瘆人。很冷！很大可能我依旧在发烧。在走向光亮处的地方的时候有些个别车辆停在走廊上。到了急诊大厅问了一下大厅的两位小姐，我想请问发热门诊在哪里呀姐姐？“哦，出去右转一直往前走查不到一直走就可以看到了，基本就是要到最那边了。”，她们说。按照他们的意思走呗走到起那面没有门诊部还好问了医院里的不知道是门卫还是保安大哥他给我指了一条正确的路。我到道声谢谢便先发热门诊奔去。到了地方显示挂号，量完血压叫号之后来到了门诊室，是一个中年妇女长得很是本地模样。说话也是条条有理的，可能我当时也是有点着急了吧。怕可能会有些医疗任务当天进行不完也没有注意多少。你这是甲流的喽，你是浙江科技学院的？听说你们学校要改名字了？我不知道我到底有没有听到她说给我测一下是甲乙流哪一个的了，反正我进的很清楚地是她操作检测管很是流畅，让我张开嘴巴打开喉咙，啊啊啊。。。这样一次在后面我还么有注意到账单时候才知道一次要111！甲乙流在一个试管上测试算了两次！有些这个门室医生说的话总让人感觉有那么点怪怪的，有点不着边际不太会说话的感觉。是这样的还有可能是我真的太过敏感了当时那个状态下！“你什么时候开始发烧的？你有没有咳嗽？你现在温度是38.9度”，她说。我详细的补充我的经过，告诉他：“我今天遇到风大就开始止不住的咳嗽，然后咳得厉害，然后就开始体温上升发烧了！”。“风大，咳嗽？不会啊，风大也不一定会咳嗽的呀？”，“你是不是有肺炎，要不要做一个胸部CT？”，她接我的话。我脑子可能真的有点恍惚，我直接就答应了。她操作真的很快直接三下五除二给我开了一张人物清单一样的白纸条，让我去大厅先付费然后做完之后在等1-2两个小时报告出来之后再来找她。我怔住了一会儿，就出去了问了一下这些血常规和CT位置在哪里。便离开，来到急诊三楼先抽血。那个姐姐也没什么废话似的直接就给我抽了两管儿。抽完之后就是一句普通的医术性话语，“压紧了”。再无其他，我先压着这边来了一个人，他开始抽了。我问姐姐，这边儿CT检验在哪里，一遍，我在问CT检验在哪里，两遍，我在问CT检验在哪里，三遍。她回我了很简单粗暴的一句话，“地上都有地标的，你自己不会看吗？”。哇，如果我不是在医院里状态不好，我真的会直接骂道她抬不起头！我终于还是自己找路线去了胸片CT拍摄的地方了，有两个女孩看他们也是甲流了（后来想想都是被骗了大几百块就为了做一个胸片一张白花花的纸上面印了两张b胸腔显影照片和一些医疗诊断话语仅此而已。），她们进去做CT的时候我还是高兴的以为医保能够保很多钱的。狗屁不是！看着这账单，我越是往深处想越可怕，一个小小的甲流医院开了你整整583.65的检查费。一个在杭州的大劳力一天能赚到几个百？一天他就不吃不喝它能赚到几个百？一次CT130，进去出来就结束了最后也不赏脸没有照片便一样的纸而是就简单的一张A4纸让人笑的可怜。笑的是自己，不是任何人！不仅让我想到有多少没有找到多少好的机会的人现在还在深夜里拼搏，他们的生命的厚度难道就只有130买来的一张纸这么薄吗？真的可悲可笑！真的没有一点虚假，医院的2个小时如果你在外没有赚钱机遇3天都不一定能补的回来！这不禁让我深刻反思，在大城市打工怎么可能有出头之日，什么油水都会在你奔波于疲惫中被消耗殆尽，消耗的很快很悄无声息！等到CT报告A4纸的过程我始终在与思想作斗争，也可能学校里服下的退烧药片现在终于开始奏效了，我发现眼前是事物变得异常的清晰可见，甚至是清晰的就是当下的自己。回忆起老爸对我说过的话，流给我的时间已经不多了，等爸妈老去我还没有一个足以支撑整个家庭的武器我在手中，我真的终将会疲惫不堪，再加上我自己的身体也不是什么结实身板儿。我突然间感到了莫名的压力开始慢慢挪动我身。报告单上写的我已经22岁了，我真的已经22岁了，我今年已经22岁了，今年就快要过去了是真的！完成了多少你想完成的任务？会，还是会有不明确不知道未来做什么，未来干什么的感觉，盲目感、空洞感、失落感这样。机会、机会、机会，机会始终远大于努力在当下。什么样的机会，会有作用？嗯，该去打印一下报告了。现在我人是很怔的，打印了单子就在再回到了发热门诊让她来给我做个评估，肺部CT上写着左下角少许肺炎迹象，她竟然说，“你还是很厉害的，年纪轻轻就有一些肺炎”。话里好像充满了嘲讽，一个两种解释都可以的词被她用在了跟我的对话中。我没有很反驳，“什么叫厉害？”。她说，“就是你比同龄人的症状厉害一点”。我想你这老婆子话都不会讲是怎么做到这个门诊的位置的？很是奇怪。说着说着给我开了一些要，由于我有肺炎少许，她建议我住院，我说不了她看了看不乐意说可以都行看你的准备怎么安排？一看这里写了少许某？我真的给看笑了，看着是大学生好欺负了住院都给她整上了，看我不愿，紧忙解释说CT证明上写的少许哦？我也就不想再多说什么了，我问他RNA试剂检测检测一次怎么会这么贵？她理由给的很到位，“这个是快速检测，可以在更短的时间里判断出来甲流阳性”等话语。然后又低估了几句，说我问你测不测，你说测？这里我真的无法回答了，我确实不知道我是否是真的说出了要测毕竟刚来那一会儿还处于脑子不清醒的状态！</p>]]></content>
    
    
    <categories>
      
      <category>感想</category>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
      <tag>就医</tag>
      
      <tag>感想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>acwing_django框架课</title>
    <link href="/2023/09/15/acwing_django%E6%A1%86%E6%9E%B6%E8%AF%BE/"/>
    <url>/2023/09/15/acwing_django%E6%A1%86%E6%9E%B6%E8%AF%BE/</url>
    
    <content type="html"><![CDATA[<p>郑重声明：</p><p>注意本文章所有内容都是在acwing网站学习记录需要请前往acwing网站学习获取</p><ul><li>链接：https://www.acwing.com</li><li>来源：AcWing</li><li>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</li></ul><h1 id="django框架">Django框架</h1><h2 id="课程概论与python3语法">1.课程概论与Python3语法</h2><p>​ <strong>描述：</strong></p><blockquote><h4 id="课程体系">课程体系</h4><figure><imgsrc="/img/learning/acwing/django_framework_course/1.课程概论和Python3语法/AcWing工程课体系——Django框架课.png"alt="AcWing工程课体系——Django框架课" /><figcaptionaria-hidden="true">AcWing工程课体系——Django框架课</figcaption></figure><h4 id="django简介">Django简介</h4><p>Django是后起之秀，近年来越来越流行，Youtube（20亿+）、Instagram（月活10亿+）等公司采用Django框架</p><p>可以作为Web、App、小程序、AcWing云端App（AC App）等各种项目。</p><p>Django优势：</p><ul><li>开发效率高，生态完善，有<ahref="https://www.djangoproject.com/">官方社区</a>产期支持</li><li>运行效率高<ul><li>项目运行效率瓶颈有很多，比如：数据库查询、网络带宽/延迟、硬盘读写速度等，这些与框架关系不大。</li><li>计算密集型的模块可以用C/C++实现，然后编译成动态链接库再<code>import</code>进来。</li><li>计算密集型的微服务可以通过<code>thrift</code>等工具对接，微服务的<code>Server</code>端代码可以用C/C++语言实现。</li><li>有很多工具可以将Python代码翻译成C/C++，比如Cython、Pypy。<ahref="https://www.acwing.com/problem/">AcWing题库</a>中的不少题目，会发现Python3比Java还快一些。</li></ul></li><li>既适合大公司，也适合个人开发者，<strong>平均开发一个Web/ACApp只需要半个月-1个月</strong>。</li></ul><hr /><h4 id="实战项目">实战项目</h4><p>课程中会开发一款支持在线对战的简易版吃鸡游戏，前后端分离，前端支持ACAPP端和Web端。</p><p>功能包括：</p><ul><li>游戏菜单，游戏设置：熟悉http协议</li><li>存储对局信息、账户信息：熟悉数据库操作</li><li>在Redis中存储每局对战状态：熟悉内存数据库操作</li><li>在线聊天室、实时移动、实时放技能：熟悉websocket协议</li><li>在线匹配系统：熟悉thrift和为服务</li><li>匹配nginx：熟悉nginx部署云服务</li></ul><hr /><h4 id="开发环境">开发环境</h4><figure><imgsrc="/img/learning/acwing/django_framework_course/1.课程概论和Python3语法/服务器结构.png"alt="服务器结构" /><figcaption aria-hidden="true">服务器结构</figcaption></figure><ul><li><p>完全无需配置本地环境。利用<code>AC Terminal</code>直接在云端开发，使用工具：<code>vim</code>、<code>tmux</code>等。不推荐在本地开发</p><ul><li>本项目会涉及多台服务器间的网络通信，如果在本地开发，未来不方便调试和部署。</li><li>在本地开发无法统一开发环境，部分<code>python</code>包在<code>windows</code>系统上安装困难。</li></ul></li><li><p>需要租一台具有公网IP的云服务器，并安装<ahref="https://docs.docker.com/engine/install/ubuntu/">docker</a>。</p><ul><li>服务器配置无要求</li><li>后期可以利用<ahref="https://docs.docker.com/engine/install/ubuntu/">docker</a>随意迁移</li></ul></li><li><p>在<code>AC Terminal</code>的<code>/var/lib/acwing/docker/images/</code>目录下给大家提供统一的课程<code>docker</code>镜像。</p><ul><li>标准化开发环境，避免未来出现软件版本不兼容。</li><li>省去配环境的环节。</li></ul></li><li><p>使用<code>AC Git</code>或者<code>github</code>管理项目代码。</p><ul><li>方便回滚代码</li></ul></li></ul><hr /><h4 id="python3语法">Python3语法</h4><ul><li>教学工具：<ahref="https://www.acwing.com/file_system/file/content/whole/index/content/2543025/">ACTerminal</a>。</li><li><ahref="https://docs.python.org/zh-cn/3/tutorial/index.html">python官方教程</a>。</li></ul></blockquote><h2id="配置dockergit环境与项目创建">2.配置docker、git环境与项目创建</h2><p>​ <strong>描述：</strong></p><blockquote><h4 id="课前准备">课前准备</h4><p>大家需要自己租一台具有公网IP的云服务器，并且配好Docker环境。可以参考<ahref="https://www.acwing.com/activity/content/57/">《Linux基础课》——8.租云服务器及配docker环境</a>的讲义及视频讲解：</p><p>讲义：</p><ul><li><ahref="https://www.acwing.com/file_system/file/content/whole/index/content/3074146/">8.租云服务器及配docker环境</a></li></ul><p>视频讲解：</p><ul><li><ahref="https://www.acwing.com/file_system/file/content/whole/index/content/3074937/">8.1租云服务器及配环境</a></li><li><ahref="https://www.acwing.com/file_system/file/content/whole/index/content/3082792/">8.2docker教程</a></li><li><ahref="https://www.acwing.com/file_system/file/content/whole/index/content/3089514/">8.3习题课</a></li></ul></blockquote><h2 id="创建菜单界面">3.创建菜单界面</h2><p>​ <strong>描述：</strong></p><blockquote><h4 id="项目系统设计">项目系统设计</h4><ul><li><code>menu</code>:菜单界面</li><li><code>playground</code>:游戏界面</li><li><code>settings</code>:设置界面</li></ul><hr /><h4 id="项目文件结构">项目文件结构</h4><ul><li><code>templates</code>:目录：管理html文件</li><li><code>urls</code>:目录：管理路由，即链接与函数的对应关系</li><li><code>views</code>:目录：管理<code>http</code>函数</li><li><code>models</code>:目录：管理数据库数据</li><li><code>static</code>:目录：管理静态文件，比如：<ul><li><code>css</code>:对象的格式，比如位置、长宽、颜色、背景、字体大小等</li><li><code>js</code>:对象的逻辑，比如对象的创建与销毁、函数事件、移动、变色等</li><li><code>image</code>:图片</li><li><code>audio</code>:声音</li><li>...</li></ul></li><li><code>consumers</code>:目录：管理<code>websocket</code>函数</li></ul><hr /><h4 id="本节课用到的素材地址">本节课用到的素材地址</h4><ul><li><ahref="https://cdn.acwing.com/media/article/image/2023/03/17/1_067a3e9cc4-background.gif">背景图片</a><ul><li>下载方式：<code>wget --output-document=自定义图片名称 图片地址</code></li></ul></li><li><code>jquery</code>库：<ul><li><code>&lt;link rel="stylesheet" href="https://cdn.acwing.com/static/jquery-ui-dist/jquery-ui.min.css"&gt;</code></li><li><code>&lt;script src="https://cdn.acwing.com/static/jquery/js/jquery-3.3.1.min.js"&gt;&lt;/script&gt;</code></li></ul></li></ul></blockquote><h2 id="部署nginx与对接acapp">5.部署nginx与对接acapp</h2><p>​ <strong>描述：</strong></p><blockquote><h4 id="增加容器的端口映射80和443">1.增加容器的端口映射：80和443</h4><p>第一步，登录容器，关闭所有运行中的任务</p><p>第二步，登录运行容器的服务器，然后执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker commit CONTAINER_NAME django_lesson:1.1 # 将容器保存为镜像，将CONTAINER_NAME替换成容器的名称<br>docker stop CONTAINER_NAME # 关闭容器<br>docker rm CONTAINER_NAME # 删除容器<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用保存下来的镜像重新创建容器</span><br>docker run -p 20000:22 -p 8000:8000 -p 80:80 -p 443:443 --name CONTAINER_NAME -itd django_lesson:1.1<br></code></pre></td></tr></table></figure><p>第三步，去云服务器控制台，在安全组配置中开放80和443端口</p><hr /><h4id="创建acapp获取域名nginx配置文件即https证书">2.创建AcApp，获取域名、nginx配置文件即https证书</h4><p>打开<ahref="https://www.acwing.com/file_system/file/content/whole/index/content/whole/application/1/">AcWing</a>,打开“创建应用”的按钮</p><figure><imgsrc="/img/learning/acwing/django_framework_course/5.部署nginx与对接acapp/AcWing应用中心.png"alt="AcWing应用中心" /><figcaption aria-hidden="true">AcWing应用中心</figcaption></figure><p>系统分配的域名，nginx配置文件即https证书在如下位置：</p><figure><imgsrc="/img/learning/acwing/django_framework_course/5.部署nginx与对接acapp/AcWing应用中心-创建应用.png"alt="AcWing应用中心-创建应用" /><figcaption aria-hidden="true">AcWing应用中心-创建应用</figcaption></figure><p>在<code>服务器IP</code>一栏填写自己服务器的ip地址</p><p>将<code>nginx.conf</code>中的内容写入服务器<code>/etc/nginx/nginx.conf</code>文件中。如果django项目路径与配置文件中不同，注意修改路径。</p><p>将<code>acapp.key</code>中的内容写入服务器<code>/etc/nginx/cert/acapp.key</code>文件中</p><p>将<code>acapp.pem</code>中的内容写入服务器<code>/etc/nginx/cert/acapp.pem</code>文件中</p><p>然后启动nginx服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo /etc/init.d/nginx start<br></code></pre></td></tr></table></figure><hr /><h4 id="修改django项目的配置">3.修改django项目的配置</h4><ul><li>打开<code>settings.py</code>文件：<ul><li>将分配的域名添加到<code>ALLOWED_HOSTS</code>列表中。注意只需要添加<code>https://</code>后面的部分</li><li>令<code>DEBUG = False</code>。</li></ul></li><li>归档<code>static</code>文件：<ul><li><code>python3 manage.py collectstatic</code></li></ul></li></ul><hr /><h4 id="配置uwsgi">4.配置uwsgi</h4><ul><li>在django项目中添加uwsgi的配置文件：<code>scripts/uwsgi.ini</code>，内容如下：</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[uwsgi]</span><br><span class="hljs-attr">socket</span>= <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8000</span><br><span class="hljs-attr">chdir</span>= /home/acs/acapp<br><span class="hljs-attr">wsgi-file</span>= acapp/wsgi.py<br><span class="hljs-attr">master</span>= <span class="hljs-literal">true</span><br><span class="hljs-attr">processes</span>= <span class="hljs-number">2</span><br><span class="hljs-attr">threads</span>= <span class="hljs-number">5</span><br><span class="hljs-attr">vacuum</span>= <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>启动uwsgi服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">uwsgi --ini scripts/uwsgi.ini<br></code></pre></td></tr></table></figure><hr /><h4 id="填写应用的剩余信息">5.填写应用的剩余信息</h4><ul><li>标题：应用的名称</li><li>关键字：应用的标签（选填）</li><li>css地址：css文件的地址，例如：<code>https://app76.acapp.acwing.com.cn/static/css/game.css</code></li><li>js地址：js文件的地址：例如：<code>https://app76.acapp.acwing.com.cn/static/js/dist/game.js</code></li><li>主类名：应用的main class，例如：<code>AcGame</code></li><li>图标：4:3的图片</li><li>应用介绍：介绍应用，支持markdown + latex语法</li></ul><hr /><h4 id="使分配的域名生效">6.使分配的域名生效</h4><p>填写完服务器IP之后，点击“保存”或者“提交”按钮，均可以使分配的域名生效</p><hr /><h4id="提交点打开应用按钮即可预览自己写的应用">7.提交点“打开应用”按钮，即可预览自己写的应用</h4><figure><imgsrc="/img/learning/acwing/django_framework_course/5.部署nginx与对接acapp/AcWing应用中心-查看自己的应用.png"alt="AcWing应用中心-查看自己的应用" /><figcaptionaria-hidden="true">AcWing应用中心-查看自己的应用</figcaption></figure><hr /><h4 id="发布应用">8.发布应用</h4><p>等待项目调试之后，可以申请发布应用。审核通过后，你的acapp应用就可以跟大家见面啦！</p></blockquote><h2 id="创建账号系统">6.创建账号系统</h2><h3 id="附录在django中集成redis">附录——在Django中集成Redis</h3><p>​ <strong>描述：</strong></p><blockquote><h4 id="安装django_redis">1.安装<code>django_redis</code></h4><p><code>pip install django_redis</code></p><h4 id="配置settings.py">2.配置<code>settings.py</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">CACHES = &#123;<br> <span class="hljs-string">&#x27;default&#x27;</span>: &#123;<br>     <span class="hljs-string">&#x27;BACKEND&#x27;</span>: <span class="hljs-string">&#x27;django_redis.cache.RedisCache&#x27;</span>,<br>     <span class="hljs-string">&#x27;LOCATION&#x27;</span>: <span class="hljs-string">&#x27;redis://127.0.0.1:6379/1&#x27;</span>,<br>     <span class="hljs-string">&quot;OPTIONS&quot;</span>: &#123;<br>         <span class="hljs-string">&quot;CLIENT_CLASS&quot;</span>: <span class="hljs-string">&quot;django_redis.client.DefaultClient&quot;</span>,<br>     &#125;,<br> &#125;,<br>&#125;<br>USER_AGENTS_CACHE = <span class="hljs-string">&#x27;default&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="启动redis-server">3.启动<code>redis-server</code></h4><p><code>sudo redis-server /etc/redis/redis.conf</code></p></blockquote><h3 id="用户名密码登录">6.1用户名密码登录</h3><p>​ <strong>描述：</strong></p><blockquote><h3 id="本章用到的资源">本章用到的资源</h3><h4 id="acwing-logo">1.AcWing Logo</h4><figure><imgsrc="/img/learning/acwing/django_framework_course/6.创建账号系统/acwing图片.png"alt="acwing图片" /><figcaption aria-hidden="true">acwing图片</figcaption></figure><p><ahref="https://cdn.acwing.com/media/article/image/2021/11/18/1_ea3d5e7448-logo64x64_2.png">https://cdn.acwing.com/media/article/image/2021/11/18/1_ea3d5e7448-logo64x64_2.png</a></p><hr /><h4 id="canvas用图片填充圆形">2.<code>canvas</code>用图片填充圆形</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">img</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>();<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">img</span>.<span class="hljs-property">src</span> = <span class="hljs-string">&quot;图片地址&quot;</span>;<br><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">ctx</span>.<span class="hljs-title function_">save</span>();<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">ctx</span>.<span class="hljs-title function_">beginPath</span>();<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">ctx</span>.<span class="hljs-title function_">arc</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span>, <span class="hljs-number">0</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span>, <span class="hljs-literal">false</span>);<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">ctx</span>.<span class="hljs-title function_">stroke</span>();<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">ctx</span>.<span class="hljs-title function_">clip</span>();<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">ctx</span>.<span class="hljs-title function_">drawImage</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">img</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span> * <span class="hljs-number">2</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span> * <span class="hljs-number">2</span>); <br><span class="hljs-variable language_">this</span>.<span class="hljs-property">ctx</span>.<span class="hljs-title function_">restore</span>();<br></code></pre></td></tr></table></figure></blockquote><h3 id="web端acwing一键登录">6.2 web端AcWing一键登录</h3><p>​ <strong>描述：</strong></p><p>授权登录模式图：</p><figure><img src="D:\学习\Django框架课\6.创建账号系统\oauth2协议模式图.png"alt="oauth2协议模式图" /><figcaption aria-hidden="true">oauth2协议模式图</figcaption></figure><p>​客户端点击一键登录发送apply_code请求（.ajax请求）到达web端，web端视图函数处理客户端请求重定向到acwing授权登录网址。用户点击授权向acwing端发送确认，acwing端收到确认即刻返回给web端授权码（code）和校验状态（state）<font color='red'>【此时需要注意：web端接收到acwing端传递过来的参数中包含state（state是Client端请求一键登录请求时一并携带的参数），因此web端可以验证当前的授权是否合法，如果不相同就会直接过滤当前的错误请求（恶意的攻击）】</font>。如果验证通过向acwing端请求access_token和openid，再次判断用户openid是否已经存在，如果已经存在则直接选择该用户登录（浏览器session中已经存在的缓存），无需重新在数据库创建该用户。如果不存在则持有access_token和openid向acwing请求用户信息userinfo于web端创建user和player并登录</p><blockquote><figure><img src="D:\学习\Django框架课\6.创建账号系统\web端acwing一键登录.png"alt="web端acwing一键登录" /><figcaption aria-hidden="true">web端acwing一键登录</figcaption></figure><h4 id="第一步-申请授权码code">第一步 申请授权码<code>code</code></h4><p>请求地址：<code>https://www.acwing.com/third_party/api/oauth2/web/authorize/</code></p><p>参考示例：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pf">请求方法：GET<br>https://www.acwing.com/third_party/api/oauth2/web/authorize/?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;scope=SCOPE&amp;<span class="hljs-keyword">state</span>=STATE<br></code></pre></td></tr></table></figure><p><strong>参数说明</strong></p><table><thead><tr class="header"><th>参数</th><th>是否必须</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>appid</td><td>是</td><td>应用的唯一id，可以在AcWing编辑AcApp的界面里看到</td></tr><tr class="even"><td>redirect_uri</td><td>是</td><td>接收授权码的地址。需要用对链接进行编码：Python3中使用urllib.parse.quote；Java中使用URLEncoder.encode</td></tr><tr class="odd"><td>scope</td><td>是</td><td>申请授权的范围。目前只需填userinfo</td></tr><tr class="even"><td>state</td><td>否</td><td>用于判断请求和回调的一致性，授权成功后后原样返回。该参数可用于防止csrf攻击（跨站请求伪造攻击），建议第三方带上该参数，可设置为简单的随机数（如果是将第三方授权登录绑定到现有账号上，那么推荐用随机数+ user_id作为state的值，可以有效防止CSRF攻击）</td></tr></tbody></table><p><strong>返回说明</strong></p><p>用户同意授权后会重定向到<code>redirect_uri</code>，返回参数<code>code</code>和<code>state</code>。链接格式如下：</p><p><code>redirect_uri?code=CODE&amp;state=STATE</code></p><p>如果用户拒绝授权，则不会发生重定向</p><hr /><h4 id="第二步-申请授权令牌access_token和用户的openid">第二步申请授权令牌<code>access_token</code>和用户的<code>openid</code></h4><p>请求地址：<code>https://www.acwing.com/third_party/api/oauth2/access_token/</code></p><p>参考示例：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">请求方法：GET<br>https:<span class="hljs-regexp">//</span>www.acwing.com<span class="hljs-regexp">/third_party/</span>api<span class="hljs-regexp">/oauth2/</span>access_token/?appid=APPID&amp;secret=APPSECRET&amp;code=CODE<br></code></pre></td></tr></table></figure><p><strong>参数说明</strong></p><table><thead><tr class="header"><th>参数</th><th>是否必须</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>appid</td><td>是</td><td>应用的唯一id，可以在AcWing编辑AcApp的界面里看到</td></tr><tr class="even"><td>secret</td><td>是</td><td>应用的秘钥，可以在AcWing编辑AcApp的界面里看到</td></tr><tr class="odd"><td>code</td><td>是</td><td>第一步中获取的授权码</td></tr></tbody></table><p><strong>返回说明</strong></p><p>申请成功示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span> <br> <span class="hljs-attr">&quot;access_token&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ACCESS_TOKEN&quot;</span><span class="hljs-punctuation">,</span> <br> <span class="hljs-attr">&quot;expires_in&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">7200</span><span class="hljs-punctuation">,</span> <br> <span class="hljs-attr">&quot;refresh_token&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;REFRESH_TOKEN&quot;</span><span class="hljs-punctuation">,</span><br> <span class="hljs-attr">&quot;openid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;OPENID&quot;</span><span class="hljs-punctuation">,</span> <br> <span class="hljs-attr">&quot;scope&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;SCOPE&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>申请失败示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br> <span class="hljs-attr">&quot;errcode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">40001</span><span class="hljs-punctuation">,</span><br> <span class="hljs-attr">&quot;errmsg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;code expired&quot;</span><span class="hljs-punctuation">,</span>  # 授权码过期<br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>返回参数说明</strong></p><table><thead><tr class="header"><th>参数</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>access_token</td><td>授权令牌，有效期2小时</td></tr><tr class="even"><td>expires_in</td><td>授权令牌还有多久过期，单位（秒）</td></tr><tr class="odd"><td>refresh_token</td><td>用于刷新access_token的令牌，有效期30天</td></tr><tr class="even"><td>openid</td><td>用户的id。每个AcWing用户在每个acapp中授权的openid是唯一的,可用于识别用户。</td></tr><tr class="odd"><td>scope</td><td>用户授权的范围。目前范围为userinfo，包括用户名、头像</td></tr></tbody></table><hr /><p><strong>刷新access_token的有效期</strong></p><p><code>access_token</code>的有效期为2小时，时间较短。<code>refresh_token</code>的有效期在30天，可用于刷新<code>access_token</code>。刷新结果有两种：</p><ol type="1"><li>如果<code>access_token</code>已过期，则生成一个新的<code>access_token</code>。</li><li>如果<code>access_token</code>未过期，则将当前的<code>access_token</code>的有效期延长为2小时</li></ol><p>参考示例：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">请求方法：GET<br>https:<span class="hljs-regexp">//</span>www.acwing.com<span class="hljs-regexp">/third_party/</span>api<span class="hljs-regexp">/oauth2/</span>refresh_token/?appid=APPID&amp;refresh_token=REFRESH_TOKEN<br></code></pre></td></tr></table></figure><p>返回结果的格式与申请<code>access_token</code>相同</p><hr /><h4 id="第三步-申请用户信息">第三步 申请用户信息</h4><p>请求地址:<code>https://www.acwing.com/third_party/api/meta/identity/getinfo/</code></p><p>参考示例:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.acwing.com<span class="hljs-regexp">/third_party/</span>api<span class="hljs-regexp">/meta/i</span>dentity<span class="hljs-regexp">/getinfo/</span>?access_token=ACCESS_TOKEN&amp;openid=OPENID<br></code></pre></td></tr></table></figure><p><strong>参数说明</strong></p><table><thead><tr class="header"><th>参数</th><th>是否必须</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>access_token</td><td>是</td><td>第二步中获取的授权令牌</td></tr><tr class="even"><td>openid</td><td>是</td><td>第二步中获取的用户openid</td></tr></tbody></table><p><strong>返回说明</strong></p><p>申请成功示例:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br> &#x27;username&#x27;<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;USERNAME&quot;</span><span class="hljs-punctuation">,</span><br> &#x27;photo&#x27;<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https:cdn.acwing.com/xxxxx&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>申请失败示例:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br> &#x27;errcode&#x27;<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;40004&quot;</span><span class="hljs-punctuation">,</span><br> &#x27;errmsg&#x27;<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;access_token expired&quot;</span>  # 授权令牌过期<br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="acapp端acwing一键登录">6.3 acapp端acwing一键登录</h3><p>​ <strong>描述:</strong></p><blockquote><figure><imgsrc="/img/learning/acwing/django_framework_course/6.创建账号系统/acapp端acwing一键登录.png"alt="acapp端acwing一键登录" /><figcaption aria-hidden="true">acapp端acwing一键登录</figcaption></figure><h4 id="第一步-申请授权码code-1">第一步 申请授权码<code>code</code></h4><p>请求授权码的API:</p><p><code>AcWingOS.api.oauth2.authorize(appid, redirect_uri, scope, state, callback);</code></p><p><strong>参数说明</strong></p><table><thead><tr class="header"><th>参数</th><th>是否必须</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>appid</td><td>是</td><td>应用的唯一id，可以在AcWing编辑AcApp的界面里看到</td></tr><tr class="even"><td>redirect_uri</td><td>是</td><td>接收授权码的地址。需要用对链接进行编码：Python3中使用urllib.parse.quote；Java中使用URLEncoder.encode</td></tr><tr class="odd"><td>scope</td><td>是</td><td>申请授权的范围。目前只需填userinfo</td></tr><tr class="even"><td>state</td><td>是</td><td>用于判断请求和回调的一致性，授权成功后后原样返回。该参数可用于防止csrf攻击（跨站请求伪造攻击），建议第三方带上该参数，可设置为简单的随机数（如果是将第三方授权登录绑定到现有账号上，那么推荐用随机数+ user_id作为state的值，可以有效防止CSRF攻击）</td></tr><tr class="odd"><td>callback</td><td>是</td><td>redirect_uri返回后的回调函数</td></tr></tbody></table><p><strong>返回说明</strong></p><p>用户同意授权后,会将<code>code</code>和<code>state</code>传递给<code>redirect_uri</code>。</p><p>如果用户拒绝授权，则将会收到如下错误码：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>errcode<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;40010&quot;</span><br>errmsg<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;user reject&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><hr /><h4id="第二步-申请授权令牌access_token和用户的openid-1">第二步　申请授权令牌<code>access_token</code>和用户的<code>openid</code></h4><p>请求地址：<code>https://www.acwing.com/third_party/api/oauth2/access_token/</code></p><p>参考示例：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">请求方法：GET<br>https:<span class="hljs-regexp">//</span>www.acwing.com<span class="hljs-regexp">/third_party/</span>api<span class="hljs-regexp">/oauth2/</span>access_token/?appid=APPID&amp;secret=APPSECRET&amp;code=CODE<br></code></pre></td></tr></table></figure><p><strong>参数说明</strong></p><table><thead><tr class="header"><th>参数</th><th>是否必须</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>appid</td><td>是</td><td>应用的唯一id，可以在AcWing编辑AcApp的界面里看到</td></tr><tr class="even"><td>secret</td><td>是</td><td>应用的秘钥，可以在AcWing编辑AcApp的界面里看到</td></tr><tr class="odd"><td>code</td><td>是</td><td>第一步中获取的授权码</td></tr></tbody></table><p><strong>返回说明</strong></p><p>申请成功示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span> <br><span class="hljs-attr">&quot;access_token&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ACCESS_TOKEN&quot;</span><span class="hljs-punctuation">,</span> <br><span class="hljs-attr">&quot;expires_in&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">7200</span><span class="hljs-punctuation">,</span> <br> <span class="hljs-attr">&quot;refresh_token&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;REFRESH_TOKEN&quot;</span><span class="hljs-punctuation">,</span><br> <span class="hljs-attr">&quot;openid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;OPENID&quot;</span><span class="hljs-punctuation">,</span> <br> <span class="hljs-attr">&quot;scope&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;SCOPE&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>申请失败示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;errcode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">40001</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;errmsg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;code expired&quot;</span><span class="hljs-punctuation">,</span>  # 授权码过期<br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>返回参数说明</strong></p><table><thead><tr class="header"><th>参数</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>access_token</td><td>授权令牌，有效期2小时</td></tr><tr class="even"><td>expires_in</td><td>授权令牌还有多久过期，单位（秒）</td></tr><tr class="odd"><td>refresh_token</td><td>用于刷新access_token的令牌，有效期30天</td></tr><tr class="even"><td>openid</td><td>用户的id。每个acwing用户在每个acapp中授权的openid是唯一的，可用于识别用户。</td></tr><tr class="odd"><td>scope</td><td>用户授权的范围。目前范围为userinfo，包括用户名、头像</td></tr></tbody></table><hr /><p><strong>刷新access_token的有效期</strong></p><p><code>access_token</code>的有效期是2小时，时间较短。<code>refresh_token</code>的有效期是30天，可用于刷新<code>access_token</code>。刷新结果有两种：</p><ol type="1"><li>如果<code>access_token</code>已过期，则生成一个新的<code>access_token</code>。</li><li>如果<code>access_token</code>未过期，则将当前的<code>access_token</code>的有效期延长为2小时</li></ol><p>参考示例：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">请求方法：GET<br>https:<span class="hljs-regexp">//</span>www.acwing.com<span class="hljs-regexp">/third_party/</span>api<span class="hljs-regexp">/oauth2/</span>refresh_token/?appid=APPID&amp;refresh_token=REFRESH_TOKEN<br></code></pre></td></tr></table></figure><p>返回结果的格式与申请<code>access_token</code>相同。</p><hr /><h4 id="第三步-申请用户信息-1">第三步 申请用户信息</h4><p>请求地址：<code>https://www.acwing.com/third_party/api/meta/identity/getinfo/</code></p><p>参考示例：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">请求方法：GET<br>https:<span class="hljs-regexp">//</span>www.acwing.com<span class="hljs-regexp">/third_party/</span>api<span class="hljs-regexp">/meta/i</span>dentity<span class="hljs-regexp">/getinfo/</span>?access_token=ACCESS_TOKEN&amp;openid=OPENID<br></code></pre></td></tr></table></figure><p><strong>参数说明</strong></p><table><thead><tr class="header"><th>参数</th><th>是否必须</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>access_token</td><td>是</td><td>第二步中获取的授权令牌</td></tr><tr class="even"><td>openid</td><td>是</td><td>第二步中获取的用户openid</td></tr></tbody></table><p><strong>返回说明</strong></p><p>申请成功示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    &#x27;username&#x27;<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;USERNAME&quot;</span><span class="hljs-punctuation">,</span><br>    &#x27;photo&#x27;<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https:cdn.acwing.com/xxxxx&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>申请失败示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    &#x27;errcode&#x27;<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;40004&quot;</span><span class="hljs-punctuation">,</span><br>    &#x27;errmsg&#x27;<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;access_token expired&quot;</span>  # 授权令牌过期<br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="实现联机对战">7.实现联机对战</h2><p>​ <strong>描述：</strong></p><blockquote><h4 id="统一长度单位">1.统一长度单位</h4><p>​不同的玩家打开游戏，游戏界面的长宽比应该是一样的才是，要不然一个玩家在的游戏界面在其他玩家的界面里是出界显示的</p><h4 id="增加联机对战模式">2.增加”联机对战“模式</h4><p>​ 将settings中的menu的zbase.js的多人模式按钮添加点击事件监听</p><h4 id="配置channels_redis">3.配置channels_redis</h4><h5 id="安装channels_redis">1.安装<code>channels_redis</code>:</h5><p><code>pip install channels_redis</code></p><hr /><h5 id="配置acappasgi.py">2.配置<code>acapp/asgi.py</code>:</h5><p>内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">from</span> channels.auth <span class="hljs-keyword">import</span> AuthMiddlewareStack<br><span class="hljs-keyword">from</span> channels.routing <span class="hljs-keyword">import</span> ProtocolTypeRouter, URLRouter<br><span class="hljs-keyword">from</span> django.core.asgi <span class="hljs-keyword">import</span> get_asgi_application<br><span class="hljs-keyword">from</span> game.routing <span class="hljs-keyword">import</span> websocket_urlpatterns<br><br>os.environ.setdefault(<span class="hljs-string">&#x27;DJANGO_SETTINGS_MODULE&#x27;</span>, <span class="hljs-string">&#x27;acapp.settings&#x27;</span>)<br><br>application = ProtocolTypeRouter(&#123;<br><span class="hljs-string">&quot;http&quot;</span>: get_asgi_application(),<br><span class="hljs-string">&quot;websocket&quot;</span>: AuthMiddlewareStack(URLRouter(websocket_urlpatterns))<br>&#125;)<br></code></pre></td></tr></table></figure><hr /><h5 id="配置acappsettings.py">3.配置<code>acapp/settings.py</code>:</h5><p>在<code>INSTALLED_APPS</code>中添加<code>channels</code>，然后添加如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">INSTALLED_APPS = [ <br><span class="hljs-string">&#x27;channels&#x27;</span>,<br><span class="hljs-string">&#x27;game.apps.GameConfig&#x27;</span>,<br><span class="hljs-string">&#x27;django.contrib.admin&#x27;</span>,<br><span class="hljs-string">&#x27;django.contrib.auth&#x27;</span>,<br><span class="hljs-string">&#x27;django.contrib.contenttypes&#x27;</span>,<br><span class="hljs-string">&#x27;django.contrib.sessions&#x27;</span>,<br><span class="hljs-string">&#x27;django.contrib.messages&#x27;</span>,<br><span class="hljs-string">&#x27;django.contrib.staticfiles&#x27;</span>,<br>]<br></code></pre></td></tr></table></figure><p>然后再文件末尾添加：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">ASGI_APPLICATION = <span class="hljs-string">&#x27;acapp.asgi.application&#x27;</span><br>CHANNEL_LAYERS = &#123;<br><span class="hljs-string">&quot;default&quot;</span>: &#123;<br><span class="hljs-string">&quot;BACKEND&quot;</span>: <span class="hljs-string">&quot;channels_redis.core.RedisChannelLayer&quot;</span>,<br><span class="hljs-string">&quot;CONFIG&quot;</span>: &#123;<br>   <span class="hljs-string">&quot;hosts&quot;</span>: [(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6379</span>)],<br>&#125;,<br>&#125;,<br>&#125;<br></code></pre></td></tr></table></figure><hr /><h5 id="配置gamerouting.py">4.配置<code>game/routing.py</code>:</h5><p>这一部分的作用相当于<code>http</code>的<code>urls</code>。</p><p>内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path<br><br>websocket_urlpatterns = [<br>]<br><br></code></pre></td></tr></table></figure><hr /><h5 id="编写gameconsumers">5.编写<code>game/consumers</code>:</h5><p>这一部分的作用相当于<code>http</code>的<code>views</code>。</p><p>参考示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> channels.generic.websocket <span class="hljs-keyword">import</span> AsyncWebsocketConsumer<br><span class="hljs-keyword">import</span> json<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiPlayer</span>(<span class="hljs-title class_ inherited__">AsyncWebsocketConsumer</span>):<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params">self</span>):<br><span class="hljs-keyword">await</span> self.accept()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;accept&#x27;</span>)<br><br>self.room_name = <span class="hljs-string">&quot;room&quot;</span><br><span class="hljs-keyword">await</span> self.channel_layer.group_add(self.room_name, self.channel_name)<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">disconnect</span>(<span class="hljs-params">self, close_code</span>):<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;disconnect&#x27;</span>)<br><span class="hljs-keyword">await</span> self.channel_layer.group_discard(self.room_name, self.channel_name)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">receive</span>(<span class="hljs-params">self, text_data</span>):<br>data = json.loads(text_data)<br><span class="hljs-built_in">print</span>(data)<br></code></pre></td></tr></table></figure><hr /><h5 id="启动django_channels">6.启动<code>django_channels</code></h5><p>在<code>~/acapp</code>目录下执行:</p><p><code>daphne -b 0.0.0.0 -p 5015 acapp.asgi:application</code></p><h4 id="编写同步函数">4.编写同步函数</h4><h5 id="canvas渲染文本"><code>canvas</code>渲染文本</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">ctx</span>.<span class="hljs-property">font</span> = <span class="hljs-string">&quot;20px serif&quot;</span>;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">ctx</span>.<span class="hljs-property">fillStyle</span> = <span class="hljs-string">&quot;white&quot;</span>;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">ctx</span>.<span class="hljs-property">textAlign</span> = <span class="hljs-string">&quot;center&quot;</span>;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">ctx</span>.<span class="hljs-title function_">fillText</span>(<span class="hljs-string">&quot;Hello HelloWorld&quot;</span>, x, y);<br></code></pre></td></tr></table></figure><hr /><h5 id="技能图标资源">技能图标资源</h5><figure><imgsrc="/img/learning/acwing/django_framework_course/7.实现联机对战/技能1.png"alt="技能1" /><figcaption aria-hidden="true">技能1</figcaption></figure><figure><imgsrc="/img/learning/acwing/django_framework_course/7.实现联机对战/技能2.png"alt="技能2" /><figcaption aria-hidden="true">技能2</figcaption></figure><h4id="尝试解释一下创建玩家这一个事件的整个流程">尝试解释一下创建玩家这一个事件的整个流程：</h4><ol type="1"><li>首先前端js接收到菜单界面事件点击，wss服务器尝试创建连接，连接创建成功后会自动调用回调函数<code>outer.mps.send_create_player</code>传递创建当前用户信息。<imgsrc="/img/learning/acwing/django_framework_course/7.实现联机对战/create_player-1.png"alt="create_player-1" /></li><li>事件进入到<code>Multiplayer</code>类中处理，类<code>Multiplayer</code>中的<code>send_create_player</code>函数将前端传入的me用户信息（<code>json</code>序列）参数转换成string通过ws连接对象发送到后端处理函数<code>receive</code>统一接收函数中<imgsrc="/img/learning/acwing/django_framework_course/7.实现联机对战/create_player-2.png"alt="create_player-2" /></li><li>后端<code>receive</code>函数接收到事件做路由分配之后携带<code>string</code>传递到后端相应的处理函数<code>create_player</code>中。<imgsrc="/img/learning/acwing/django_framework_course/7.实现联机对战/create_player-3.png"alt="create_player-3" /></li><li><code>create_player</code>函数先从<code>cache</code>中找寻空房间并确定空的房间准备加入中，然后将该房间中的已经存在的玩家在本机窗口中创建（遍历<code>redis</code>中的玩家信息依次发送给前端创建玩家的请求）<imgsrc="/img/learning/acwing/django_framework_course/7.实现联机对战/create_player-4.png"alt="create_player-4" /></li><li>前端也有一个接收消息的函数作为回应后端的请求，当前端接收到后端发送的创建玩家请求之后经过路由过滤调用创建玩家的函数<code>receive_create_player()</code><imgsrc="/img/learning/acwing/django_framework_course/7.实现联机对战/create_player-5.png"alt="create_player-5" /></li><li>最后<code>receive_create_player</code>函数真实的在前端创建出来一个玩家，并且本机窗口创建的enemy玩家不受本机点触事件的控制所以应该将该玩家的uuid统一为控制方生成的<code>uuid</code>保证事件的同步运行<imgsrc="/img/learning/acwing/django_framework_course/7.实现联机对战/create_player-6.png"alt="create_player-6" /></li><li>(接上 ——4.)但此时所有事件后端函数还没有执行完成，当同一个<code>room</code>中的玩家都在本地已经渲染完了之后需要将本机生成的玩家创建出来，加入到当前的<code>room</code>中，创建me玩家时是通过群发的方式创建的玩家，群发函数能够接收函数<code>group_send_event</code>收到并执行<imgsrc="/img/learning/acwing/django_framework_course/7.实现联机对战/create_player-7.png"alt="create_player-7" /></li><li>接收函数<code>group_send_event</code>接收到群发消息后在统一<code>room</code>中的所有窗口中创建me玩家<imgsrc="/img/learning/acwing/django_framework_course/7.实现联机对战/create_player-8.png"alt="create_player-8" /></li><li>最后同一个<code>room</code>中的所有玩家在各自的窗口中就能够同步显示<code>create_player</code>的效果了</li></ol></blockquote><h2 id="实现匹配系统">9.实现匹配系统</h2><p>​ <strong>描述：</strong></p><blockquote><h4 id="thrift服务">thrift服务</h4><ol type="1"><li><a href="https://thrift.apache.org/">thrift官网</a></li><li><ahref="https://git.acwing.com/yxc/thrift_lesson">Linux基础课-thrift项目地址</a></li></ol><hr /><h4 id="项目收尾">项目收尾</h4><p><strong>1.加密、压缩js代码</strong></p><p>安装<code>tester</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get update<br>sudo apt-get install npm<br>sudo npm install terser -g<br></code></pre></td></tr></table></figure><p><code>terser</code>不仅支持文件输入，也支持标准输入。结果会输出到标准输出中</p><p>使用方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">terser xxx.js -c -m<br></code></pre></td></tr></table></figure><hr /><p><strong>2.清理监听函数</strong></p><p>在ACAPP关闭之前触发的事件可以通过如下api添加：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">AcWingOS.api.window.on_close(func);<br></code></pre></td></tr></table></figure><h4 id="注意">注意：</h4><ul><li>在同一个页面中，多个acapp引入的js代码只会加载一次，因此<code>AC_GAME_OBJECTS</code>等全局变量是同一个页面、同一个<code>acapp</code>的所有窗口公用的。</li><li>各自创建的局部变量是独立的，比如<code>new AcGame()</code>创建出的对象各个窗口是独立的。</li></ul><hr /><p><strong>3.编写每局游戏的结束界面</strong></p><p>资源地址：</p><ol type="1"><li><ahref="https://cdn.acwing.com/media/article/image/2021/12/17/1_8f58341a5e-win.png">获胜图标</a></li><li><ahref="https://cdn.acwing.com/media/article/image/2021/12/17/1_9254b5f95e-lose.png">失败图标</a></li></ol><hr /><p><strong>4.更新战绩</strong></p><p><strong>5.添加favicon.ico</strong></p><p>资源地址：</p><ul><li><ahref="https://cdn.acwing.com/media/article/image/2021/12/17/1_be4c11ce5f-acapp.png">acapp.png</a></li></ul></blockquote><h2 id="rest-framework与jwt身份验证">10.Rest Framework与JWT身份验证</h2><p>​ <strong>描述：</strong></p><blockquote><p>为了方便解决跨域身份验证问题，本章我们在之前的项目中集成 Django RestFramework 和 JWT 身份验证。</p><h4 id="继承django-rest-framework">1.继承Django Rest Framework</h4><p><strong>1.1安装</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install djangorestframework<br>pip install pyjwt<br></code></pre></td></tr></table></figure><p>然后在<code>settings.py</code>的<code>INSTALLED_APPS</code>中添加<code>rest_framework</code>。</p><hr /><p><strong>1.2Class-Based Views</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> rest_framework.views <span class="hljs-keyword">import</span> APIView<br><span class="hljs-keyword">from</span> rest_framework.response <span class="hljs-keyword">import</span> Response<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SnippetDetail</span>(<span class="hljs-title class_ inherited__">APIView</span>):<br> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self, request</span>):  <span class="hljs-comment"># 查找</span><br>     ...<br>     <span class="hljs-keyword">return</span> Response(...)<br><br> <span class="hljs-keyword">def</span> <span class="hljs-title function_">post</span>(<span class="hljs-params">self, request</span>):  <span class="hljs-comment"># 创建</span><br>     ...<br>     <span class="hljs-keyword">return</span> Response(...)<br><br> <span class="hljs-keyword">def</span> <span class="hljs-title function_">put</span>(<span class="hljs-params">self, request, pk</span>):  <span class="hljs-comment"># 修改</span><br>     ...<br>     <span class="hljs-keyword">return</span> Response(...)<br><br> <span class="hljs-keyword">def</span> <span class="hljs-title function_">delete</span>(<span class="hljs-params">self, request, pk</span>):  <span class="hljs-comment"># 删除</span><br>     ...<br>     <span class="hljs-keyword">return</span> Response(...)<br><br></code></pre></td></tr></table></figure><h4 id="集成jwt验证">2.集成JWT验证</h4><p><strong>2.1安装</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> djangorestframework-simplejwt<br></code></pre></td></tr></table></figure><p>然后在<code>settings.py</code>中添加：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">INSTALLED_APPS = [<br> ...<br> <span class="hljs-string">&#x27;rest_framework_simplejwt&#x27;</span>,<br> ...<br>]<br><br>REST_FRAMEWORK = &#123;<br> ...<br> <span class="hljs-string">&#x27;DEFAULT_AUTHENTICATION_CLASSES&#x27;</span>: (<br>     ...<br>     <span class="hljs-string">&#x27;rest_framework_simplejwt.authentication.JWTAuthentication&#x27;</span>,<br> )<br> ...<br>&#125;<br></code></pre></td></tr></table></figure><hr /><p><strong>2.2配置</strong></p><p>在<code>settings.py</code>中添加：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> timedelta<br>...<br><br>SIMPLE_JWT = &#123;<br> <span class="hljs-string">&#x27;ACCESS_TOKEN_LIFETIME&#x27;</span>: timedelta(minutes=<span class="hljs-number">5</span>),<br> <span class="hljs-string">&#x27;REFRESH_TOKEN_LIFETIME&#x27;</span>: timedelta(days=<span class="hljs-number">1</span>),<br> <span class="hljs-string">&#x27;ROTATE_REFRESH_TOKENS&#x27;</span>: <span class="hljs-literal">False</span>,<br> <span class="hljs-string">&#x27;BLACKLIST_AFTER_ROTATION&#x27;</span>: <span class="hljs-literal">False</span>,<br> <span class="hljs-string">&#x27;UPDATE_LAST_LOGIN&#x27;</span>: <span class="hljs-literal">False</span>,<br><br> <span class="hljs-string">&#x27;ALGORITHM&#x27;</span>: <span class="hljs-string">&#x27;HS256&#x27;</span>,<br> <span class="hljs-string">&#x27;SIGNING_KEY&#x27;</span>: SECRET_KEY,<br> <span class="hljs-string">&#x27;VERIFYING_KEY&#x27;</span>: <span class="hljs-literal">None</span>,<br> <span class="hljs-string">&#x27;AUDIENCE&#x27;</span>: <span class="hljs-literal">None</span>,<br> <span class="hljs-string">&#x27;ISSUER&#x27;</span>: <span class="hljs-literal">None</span>,<br> <span class="hljs-string">&#x27;JWK_URL&#x27;</span>: <span class="hljs-literal">None</span>,<br> <span class="hljs-string">&#x27;LEEWAY&#x27;</span>: <span class="hljs-number">0</span>,<br><br> <span class="hljs-string">&#x27;AUTH_HEADER_TYPES&#x27;</span>: (<span class="hljs-string">&#x27;Bearer&#x27;</span>,),<br> <span class="hljs-string">&#x27;AUTH_HEADER_NAME&#x27;</span>: <span class="hljs-string">&#x27;HTTP_AUTHORIZATION&#x27;</span>,<br> <span class="hljs-string">&#x27;USER_ID_FIELD&#x27;</span>: <span class="hljs-string">&#x27;id&#x27;</span>,<br> <span class="hljs-string">&#x27;USER_ID_CLAIM&#x27;</span>: <span class="hljs-string">&#x27;user_id&#x27;</span>,<br> <span class="hljs-string">&#x27;USER_AUTHENTICATION_RULE&#x27;</span>: <span class="hljs-string">&#x27;rest_framework_simplejwt.authentication.default_user_authentication_rule&#x27;</span>,<br><br> <span class="hljs-string">&#x27;AUTH_TOKEN_CLASSES&#x27;</span>: (<span class="hljs-string">&#x27;rest_framework_simplejwt.tokens.AccessToken&#x27;</span>,),<br> <span class="hljs-string">&#x27;TOKEN_TYPE_CLAIM&#x27;</span>: <span class="hljs-string">&#x27;token_type&#x27;</span>,<br> <span class="hljs-string">&#x27;TOKEN_USER_CLASS&#x27;</span>: <span class="hljs-string">&#x27;rest_framework_simplejwt.models.TokenUser&#x27;</span>,<br><br> <span class="hljs-string">&#x27;JTI_CLAIM&#x27;</span>: <span class="hljs-string">&#x27;jti&#x27;</span>,<br><br> <span class="hljs-string">&#x27;SLIDING_TOKEN_REFRESH_EXP_CLAIM&#x27;</span>: <span class="hljs-string">&#x27;refresh_exp&#x27;</span>,<br> <span class="hljs-string">&#x27;SLIDING_TOKEN_LIFETIME&#x27;</span>: timedelta(minutes=<span class="hljs-number">5</span>),<br> <span class="hljs-string">&#x27;SLIDING_TOKEN_REFRESH_LIFETIME&#x27;</span>: timedelta(days=<span class="hljs-number">1</span>),<br>&#125;<br><br></code></pre></td></tr></table></figure><hr /><p><strong>2.3添加获取jwt和刷新jwt路由</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> rest_framework_simplejwt.views <span class="hljs-keyword">import</span> (<br> TokenObtainPairView,<br> TokenRefreshView,<br>)<br><br>urlpatterns = [<br> ...<br> path(<span class="hljs-string">&#x27;api/token/&#x27;</span>, TokenObtainPairView.as_view(), name=<span class="hljs-string">&#x27;token_obtain_pair&#x27;</span>),<br> path(<span class="hljs-string">&#x27;api/token/refresh/&#x27;</span>, TokenRefreshView.as_view(), name=<span class="hljs-string">&#x27;token_refresh&#x27;</span>),<br> ...<br>]<br><br></code></pre></td></tr></table></figure><hr /><p><strong>2.4手动获取jwt</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> rest_framework_simplejwt.tokens <span class="hljs-keyword">import</span> RefreshToken<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_tokens_for_user</span>(<span class="hljs-params">user</span>):<br> refresh = RefreshToken.for_user(user)<br><br> <span class="hljs-keyword">return</span> &#123;<br>     <span class="hljs-string">&#x27;refresh&#x27;</span>: <span class="hljs-built_in">str</span>(refresh),<br>     <span class="hljs-string">&#x27;access&#x27;</span>: <span class="hljs-built_in">str</span>(refresh.access_token),<br> &#125;<br></code></pre></td></tr></table></figure><hr /><p><strong>2.5将jwt验证集成到Django Channel中</strong></p><p>创建文件<code>channelsmiddleware.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;General web socket middlewares</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">from</span> channels.db <span class="hljs-keyword">import</span> database_sync_to_async<br><span class="hljs-keyword">from</span> django.contrib.auth <span class="hljs-keyword">import</span> get_user_model<br><span class="hljs-keyword">from</span> django.contrib.auth.models <span class="hljs-keyword">import</span> AnonymousUser<br><span class="hljs-keyword">from</span> rest_framework_simplejwt.exceptions <span class="hljs-keyword">import</span> InvalidToken, TokenError<br><span class="hljs-keyword">from</span> rest_framework_simplejwt.tokens <span class="hljs-keyword">import</span> UntypedToken<br><span class="hljs-keyword">from</span> rest_framework_simplejwt.authentication <span class="hljs-keyword">import</span> JWTTokenUserAuthentication<br><span class="hljs-keyword">from</span> channels.middleware <span class="hljs-keyword">import</span> BaseMiddleware<br><span class="hljs-keyword">from</span> channels.auth <span class="hljs-keyword">import</span> AuthMiddlewareStack<br><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> close_old_connections<br><span class="hljs-keyword">from</span> urllib.parse <span class="hljs-keyword">import</span> parse_qs<br><span class="hljs-keyword">from</span> jwt <span class="hljs-keyword">import</span> decode <span class="hljs-keyword">as</span> jwt_decode<br><span class="hljs-keyword">from</span> django.conf <span class="hljs-keyword">import</span> settings<br><span class="hljs-meta">@database_sync_to_async</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_user</span>(<span class="hljs-params">validated_token</span>):<br> <span class="hljs-keyword">try</span>:<br>     user = get_user_model().objects.get(<span class="hljs-built_in">id</span>=validated_token[<span class="hljs-string">&quot;user_id&quot;</span>])<br>     <span class="hljs-comment"># return get_user_model().objects.get(id=toke_id)</span><br>     <span class="hljs-keyword">return</span> user<br><br> <span class="hljs-keyword">except</span>:<br>     <span class="hljs-keyword">return</span> AnonymousUser()<br><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">JwtAuthMiddleware</span>(<span class="hljs-title class_ inherited__">BaseMiddleware</span>):<br> <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, inner</span>):<br>     self.inner = inner<br><br> <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, scope, receive, send</span>):<br>    <span class="hljs-comment"># Close old database connections to prevent usage of timed out connections</span><br>     close_old_connections()<br><br>     <span class="hljs-comment"># Try to authenticate the user</span><br>     <span class="hljs-keyword">try</span>:<br>         <span class="hljs-comment"># Get the token</span><br>         token = parse_qs(scope[<span class="hljs-string">&quot;query_string&quot;</span>].decode(<span class="hljs-string">&quot;utf8&quot;</span>))[<span class="hljs-string">&quot;token&quot;</span>][<span class="hljs-number">0</span>]<br><br>         <span class="hljs-comment"># This will automatically validate the token and raise an error if token is invalid</span><br>         UntypedToken(token)<br>     <span class="hljs-keyword">except</span>:<br>         <span class="hljs-comment"># Token is invalid</span><br><br>         scope[<span class="hljs-string">&quot;user&quot;</span>] = AnonymousUser()<br>     <span class="hljs-keyword">else</span>:<br>         <span class="hljs-comment">#  Then token is valid, decode it</span><br>         decoded_data = jwt_decode(token, settings.SIMPLE_JWT[<span class="hljs-string">&quot;SIGNING_KEY&quot;</span>], algorithms=[<span class="hljs-string">&quot;HS256&quot;</span>])<br><br>         <span class="hljs-comment"># Get the user using ID</span><br>         scope[<span class="hljs-string">&quot;user&quot;</span>] = <span class="hljs-keyword">await</span> get_user(validated_token=decoded_data)<br>     <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-built_in">super</span>().__call__(scope, receive, send)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">JwtAuthMiddlewareStack</span>(<span class="hljs-params">inner</span>):<br> <span class="hljs-keyword">return</span> JwtAuthMiddleware(AuthMiddlewareStack(inner))<br><br></code></pre></td></tr></table></figure><h4 id="配置nginx">3.配置Nginx</h4><p>打开<code>/etc/nginx/nginx.conf</code>，在<code>location /</code>的路由中添加对<code>PUT</code>、<code>POST</code>、<code>DELETE</code>方法的支持。完整配置见【创建应用】界面。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">if</span> (<span class="hljs-variable">$request_method</span> = <span class="hljs-string">&#x27;POST&#x27;</span>) &#123;<br> <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="hljs-string">&#x27;https://www.acwing.com&#x27;</span>;<br> <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span> <span class="hljs-string">&#x27;GET, PUT, OPTIONS, POST, DELETE&#x27;</span>;<br> <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span> <span class="hljs-string">&#x27;DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization,X-Amz-Date&#x27;</span>;<br> <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Expose-Headers&#x27;</span> <span class="hljs-string">&#x27;Content-Length,Content-Range&#x27;</span>;<br>&#125;<br><span class="hljs-attribute">if</span> (<span class="hljs-variable">$request_method</span> = <span class="hljs-string">&#x27;DELETE&#x27;</span>) &#123;<br> <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="hljs-string">&#x27;https://www.acwing.com&#x27;</span>;<br> <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span> <span class="hljs-string">&#x27;GET, PUT, OPTIONS, POST, DELETE&#x27;</span>;<br> <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span> <span class="hljs-string">&#x27;DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization,X-Amz-Date&#x27;</span>;<br> <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Expose-Headers&#x27;</span> <span class="hljs-string">&#x27;Content-Length,Content-Range&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建完成后，执行：<code>sudo nginx -s reload</code>，使修改生效。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>acwing</category>
      
      <category>工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>acwing</tag>
      
      <tag>学习</tag>
      
      <tag>工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>acwing_linux基础</title>
    <link href="/2023/08/08/acwing_linux%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/08/08/acwing_linux%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>郑重声明：</p><p>注意本文章所有内容都是在acwing网站学习记录需要请前往acwing网站学习获取</p><ul><li>链接：https://www.acwing.com</li><li>来源：AcWing</li><li>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</li></ul><h1 id="linux基础">Linux基础</h1><h2 id="常用文件管理命令">1.常用文件管理命令</h2><p>​ <strong>描述：</strong>多敲多敲多敲</p><p>linux文件结构：/(根目录) -&gt; home | bin | var | lib | proc | etc |root and so on...</p><blockquote><p>根目录 -&gt; /</p><p>家目录 -&gt; /home/xxx (xxx -&gt; 当前用户名)</p><p>绝对路径：从根目录开始描述的路径 -&gt; 开头是/</p><p>相对路径：从当前目录开始描述的路径 -&gt; 开头不是/</p></blockquote><blockquote><p>常见操作：</p><p>.. -&gt; 上一级目录</p><p>. -&gt; 当前目录</p><p>~/ -&gt; 家目录</p></blockquote><blockquote><p>常用命令介绍：</p><ol type="1"><li><p>ctrl c: 取消命令，并且换行</p></li><li><p>ctrl u: 清空本行命令</p></li><li><p>tab键：可以补全命令和文件名，如果补全不了快速按两下tab键，可以显示备选选项</p></li><li><p>ls:列出当前目录下所有文件，蓝色的是文件夹，白色的是普通文件，绿色的是可执行文件</p></li><li><p>pwd: 显示当前路径</p></li><li><p>cd XXX: 进入XXX目录下, cd .. 返回上层目录</p><p>cd . cd .. cd 等等</p></li><li><p>cp XXX YYY: （复制+粘贴+重命名<code>将一个文件复制一份到另一个地方，原来那个地方文件还有</code>）将XXX文件复制成YYY，XXX和YYY可以是一个路径，比如../dir_c/a.txt，表示上层目录下的dir_c文件夹下的文件a.txt</p><p>cp a/tmp.txt b/ cp a/tmp.txt b/tmp2.txt cp a b -r 等等</p></li><li><p>mkdir XXX: 创建目录XXX</p></li><li><p>rm XXX: 删除普通文件; rm XXX -r: 删除文件夹</p></li><li><p>mv XXX YYY: （剪切 + 重命名<code>将一个文件移动到另一个地方，原来那个地方文件没了</code>）将XXX文件移动到YYY，和cp命令一样，XXX和YYY可以是一个路径；重命名也是用这个命令</p></li><li><p>touch XXX: 创建一个文件</p></li><li><p>cat XXX: 展示文件XXX中的内容</p></li><li><p>复制文本 windows/Linux下：Ctrl + insert，Mac下：command +c</p></li><li><p>粘贴文本 windows/Linux下：Shift + insert，Mac下：command +v</p></li></ol></blockquote><h2 id="tmux和vim">2.tmux和vim</h2><p>​ <strong>描述：</strong>多敲多敲多敲</p><p>tmux可以开很多的session（session1， session2， ... ），每一个session可以包含很多的window（window1， window2， window3，... ），每一个window可以开很多的pane（pane1， pane2， pane3，...），每一个pane都会打开一个shell对话框</p><figure><img src="/img/learning/acwing/linux_basic/2.tmux和vim/1.tmux结构.png"alt="1.tmux结构" /><figcaption aria-hidden="true">1.tmux结构</figcaption></figure><blockquote><p><strong>1.tmux教程</strong> <strong>功能：</strong> (1) 分屏。 (2)允许断开Terminal连接后，继续运行进程。 <strong>结构：</strong>一个tmux可以包含多个session，一个session可以包含多个window，一个window可以包含多个pane。实例： tmux: session 0: window 0: pane 0 pane 1 pane 2 ... window 1window 2 ... session 1 session 2 ... <strong>操作：</strong> (1)tmux：新建一个session，其中包含一个window，window中包含一个pane，pane里打开了一个shell对话框。(2) 按下Ctrl + a后手指松开，然后按%：将当前pane左右平分成两个pane。 (3)按下Ctrl + a后手指松开，然后按"：将当前pane上下平分成两个pane。 (4) Ctrl+d：关闭当前pane；如果当前window的所有pane均已关闭，则自动关闭window；如果当前session的所有window均已关闭，则自动关闭session。(5) 鼠标点击可以选pane。 (6) 按下ctrl +a后手指松开，然后按方向键：选择相邻的pane。 (7)鼠标拖动pane之间的分割线，可以调整分割线的位置。 (8) 按住ctrl +a的同时按方向键，可以调整pane之间分割线的位置。 (9) 按下ctrl +a后手指松开，然后按z：将当前pane全屏/取消全屏。 (10) 按下ctrl +a后手指松开，然后按d：挂起当前session。 (11) tmuxa：打开之前挂起的session。 (12) 按下ctrl +a后手指松开，然后按s：选择其它session。 方向键 —— 上：选择上一项session/window/pane 方向键 —— 下：选择下一项 session/window/pane 方向键—— 右：展开当前项 session/window 方向键 —— 左：闭合当前项 session/window(13) 按下Ctrl +a后手指松开，然后按c：在当前session中创建一个新的window。 (14) 按下Ctrl+ a后手指松开，然后按w：选择其他window，操作方法与(12)完全相同。 (15)按下Ctrl + a后手指松开，然后按PageUp：翻阅当前pane内的内容。 (16)鼠标滚轮：翻阅当前pane内的内容。 (17)在tmux中选中文本时，需要按住shift键。（仅支持Windows和Linux，不支持Mac，不过该操作并不是必须的，因此影响不大）(18) tmux中复制/粘贴文本的通用方式： (1) 按下Ctrl + a后松开手指，然后按[(2) 用鼠标选中文本，被选中的文本会被自动复制到tmux的剪贴板 (3) 按下Ctrl+ a后松开手指，然后按]，会将剪贴板中的内容粘贴到光标处</p><p><strong>2.vim教程</strong> <strong>功能：</strong> (1)命令行模式下的文本编辑器。 (2)根据文件扩展名自动判别编程语言。支持代码缩进、代码高亮等功能。 (3)使用方式：vim filename 如果已有该文件，则打开它。如果没有该文件，则打开个一个新的文件，并命名为filename<strong>模式：</strong> (1) 一般命令模式默认模式。命令输入方式：类似于打游戏放技能，按不同字符，即可进行不同操作。可以复制、粘贴、删除文本等。(2) 编辑模式 在一般命令模式里按下i，会进入编辑模式。按下ESC会退出编辑模式，返回到一般命令模式。 (3) 命令行模式在一般命令模式里按下:/?三个字母中的任意一个，会进入命令行模式。命令行在最下面。可以查找、替换、保存、退出、配置编辑器等。 <strong>操作：</strong> (1)i：进入编辑模式 (2) ESC：进入一般命令模式 (3) h 或左箭头键：光标向左移动一个字符 (4) j 或 向下箭头：光标向下移动一个字符(5) k 或 向上箭头：光标向上移动一个字符 (6) l 或向右箭头：光标向右移动一个字符 (7)n&lt;Space&gt;：n表示数字，按下数字后再按空格，光标会向右移动这一行的n个字符(8) 0 或 功能键[Home]：光标移动到本行开头 (9) $ 或功能键[End]：光标移动到本行末尾 (10) G：光标移动到最后一行 (11) :n 或nG：n为数字，光标移动到第n行 (12) gg：光标移动到第一行，相当于1G (13)n&lt;Enter&gt;：n为数字，光标向下移动n行 (14)/word：向光标之下寻找第一个值为word的字符串。 (15)?word：向光标之上寻找第一个值为word的字符串。 (16) n：重复前一个查找操作(17) N：反向重复前一个查找操作 (18):n1,n2s/word1/word2/g：n1与n2为数字，在第n1行与n2行之间寻找word1这个字符串，并将该字符串替换为word2(19) :1,$s/word1/word2/g：将全文的word1替换为word2 (20):1,$s/word1/word2/gc：将全文的word1替换为word2，且在替换前要求用户确认。(21) v：选中文本<br />(22) d：删除选中的文本 (23) dd: 删除当前行 (24) y：复制选中的文本 (25)yy: 复制当前行 (26) p: 将复制的数据在光标的下一行/下一个位置粘贴 (27)u：撤销 (28) Ctrl + r：取消撤销 (29) 大于号&gt;：将选中的文本整体向右缩进一次 (30) 小于号&lt;：将选中的文本整体向左缩进一次 (31) :w 保存 (32) :w! 强制保存 (33):q 退出 (34) :q! 强制退出 (35) :wq 保存并退出 (36) :set paste设置成粘贴模式，取消代码自动缩进 (37) :set nopaste取消粘贴模式，开启代码自动缩进 (38) :set nu 显示行号 (39) :set nonu隐藏行号 (40) gg=G：将全文代码格式化 (41) :noh 关闭查找关键词高亮 (42)Ctrl + q：当vim卡死时，可以取消当前正在执行的命令<strong>异常处理：</strong>每次用vim编辑文件时，会自动创建一个.filename.swp的临时文件。如果打开某个文件时，该文件的swp文件已存在，则会报错。此时解决办法有两种：(1) 找到正在打开该文件的程序，并退出 (2) 直接删掉该swp文件即可</p></blockquote><h2 id="shell语法">3.shell语法</h2><p>​ <strong>描述：</strong>多敲多敲多敲！</p><h3 id="概论">1.概论：</h3><blockquote><p>shell是我们通过命令行与操作系统沟通的<strong>语言</strong>，跟我们正常学习的C/C++类似就是一个交互语言。</p><p>shell脚本可以直接在命令行中执行，也可以将一套逻辑组织成<strong>一个文件</strong>，方便复用。AC Terminal中的命令行可以看成是一个“shell脚本在逐行执行”。</p><p>Linux中常见的shell脚本有很多种，常见的有：</p><ul><li>Bourne Shell(/usr/bin/sh或/bin/sh)</li><li><font color='blue'>Bourne Again Shell(/bin/bash)</font></li><li>C Shell(/usr/bin/csh)</li><li>K Shell(/usr/bin/ksh)</li><li>zsh</li><li>…</li></ul><p>Linux系统中一般默认使用bash，所以接下来讲解bash中的语法。</p><p><strong>文件开头需要写#!/bin/bash，指明bash为脚本解释器。</strong></p><hr /><p><strong>学习技巧</strong></p><p>不要死记硬背，遇到含糊不清的地方，可以在 <code>Terminal</code>里实际运行一遍。</p><p><strong>脚本示例</strong></p><p>新建一个 <code>test.sh</code> 文件，内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">! /bin/bash</span><br>echo &quot;Hello World!&quot;<br></code></pre></td></tr></table></figure><hr /><p><strong>运行方式</strong></p><p>作为可执行文件 -&gt; <strong>需要权限</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">acs@9e0ebfcd82d7:~\$ chmod +x test.sh  # 使脚本具有可执行权限<br>acs@9e0ebfcd82d7:~\$ ./test.sh  # 当前路径下执行<br>Hello World!  # 脚本输出<br>acs@9e0ebfcd82d7:~$ /home/acs/test.sh  # 绝对路径下执行<br>Hello World!  # 脚本输出<br>acs@9e0ebfcd82d7:~$ ~/test.sh  # 家目录路径下执行<br>Hello World!  # 脚本输出<br></code></pre></td></tr></table></figure><p>用解释器执行 -&gt; <strong>无需权限</strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">acs<span class="hljs-variable">@9e0ebfcd82d7</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>bash test.sh<br><span class="hljs-title class_">Hello</span> <span class="hljs-title class_">World</span>!  <span class="hljs-comment"># 脚本输出</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="注释">2.注释:</h3><blockquote><p>单行注释 每行中 <code>#</code> 之后的内容均是注释。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">这是一行注释</span><br><br>echo &#x27;Hello World&#x27;  #  这也是注释<br></code></pre></td></tr></table></figure><hr /><p><strong>多行注释:</strong></p><p>格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">:&lt;&lt;EOF<br>第一行注释<br>第二行注释<br>第三行注释<br>EOF<br></code></pre></td></tr></table></figure><p>其中 <code>EOF</code> 可以换成其它任意字符串。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">:&lt;&lt;abc<br>第一行注释<br>第二行注释<br>第三行注释<br>abc<br><br>:&lt;&lt;!<br>第一行注释<br>第二行注释<br>第三行注释<br>!<br></code></pre></td></tr></table></figure></blockquote><h3 id="变量">3.变量：</h3><blockquote><p>定义变量 定义变量，不需要加 <code>$</code> 符号，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">name1=&#x27;yxc&#x27;  # 单引号定义字符串<br>name2=&quot;yxc&quot;  # 双引号定义字符串<br>name3=yxc    # 也可以不加引号，同样表示字符串<br></code></pre></td></tr></table></figure><hr /><p><strong>使用变量:</strong></p><p>使用变量，需要加上 <code>$</code> 符号，或者 <code>$&#123;&#125;</code>符号。花括号是可选的，主要为了帮助解释器识别变量边界。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">name=yxc<br>echo $name  # 输出yxc<br>echo $&#123;name&#125;  # 输出yxc<br>echo $&#123;name&#125;acwing  # 输出yxcacwing<br>echo $&#123;name&#125;’s acwing is such a good website to learn having fun # 输出 yxc acwing is such a good website to learn having fun<br></code></pre></td></tr></table></figure><hr /><p><strong>只读变量:</strong></p><p>使用 <code>readonly</code> 或者 <code>declare</code>可以将变量变为只读。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">name=yxc<br>readonly name<br>declare -r name  # 两种写法均可<br><br>name=abc  # 会报错，因为此时name只读<br></code></pre></td></tr></table></figure><hr /><p><strong>删除变量:</strong></p><p><code>unset</code> 可以删除变量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">name=yxc<br>unset name<br>echo $name  # 输出空行<br></code></pre></td></tr></table></figure><hr /><p><strong>变量类型:</strong></p><ol type="1"><li><p>自定义变量（局部变量）</p><p>子进程不能访问的变量</p></li><li><p>环境变量（全局变量）</p><p>子进程可以访问的变量</p></li></ol><p>自定义变量改成环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">acs@9e0ebfcd82d7:~$ name=yxc  # 定义变量<br>acs@9e0ebfcd82d7:~$ export name  # 第一种方法<br>acs@9e0ebfcd82d7:~$ declare -x name  # 第二种方法<br></code></pre></td></tr></table></figure><p>环境变量改为自定义变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">acs@9e0ebfcd82d7:~$ export name=yxc  # 定义环境变量<br>acs@9e0ebfcd82d7:~$ declare +x name  # 改为自定义变量<br></code></pre></td></tr></table></figure><hr /><p><strong>字符串</strong></p><p>字符串可以用单引号，也可以用双引号，也可以不用引号。</p><p>单引号与双引号的区别：</p><ul><li>单引号中的内容会原样输出，不会执行、不会取变量；</li><li>双引号中的内容可以执行、可以取变量；</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">name=yxc  # 不用引号<br>echo &#x27;hello, $name \&quot;hh\&quot;&#x27;  # 单引号字符串，输出 hello, $name \&quot;hh\&quot;<br>echo &quot;hello, $name \&quot;hh\&quot;&quot;  # 双引号字符串，输出 hello, yxc &quot;hh&quot;<br></code></pre></td></tr></table></figure><p>获取字符串长度</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">name=&quot;yxc&quot;<br>echo $&#123;#name&#125;  # 输出3<br></code></pre></td></tr></table></figure><p>提取子串</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">name=&quot;hello, yxc&quot;<br>echo $&#123;name:0:5&#125;  # 提取从0开始的5个字符<br></code></pre></td></tr></table></figure></blockquote><h3 id="默认变量">4.默认变量：</h3><p>​ <strong>描述：</strong></p><blockquote><p>文件参数变量 在执行shell脚本时，可以向脚本传递参数。<code>$1</code>是第一个参数，<code>$2</code>是第二个参数，以此类推。特殊的，<code>$0</code>是文件名（包含路径）。例如：</p><p>创建文件 <code>test.sh</code> ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs SHELL"><span class="hljs-meta prompt_">#</span><span class="language-bash">! /bin/bash</span><br><br>echo &quot;文件名：&quot;$0<br>echo &quot;第一个参数：&quot;$1<br>echo &quot;第二个参数：&quot;$2<br>echo &quot;第三个参数：&quot;$3<br>echo &quot;第四个参数：&quot;$4<br></code></pre></td></tr></table></figure><p>然后执行脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">acs@9e0ebfcd82d7:~$ chmod +x test.sh <br>acs@9e0ebfcd82d7:~$ ./test.sh 1 2 3 4<br>文件名：./test.sh<br>第一个参数：1<br>第二个参数：2<br>第三个参数：3<br>第四个参数：4<br></code></pre></td></tr></table></figure><hr /><p><strong>其他参数相关变量</strong></p><table><thead><tr class="header"><th><strong>参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr class="odd"><td><code>$#</code></td><td>代表文件传入的参数个数，如上例中值为4</td></tr><tr class="even"><td><code>$*</code></td><td>由所有参数构成的用空格隔开的字符串，如上例中值为<code>"$1 $2 $3 $4"</code></td></tr><tr class="odd"><td><code>$@</code></td><td>每个参数分别用双引号括起来的字符串，如上例中值为<code>"$1" "$2" "$3" "$4"</code></td></tr><tr class="even"><td><code>$$</code></td><td>脚本当前运行的进程ID</td></tr><tr class="odd"><td><code>$?</code></td><td>上一条命令的退出状态（注意不是stdout，而是exitcode）。0表示正常退出，其他值表示错误</td></tr><tr class="even"><td><code>$(command)</code></td><td>返回<code>command</code>这条命令的stdout（可嵌套）</td></tr><tr class="odd"><td>`command`</td><td>返回<code>command</code>这条命令的stdout（不可嵌套）</td></tr></tbody></table></blockquote><h3 id="数组">5.数组</h3><p>​ <strong>描述：</strong></p><blockquote><p>数组中可以存放多个不同类型的值，只支持一维数组，初始化时不需要指明数组大小。数组<strong>下标从0开始</strong>。</p><p><strong>特殊：</strong>shell语法中的数组支持开放指定位置i的数组内容的，实际数组大小不是最大下标而是当前数组用了多少个下标的内容就是多少</p><hr /><p><strong>定义：</strong></p><p>数组用小括号表示，元素之间空格隔开。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">array=(1 abc &quot;def&quot; yxc)<br></code></pre></td></tr></table></figure><p>也可以直接定义数组中的某个元素的值：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">array[0]=1<br>array[1]=abc<br>array[2]=&quot;def&quot;<br>array[3]=yxc<br></code></pre></td></tr></table></figure><hr /><p><strong>读取数组中某个元素的值</strong></p><p>格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;array[index]&#125;</span><br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">array=(1 abc &quot;def&quot; yxc)<br>echo $&#123;array[0]&#125; # 输出数组中单独一个元素的值<br>echo $&#123;array[1]&#125;<br>echo $&#123;array[2]&#125;<br>echo $&#123;array[3]&#125;<br></code></pre></td></tr></table></figure><hr /><p><strong>读取整个数组</strong></p><p>格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;array[@]&#125;  <span class="hljs-comment"># 第一种写法 将数组中所有的值输出到一行</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;array[*]&#125;  <span class="hljs-comment"># 第二种写法 将数组中所有的值输出到一行</span></span><br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">array=(1 abc &quot;def&quot; yxc)<br><br>echo $&#123;array[@]&#125;  # 第一种写法<br>echo $&#123;array[*]&#125;  # 第二种写法<br></code></pre></td></tr></table></figure><hr /><p><strong>数组长度</strong></p><p>类似于字符串</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;<span class="hljs-comment">#array[@]&#125;  # 第一种写法 输出的是数组中元素的个数</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;<span class="hljs-comment">#array[*]&#125;  # 第二种写法 输出的是数组中元素的个数</span></span><br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">array=(1 abc &quot;def&quot; yxc)<br><br>echo $&#123;#array[@]&#125;  # 第一种写法<br>echo $&#123;#array[*]&#125;  # 第二种写法<br></code></pre></td></tr></table></figure></blockquote><h3 id="expr命令">6.expr命令</h3><p>​ <strong>描述：</strong>其实是第三方实现的: 命令窗输入<code>type expr</code> 输出 <code>expr is /usr/bin/expr</code></p><blockquote><p><code>expr</code>命令用于求表达式的值，格式为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">expr 表达式<br></code></pre></td></tr></table></figure><p>表达式说明：</p><ul><li>用空格隔开每一项</li><li>用反斜杠放在<code>shell</code>特定的字符前面（发现表达式运行错误时，可以试试转义）</li><li>对包含空格和其他特殊字符的字符串要用引号括起来</li><li><code>expr</code>会在<code>stdout</code>中输出结果。如果为逻辑关系表达式，则结果为真时，<code>stdout</code>输出<code>1</code>，否则输出<code>0</code>。</li><li><code>expr</code>的<code>exit code</code>：如果为逻辑关系表达式，则结果为真时，<code>exit code</code>为<code>0</code>，否则为<code>1</code>。</li></ul><hr /><p><strong>字符串表达式</strong></p><ul><li><p><code>length STRING</code></p><p>返回<code>STRING</code>的长度</p></li><li><p><code>index STRING CHARSET</code></p><p><code>CHARSET</code>中任意单个字符在<code>STRING</code>中最前面的字符位置，<strong>下标从1开始</strong>。如果在<code>STRING</code>中完全不存在<code>CHARSET</code>中的字符，则返回0。</p></li><li><p><code>substr STRING POSITION LENGTH</code></p><p>返回<code>STRING</code>字符串中从<code>POSITION</code>开始，长度最大为<code>LENGTH</code>的子串。如果<code>POSITION</code>或<code>LENGTH</code>为负数，0或非数值，则返回空字符串。</p></li></ul><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">str=&quot;Hello World!&quot;<br><br>echo `expr length &quot;$str&quot;`  # ``不是单引号，表示执行该命令，输出12<br>echo `expr index &quot;$str&quot; aWd`  # 输出7，下标从1开始<br>echo `expr substr &quot;$str&quot; 2 3`  # 输出 ell<br></code></pre></td></tr></table></figure><hr /><p><strong>整数表达式</strong></p><p><code>expr</code>支持普通的算数运算，算术表达式优先级低于字符串表达式，高于逻辑表达式</p><ul><li><p><code>+ -</code>加减运算。两端参数会转换为整数，如果转换失败则报错。</p></li><li><p><code>/ %</code>乘，除，取模运算。两端参数会转换为整数，如果转换失败则报错。</p></li><li><p><code>()</code>可以改变优先级，但需要用反斜杠转义</p></li></ul><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">a=3<br>b=4<br><br>echo `expr $a + $b`  # 输出7<br>echo `expr $a - $b`  # 输出-1<br>echo `expr $a \* $b`  # 输出12，*需要转义<br>echo `expr $a / $b`  # 输出0，整除<br>echo `expr $a % $b` # 输出3<br>echo `expr \( $a + 1 \) \* \( $b + 1 \)`  # 输出20，值为(a + 1) * (b + 1)<br></code></pre></td></tr></table></figure><hr /><p><strong>逻辑表达式</strong></p><ul><li><p><code>|</code></p></li><li><p>如果第一个参数非空且非0，则返回第一个参数的值，否则返回第二个参数的值，但要求第二个参数的值也是非空或非0，否则返回0。如果第一个参数是非空或非0时，不会计算第二个参数。</p></li><li><p><code>&amp;</code></p></li><li><p>如果两个参数都非空且非0，则返回第一个参数，否则返回0。如果第一个参为0或为空，则不会计算第二个参数。</p></li><li><p><code>&lt; &lt;= = == != &gt;= &gt;</code></p></li><li><p>比较两端的参数，如果为true，则返回1，否则返回0。”==”是”=”的同义词。”expr”首先尝试将两端参数转换为整数，并做算术比较，如果转换失败，则按字符集排序规则做字符比较。</p></li><li><p><code>()</code> 可以改变优先级，但需要用反斜杠转义</p></li></ul><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">a=3<br>b=4<br><br>echo `expr $a \&gt; $b`  # 输出0，&gt;需要转义<br>echo `expr $a &#x27;&lt;&#x27; $b`  # 输出1，也可以将特殊字符用引号引起来<br>echo `expr $a &#x27;&gt;=&#x27; $b`  # 输出0<br>echo `expr $a \&lt;\= $b`  # 输出1<br><br>c=0<br>d=5<br><br>echo `expr $c \&amp; $d`  # 输出0<br>echo `expr $a \&amp; $b`  # 输出3<br>echo `expr $c \| $d`  # 输出5<br>echo `expr $a \| $b`  # 输出3<br></code></pre></td></tr></table></figure></blockquote><h3 id="read命令">7.read命令</h3><p>​ <strong>描述：</strong></p><blockquote><p><code>read</code>命令用于从标准输入中读取单行数据。当读到文件结束符时，<code>exit code</code>为1，否则为0。</p><p>参数说明</p><ul><li><code>-p</code>: 后面可以接提示信息</li><li><code>-t</code>：后面跟秒数，定义输入字符的等待时间，超过等待时间后会自动忽略此命令</li></ul><p>实例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs SHELL">acs@9e0ebfcd82d7:~$ read name  # 读入name的值<br>acwing yxc  # 标准输入<br>acs@9e0ebfcd82d7:~$ echo $name  # 输出name的值<br>acwing yxc  #标准输出<br>acs@9e0ebfcd82d7:~$ read -p &quot;Please input your name: &quot; -t 30 name  # 读入name的值，等待时间30秒<br>Please input your name: acwing yxc  # 标准输入<br>acs@9e0ebfcd82d7:~$ echo $name  # 输出name的值<br>acwing yxc  # 标准输出<br></code></pre></td></tr></table></figure></blockquote><h3 id="echo命令">8.echo命令</h3><p>​ <strong>描述：</strong></p><blockquote><p><code>echo</code>用于输出字符串。命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo STRING<br></code></pre></td></tr></table></figure><hr /><p><strong>显示普通的字符串</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &quot;Hello AC Terminal&quot;<br>echo Hello AC Terminal  # 引号可以省略<br></code></pre></td></tr></table></figure><hr /><p><strong>显示转义字符</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &quot;\&quot;Hello AC Terminal\&quot;&quot;  # 注意只能使用双引号，如果使用单引号，则不转义<br>echo \&quot;Hello AC Terminal\&quot;  # 也可以省略双引号<br></code></pre></td></tr></table></figure><hr /><p><strong>显示变量</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">name=yxc<br>echo &quot;My name is $name&quot;  # 输出 My name is yxc<br></code></pre></td></tr></table></figure><hr /><p><strong>显示换行</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo -e &quot;Hi\n&quot;  # -e 开启转义<br>echo &quot;acwing&quot;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">Hi<br><br>acwing<br></code></pre></td></tr></table></figure><hr /><p><strong>显示不换行</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo -e &quot;Hi \c&quot; # -e 开启转义 \c 不换行<br>echo &quot;acwing&quot;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Hi acwing<br></code></pre></td></tr></table></figure><hr /><p><strong>显示结果定向至文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &quot;Hello World&quot; &gt; output.txt  # 将内容以覆盖的方式输出到output.txt中<br></code></pre></td></tr></table></figure><hr /><p><strong>原样输出字符串，不进行转义或取变量（用单引号）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell'">name=acwing<br>echo &#x27;$name\&quot;&#x27;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">name\&quot;</span><br></code></pre></td></tr></table></figure><hr /><p><strong>显示命令的执行结果</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo `date`<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Wed Sep 1 11:45:33 CST 2021<br></code></pre></td></tr></table></figure></blockquote><h3 id="printf命令">9.printf命令</h3><p>​ <strong>描述：</strong></p><blockquote><p><code>printf</code>命令用于格式化输出，类似于<code>C/C++</code>的<code>printf</code>函数</p><p>默认<strong>不会在字符串末尾添加换行符</strong></p><p>命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">printf format-string [arguments...]<br></code></pre></td></tr></table></figure><hr /><p><strong>用法示例</strong></p><p>脚本内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">printf &quot;%10d.\n&quot; 123  # 占10位，右对齐<br>printf &quot;%-10.2f.\n&quot; 123.123321  # 占10位，保留2位小数，左对齐<br>printf &quot;My name is %s\n&quot; &quot;yxc&quot;  # 格式化输出字符串<br>printf &quot;%d * %d = %d\n&quot;  2 3 `expr 2 \* 3` # 表达式的值作为参数<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">    123.<br>123.12    .<br>My name is yxc<br>2 * 3 = 6<br></code></pre></td></tr></table></figure></blockquote><h3 id="test命令与判断符号">10.test命令与判断符号[]</h3><p>​ <strong>描述：</strong></p><blockquote><p><strong>逻辑运算符&amp;&amp;和||</strong></p><ul><li><code>&amp;&amp;</code> 表示与，<code>||</code> 表示或</li><li>二者具有短路原则：<code>expr1 &amp;&amp; expr2</code>：当<code>expr1</code>为假时，直接忽略<code>expr2</code><code>expr1 || expr2</code>：当<code>expr1</code>为真时，直接忽略<code>expr2</code></li><li>表达式的<code>exit code</code>为0，表示真；为非零，表示假。（与C/C++中的定义相反）</li></ul><hr /><p><strong>test命令</strong></p><p>在命令行中输入<code>man test</code>，可以查看<code>test</code>命令的用法。</p><ul><li><p><code>test</code>命令用于判断文件类型，以及对变量做比较。</p></li><li><p><code>test</code>命令用<code>exit code</code>返回结果，而不是使用<code>stdout</code>。0表示真，非0表示假。</p></li></ul><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">test 2 -lt 3  # 为真，返回值为0<br>echo $?  # 输出上个命令的返回值，输出0<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">acs@9e0ebfcd82d7:~$ ls  # 列出当前目录下的所有文件<br>homework  output.txt  test.sh  tmp<br>acs@9e0ebfcd82d7:~$ test -e test.sh &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;<br>exist  # test.sh 文件存在<br>acs@9e0ebfcd82d7:~$ test -e test2.sh &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;<br>Not exist  # testh2.sh 文件不存在<br></code></pre></td></tr></table></figure><hr /><p><strong>文件类型判断</strong></p><p>命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">test -e filename  # 判断文件是否存在<br></code></pre></td></tr></table></figure><table><thead><tr class="header"><th><strong>测试参数</strong></th><th><strong>代表意义</strong></th></tr></thead><tbody><tr class="odd"><td>-e</td><td>文件是否存在</td></tr><tr class="even"><td>-f</td><td>是否为(普通)文件</td></tr><tr class="odd"><td>-d</td><td>是否为目录</td></tr></tbody></table><hr /><p><strong>文件权限判断</strong></p><p>命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">test -r filename  # 判断文件是否可读<br></code></pre></td></tr></table></figure><table><thead><tr class="header"><th><strong>测试参数</strong></th><th><strong>代表意义</strong></th></tr></thead><tbody><tr class="odd"><td>-r</td><td>文件是否可读</td></tr><tr class="even"><td>-w</td><td>文件是否可写</td></tr><tr class="odd"><td>-x</td><td>文件是否可执行</td></tr><tr class="even"><td>-s</td><td>是否为非空文件</td></tr></tbody></table><hr /><p><strong>整数间的比较</strong></p><p>命令比较：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">test $a -eq $b  # a是否等于b<br></code></pre></td></tr></table></figure><table><thead><tr class="header"><th><strong>测试参数</strong></th><th><strong>代表意义</strong></th></tr></thead><tbody><tr class="odd"><td>-eq</td><td>a是否等于b</td></tr><tr class="even"><td>-ne</td><td>a是否不等于b</td></tr><tr class="odd"><td>-gt</td><td>a是否大于b</td></tr><tr class="even"><td>-lt</td><td>a是否小于b</td></tr><tr class="odd"><td>-ge</td><td>a是否大于等于b</td></tr><tr class="even"><td>-le</td><td>a是否小于等于b</td></tr></tbody></table><hr /><p><strong>字符串比较</strong></p><table><thead><tr class="header"><th><strong>测试参数</strong></th><th><strong>代表意义</strong></th></tr></thead><tbody><tr class="odd"><td>test -z STRING</td><td>判断STRING是否为空，如果为空，则返回true</td></tr><tr class="even"><td>test -n STRING</td><td>判断STRING是否非空，如果非空，则返回true（-n可以省略）</td></tr><tr class="odd"><td>test str1 == str2</td><td>判断str1是否等于str2</td></tr><tr class="even"><td>test str1 != str2</td><td>判断str1是否不等于str2</td></tr></tbody></table><hr /><p><strong>多重条件判定</strong></p><p>命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">test -r filename -a -x filename<br></code></pre></td></tr></table></figure><table><thead><tr class="header"><th><strong>测试参数</strong></th><th><strong>代表意义</strong></th></tr></thead><tbody><tr class="odd"><td>-a</td><td>两条件是否同时成立</td></tr><tr class="even"><td>-o</td><td>两条件是否至少一个成立</td></tr><tr class="odd"><td>！</td><td>取反。如 test ! -x file，当file不可执行时，返回true</td></tr></tbody></table><hr /><p><strong>判断符号[]</strong></p><p><code>[]</code>与<code>test</code>用法几乎一模一样，更常用于<code>if</code>语句中。另外<code>[[]]</code>是<code>[]</code>的加强版，支持的特性更多。</p><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[ 2 -lt 3 ]  # 为真，返回值为0<br>echo $?  # 输出上个命令的返回值，输出0<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">acs@9e0ebfcd82d7:~$ ls  # 列出当前目录下的所有文件<br>homework  output.txt  test.sh  tmp<br>acs@9e0ebfcd82d7:~$ [ -e test.sh ] &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;<br>exist  # test.sh 文件存在<br>acs@9e0ebfcd82d7:~$ [ -e test2.sh ] &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;<br>Not exist  # testh2.sh 文件不存在<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li><code>[]</code>内的每一项都要用空格隔开</li><li>中括号内的变量，最好用双引号括起来</li><li>中括号内的常数，最好用单或双引号括起来</li></ul><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">name=&quot;acwing yxc&quot;<br>[ $name == &quot;acwing yxc&quot; ]  # 错误，等价于 [ acwing yxc == &quot;acwing yxc&quot; ]，参数太多<br>[ &quot;$name&quot; == &quot;acwing yxc&quot; ]  # 正确<br></code></pre></td></tr></table></figure></blockquote><h3 id="判断语句">11.判断语句</h3><p>​ <strong>描述：</strong></p><blockquote><p><strong>if…then形式</strong>类似于<code>C/C++</code>中的<code>if-else</code>语句。</p><hr /><p><strong>单层if</strong></p><p>命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">if condition<br>then<br> 语句1<br> 语句2<br> ...<br>fi<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">a=3<br>b=4<br><br>if [ &quot;$a&quot; -lt &quot;$b&quot; ] &amp;&amp; [ &quot;$a&quot; -gt 2 ]<br>then<br> echo $&#123;a&#125;在范围内<br>fi<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">3在范围内<br></code></pre></td></tr></table></figure><hr /><p><strong>单层if-else</strong></p><p>命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">if condition<br>then<br> 语句1<br> 语句2<br> ...<br>else<br> 语句1<br> 语句2<br> ...<br>fi<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">a=3<br>b=4<br><br>if ! [ &quot;$a&quot; -lt &quot;$b&quot; ]<br>then<br> echo $&#123;a&#125;不小于$&#123;b&#125;<br>else<br> echo $&#123;a&#125;小于$&#123;b&#125;<br>fi<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">3小于4<br></code></pre></td></tr></table></figure><hr /><p><strong>多层if-elif-elif-else</strong></p><p>命令格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">if condition<br>then<br> 语句1<br> 语句2<br> ...<br>elif condition<br>then<br> 语句1<br> 语句2<br> ...<br>elif condition<br>then<br> 语句1<br> 语句2<br>else<br> 语句1<br> 语句2<br> ...<br>fi<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">a=4<br><br>if [ $a -eq 1 ]<br>then<br> echo $&#123;a&#125;等于1<br>elif [ $a -eq 2 ]<br>then<br> echo $&#123;a&#125;等于2<br>elif [ $a -eq 3 ]<br>then<br> echo $&#123;a&#125;等于3<br>else<br> echo 其他<br>fi<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">其他<br></code></pre></td></tr></table></figure><hr /><p><strong>case...esac形式</strong></p><p>类似于<code>C/C++</code>中的<code>switch</code>语句</p><p>命令格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">case $变量名称 in<br> 值1)<br>     语句1<br>     语句2<br>     ...<br>     ;;  # 类似于C/C++中的break<br> 值2)<br>     语句1<br>     语句2<br>     ...<br>     ;;<br> *)  # 类似于C/C++中的default<br>     语句1<br>     语句2<br>     ...<br>     ;;<br>esac<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">a=4<br><br>case $a in<br> 1)<br>     echo $&#123;a&#125;等于1<br>     ;;<br> 2)<br>     echo $&#123;a&#125;等于2<br>     ;;<br> 3)                                                <br> echo $&#123;a&#125;等于3<br>  ;;<br> *)<br>echo 其他<br> ;;  s<br>esac<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">其他<br></code></pre></td></tr></table></figure></blockquote><h3 id="循环语句">12.循环语句</h3><p>​ <strong>描述：</strong></p><blockquote><p><strong>for…in…do…done</strong></p><p>命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">for var in val1 val2 val3<br>do<br>语句1<br>语句2<br>...<br>done<br></code></pre></td></tr></table></figure><p>示例1，输出a 2 cc，每个元素一行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">for i in a 2 cc<br>do<br>echo $i<br>done<br></code></pre></td></tr></table></figure><p>示例2，输出当前路径下的所有文件名，每个文件名一行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">for file in `ls`<br>do<br>echo $file<br>done<br></code></pre></td></tr></table></figure><p>示例3，输出1-10</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">for i in $(seq 1 10)<br>do<br>echo $i<br>done<br></code></pre></td></tr></table></figure><p>示例4，使用<code>&#123;1...10&#125;</code>或者<code>&#123;a...z&#125;</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">for i in &#123;a..z&#125;<br>do<br>echo $i<br>done<br></code></pre></td></tr></table></figure><hr /><p><strong>for ((…;…;…)) do…done</strong></p><p>命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">for ((expression; condition; expression))<br>do<br>语句1<br>语句2<br>done<br></code></pre></td></tr></table></figure><p>示例，输出1-10，每一个数占一行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">for (( i = 1; i &lt;= 10; i ++ ))<br>do<br>echo $i<br>done<br></code></pre></td></tr></table></figure><hr /><p><strong>while...do...done循环</strong></p><p>命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">while condition<br>do<br>语句1<br>语句2<br>...<br>done<br></code></pre></td></tr></table></figure><p>示例，文件结束符<code>Ctrl+d</code>，输入文件结束符后<code>read</code>指令返回<code>false</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">while read name<br>do<br>echo $name<br>done<br></code></pre></td></tr></table></figure><hr /><p><strong>until...do...done循环</strong></p><p>当条件为真时结束</p><p>命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">until condition<br>do<br>语句1<br>语句2<br>...<br>done<br></code></pre></td></tr></table></figure><p>示例，当用户输入<code>yes</code>或者<code>YES</code>时结束，否则一直等待读入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">until [ &quot;$&#123;word&#125;&quot; == &quot;yes&quot; ] || [ &quot;$&#123;word&#125;&quot; == &quot;YES&quot; ]<br>do<br>read -p &quot;Please input yes/YES to stop this program: &quot; word<br>done<br></code></pre></td></tr></table></figure><hr /><p><strong>break命令</strong></p><p>跳出当前一层循环，注意与<code>C/C++</code>不同的是：<code>break</code>不能跳出<code>case</code>语句。</p><p>示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">while read name<br>do<br>for (( i=1; i &lt;= 10; i++ ))<br>do<br>  case $i in<br>      8)<br>          break<br>          ;;<br>      *)<br>          echo $i<br>          ;;<br>  esac<br>done<br>done<br></code></pre></td></tr></table></figure><p>该示例每读入非EOF的字符串，会输出一遍1-7</p><p>该程序可以输入<code>Ctrl+d</code>文件结束符来结束，也可以直接用<code>Ctrl+c</code>杀掉该进程。</p><hr /><p><strong>contiune命令</strong></p><p>跳出当前循环。</p><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">for ((i=1;i&lt;=10;i++))<br>do<br>if [ `expr $i % 2` -eq 0 ]<br>then<br>  continue<br>fi<br>echo $i<br>done<br></code></pre></td></tr></table></figure><p>该程序输出1-10中的所有奇数</p><p><strong>死循环的处理方式</strong></p><p>如果<code>AC Terminal</code>可以打开该程序，则输入<code>Ctrl+c</code>即可。</p><p>否则可以直接关闭进程：</p><ol type="1"><li>使用<code>top</code>命令找到进程的<code>PID</code></li><li>输入<code>kill -9 PID</code>即可关掉此进程</li></ol></blockquote><h3 id="函数">13.函数</h3><p>​ <strong>描述：</strong></p><blockquote><p><code>bash</code>中的函数类似于<code>C/C++</code>中的函数，但<code>return</code>的返回值与<code>C/C++</code>不同，返回的是<code>exit code</code>，取值为<code>0-255</code>，<code>0</code>表示正常结束。</p><p>如果想获取函数的输出结果，可以通过<code>echo</code>输出到<code>stdout</code>中，然后通过<code>$(function_name)</code>来获取<code>stdout</code>中的结果。</p><p>函数的<code>return</code>值可以通过<code>$?</code>来获取。</p><p>命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[function] func_name() &#123;  # function关键字可以省略<br>语句1<br>语句2<br>...<br>&#125;<br></code></pre></td></tr></table></figure><hr /><p><strong>不获取<code>return</code>值和<code>stdout</code>值</strong></p><p>示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">func() &#123;<br>name=yxc<br>echo &quot;Hello $name&quot;<br>&#125;<br><br>func<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Hello yxc<br></code></pre></td></tr></table></figure><hr /><p><strong>获取<code>return</code>值和<code>stdout</code>值</strong></p><p>不写<code>return</code>时，默认<code>return 0</code></p><p>示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">func() &#123;<br>name=yxc<br>echo &quot;Hello $name&quot;<br><br>return 123<br>&#125;<br><br>output=$(func)<br>ret=$?<br><br>echo &quot;output = $output&quot;<br>echo &quot;return = $ret&quot;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">output = Hello yxc<br>return = 123<br></code></pre></td></tr></table></figure><p><strong>函数的输入参数</strong></p><p>在函数内，<code>$1</code>表示第一个输入参数，<code>$2</code>表示第二个输入参数，依此类推。</p><p>注意：函数内的<code>$0</code>仍然是文件名，而不是函数名。</p><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell">func() &#123;  # 递归计算 $1 + ($1 - 1) + ($1 - 2) + ... + 0<br>word=&quot;&quot;<br>while [ &quot;$&#123;word&#125;&quot; != &#x27;y&#x27; ] &amp;&amp; [ &quot;$&#123;word&#125;&quot; != &#x27;n&#x27; ]<br>do<br>  read -p &quot;要进入func($1)函数吗？请输入y/n：&quot; word<br>done<br><br>if [ &quot;$word&quot; == &#x27;n&#x27; ]<br>then<br>  echo 0<br>  return 0<br>fi  <br><br>if [ $1 -le 0 ] <br>then<br>  echo 0<br>  return 0<br>fi  <br><br>sum=$(func $(expr $1 - 1))<br>echo $(expr $sum + $1)<br>&#125;<br><br>echo $(func 10)<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">55<br></code></pre></td></tr></table></figure><p><strong>函数内部的局部变量</strong></p><p>可以在函数内定义局部变量，作用范围仅在当前函数内。</p><p>可以在递归函数中定义局部变量。</p><p>命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">local 变量名=变量值<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">! /bin/bash</span><br><br>func() &#123;<br>local name=yxc<br>echo $name<br>&#125;<br>func<br><br>echo $name<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">yxc<br><br></code></pre></td></tr></table></figure><p>第一行为函数内的name变量，第二行为函数外调用name变量，会发现此时该变量不存在。</p></blockquote><h3 id="exit命令">14.exit命令</h3><p>​ <strong>描述：</strong></p><blockquote><p><code>exit</code>命令用来退出当前<code>shell</code>进程，并返回一个退出状态；使用<code>$?</code>可以接收这个退出状态。</p><p><code>exit</code>命令可以接受一个整数值作为参数，代表退出状态。如果不指定，默认状态值是<code>0</code>。</p><p><code>exit</code>退出状态只能是一个介于 <code>0~255</code>之间的整数，其中只有 <code>0</code> 表示成功，其它值都表示失败。</p><hr /><p>示例：</p><p>创建<code>test.ch</code>，内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">! /bin/bash</span><br><br>if [ $# -ne 1 ]  # 如果传入参数个数等于1，则正常退出；否则非正常退出。<br>then<br> echo &quot;arguments not valid&quot;<br> exit 1<br>else<br> echo &quot;arguments valid&quot;<br> exit 0<br>fi<br></code></pre></td></tr></table></figure><p>执行该脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">acs@9e0ebfcd82d7:~$ chmod +x test.sh <br>acs@9e0ebfcd82d7:~$ ./test.sh acwing<br>arguments valid<br>acs@9e0ebfcd82d7:~$ echo $?  # 传入一个参数，则正常退出，exit code为0<br>0<br>acs@9e0ebfcd82d7:~$ ./test.sh <br>arguments not valid<br>acs@9e0ebfcd82d7:~$ echo $?  # 传入参数个数不是1，则非正常退出，exit code为1<br>1<br></code></pre></td></tr></table></figure></blockquote><h3 id="文件重定向">15.文件重定向</h3><p>​ <strong>描述：</strong></p><blockquote><p>每个进程默认打开3个文件描述符：</p><ul><li><code>stdin</code>标准输入，从命令行读取数据，文件描述符为0</li><li><code>stdout</code>标准输出，向命令行输出数据，文件描述符为1</li><li><code>stderr</code>标准错误输出，向命令行输出数据，文件描述符为2</li></ul><p>可以用文件重定向将这三个文件重定向到其他文件中。</p><hr /><table><thead><tr class="header"><th><strong>命令</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr class="odd"><td><code>command &gt; file</code></td><td>将<code>stdout</code>重定向到<code>file</code>中</td></tr><tr class="even"><td><code>command &lt; file</code></td><td>将<code>stdin</code>重定向到<code>file</code>中</td></tr><tr class="odd"><td><code>command &gt;&gt; file</code></td><td>将<code>sidout</code>以追加的方式重定向到<code>file</code>中</td></tr><tr class="even"><td><code>command n &gt; file</code></td><td>将文件描述符<code>n</code>重定向到<code>file</code>中</td></tr><tr class="odd"><td><code>command n &gt;&gt; file</code></td><td>将文件描述符<code>n</code>以追加的方式重定向到<code>file</code>中</td></tr></tbody></table><hr /><p><strong>输入和输出重定向</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo -e &quot;Hello \c&quot; &gt; output.txt  # 将stdout重定向到output.txt中<br>echo &quot;World&quot; &gt;&gt; output.txt  # 将字符串追加到output.txt中<br><br>read str &lt; output.txt  # 从output.txt中读取字符串<br><br>echo $str  # 输出结果：Hello World<br></code></pre></td></tr></table></figure><hr /><p><strong>同时重定向stdin和stdout</strong></p><p>创建bash脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">! /bin/bash</span><br><br>read a<br>read b<br><br>echo $(expr &quot;$a&quot; + &quot;$b&quot;)<br></code></pre></td></tr></table></figure><p>创建input.txt，里面的内容为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell'">3<br>4<br></code></pre></td></tr></table></figure><p>执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">acs@9e0ebfcd82d7:~$ chmod +x test.sh  # 添加可执行权限<br>acs@9e0ebfcd82d7:~$ ./test.sh &lt; input.txt &gt; output.txt  # 从input.txt中读取内容，将输出写入output.txt中<br>acs@9e0ebfcd82d7:~$ cat output.txt  # 查看output.txt中的内容<br>7<br></code></pre></td></tr></table></figure></blockquote><h3 id="引入外部脚本">16.引入外部脚本</h3><p>​ <strong>描述：</strong></p><blockquote><p>类似于<code>C/C++</code>中的<code>include</code>操作，<code>bash</code>也可以引入其他文件中的代码。</p><p>语法格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">. filename  # 注意点和文件名之间有一个空格<br><br>或<br><br>source filename<br></code></pre></td></tr></table></figure><hr /><p><strong>示例</strong></p><p>创建<code>test1.sh</code>，内容为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">! /bin/bash</span><br><br>name=yxc  # 定义变量name<br></code></pre></td></tr></table></figure><p>创建<code>test2.sh</code>，内容为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">! /bin/bash</span><br><br>source test1.sh # 或 . test1.sh<br><br>echo My name is: $name  # 可以使用test1.sh中的变量<br></code></pre></td></tr></table></figure><p>执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">acs@9e0ebfcd82d7:~$ chmod +x test2.sh <br>acs@9e0ebfcd82d7:~$ ./test2.sh <br>My name is: yxc<br></code></pre></td></tr></table></figure></blockquote><h2 id="ssh">4.ssh</h2><p>​ <strong>描述：</strong>多敲多敲多敲</p><blockquote><h3id="ssh登录ctrld快速logout"><em>ssh登录</em>：<code>ctrl+d</code>快速logout</h3><h4 id="基本用法">基本用法</h4><p>远程登录服务器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs usd">ssh user@hostname<br></code></pre></td></tr></table></figure><ul><li><code>user</code>：用户名</li><li><code>hostname</code>：IP地址或域名</li></ul><p>第一次登录时会提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">The authenticity of host &#x27;123.57.47.211 (123.57.47.211)&#x27; can&#x27;t be established.<br>ECDSA key fingerprint is SHA256:iy237yysfCe013/l+kpDGfEG9xxHxm0dnxnAbJTPpG8.<br>Are you sure you want to continue connecting (yes/no/[fingerprint])?<br></code></pre></td></tr></table></figure><p>输入<code>yes</code>，然后回车即可</p><p>这样会将该服务器的信息记录在<code>~/ .ssh/kown_hosts</code>文件中。</p><p>然后输入密码即可登录到远程服务中。</p><hr /><p>默认登录端口为22。如果想登录某一个特定端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh user@hostname -p 22<br></code></pre></td></tr></table></figure><hr /><h4 id="配置文件">配置文件</h4><p>创建文件<code>~/ .ssh/config</code></p><p>然后在文件输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">Host myserver1<br>HostName IP地址或域名<br>User 用户名<br><br>Host myserver2<br>HostName IP地址或域名<br>User 用户名<br></code></pre></td></tr></table></figure><p>之后再使用服务器时，可以直接使用别名<code>myserver1</code>、<code>myserver2</code>。</p><hr /><h4 id="密钥登录">密钥登录</h4><p>创建密钥：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen<br></code></pre></td></tr></table></figure><p>然后一直回车即可。</p><p>执行结束后，<code>~/ .ssh/</code>目录下会多两个文件</p><ul><li><code>id_rsa</code>：私钥</li><li><code>id_rsa.pub</code>：公钥</li></ul><hr /><p>之后想免密码登录哪一台服务器，就将公钥传给哪个服务器即可。</p><p>例如，想免密登录<code>myserver</code>服务器。则将公钥中的内容，复制到<code>myserver</code>中的<code>~/.ssh/authorized_keys</code>文件里即可。</p><p>也可以使用如下命令一键添加公钥：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-copy-id myserver<br></code></pre></td></tr></table></figure><hr /><h4 id="执行命令">执行命令</h4><p>命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh user@hostname command<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh user@hostname ls -a<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">单引号中的<span class="hljs-variable">$i</span>可以求值（<span class="hljs-variable">$i</span>可以解析）</span><br>ssh myserver &#x27;for ((i = 0; i &lt; 10; i ++ )) do echo $i; done&#x27;<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">双引号中的<span class="hljs-variable">$i</span>不可以求值（<span class="hljs-variable">$i</span>不被解析）</span><br>ssh myserver &quot;for ((i = 0; i &lt; 10; i ++ )) do echo $i; done&quot;<br></code></pre></td></tr></table></figure><h3 id="scp传文件"><em>scp传文件</em></h3><h4 id="基本用法-1">基本用法</h4><p>命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp source destination<br></code></pre></td></tr></table></figure><p>将<code>source</code>路径下的文件复制到<code>destination</code>中</p><p>一次复制多个文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp source1 source2 destination<br></code></pre></td></tr></table></figure><hr /><p>赋值文件夹：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp -r ~/tmp myserver:/home/acs<br></code></pre></td></tr></table></figure><p>将本地家目录中的<code>tmp</code>文件复制到<code>myserver</code>服务器中的<code>/home/acs</code>目录下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp -r ~/tmp myserver:homework/<br></code></pre></td></tr></table></figure><p>将本地家目录中的<code>tmp</code>文件夹复制到<code>myserver</code>服务器中<code>~/homework/</code>目录下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp -r myserver:homework.<br></code></pre></td></tr></table></figure><p>将<code>myserver</code>服务器中的<code>~/homework/</code>文件夹复制到本地的当前路径下。</p><hr /><p>指定服务器的端口号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp -P 22 source1 source2 destination<br></code></pre></td></tr></table></figure><hr /><p><strong>注意：</strong><code>scp</code>的<code>-r -p</code>等参数尽量加在<code>source</code>和<code>destination</code>之前</p><hr /><h4id="使用scp配置其他服务器的vim和tmux">使用<code>scp</code>配置其他服务器的<code>vim</code>和<code>tmux</code></h4><p><code>Ac Terminal</code>中的<code>.vimrc</code>和<code>.tmux.conf</code>文件是旷视公司leader留下来的是经验的集大成配置文件</p><p>其实就是修改根目录下的<code>.vimrc</code>和<code>.tmux.conf</code>文件即可（具体修改操作查询）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp ~/.vimrc ~/.tmux.conf myserver:<br></code></pre></td></tr></table></figure></blockquote><h2 id="git">5.git</h2><p>​ <strong>描述：</strong>多敲多敲多敲多敲</p><p>一般情况开发的话不会在主分支上开发，会在旁分支上开发</p><blockquote><h4 id="git平台">1.git平台</h4><p>代码托管平台：<a href="git.acwing.com">acgit</a>、<ahref="https://github.com/">github</a>、<ahref="https://gitee.com/">gitee</a></p><h4 id="git基本概念">2.git基本概念</h4><ul><li><strong>工作区</strong>：仓库的目录。工作区是独立于各个分支的</li><li><strong>暂存区</strong>：数据暂时存放的区域，类似于工作区写入版本前的缓存区。缓存区是独立于分支的。</li><li><strong>版本库</strong>：存放所有已经提交到本地仓库的代码版本</li><li><strong>版本结构</strong>：树结构，树中每一个节点代表一个版本</li></ul><h4 id="全局设置">3.全局设置</h4><ol type="1"><li><code>git config --global user.name xxx</code>：设置全局用户名，信息记录在<code>~/.gitconfig</code>文件中</li><li><code>git config --global user.email xxx@xxx.com</code>：设置全局邮箱地址，信息记录在<code>~/.gitconfig</code>文件中</li><li><code>git init</code>：将当前目录配置成git仓库，信息记录在隐藏的.git文件夹中</li></ol><h4 id="常用命令">4.常用命令</h4><ol type="1"><li><code>git add XX</code>：将XX文件添加到暂存区</li><li><code>git commit -m"给自己看的备注信息"</code>：将暂存区的内容提交到当前分支</li><li><code>git status</code>：查看仓库状态</li><li><code>git log</code>：查看当前分支的所有版本</li><li><code>git push -u (第一次需要-u以后不需要)</code>：将当前分支推送到远程仓库</li><li><code>git clone git@git.acwing.com:xxx/XXX.git</code>：将远程仓库XXX下载到当前目录下</li><li><code>git branch</code>：查看所有分支和当前所处分支</li></ol><h4 id="查看命令">5.查看命令</h4><ol type="1"><li><code>git diff XX</code>：查看XX文件相对于暂存区修改了哪些内容<ul><li>当工作区有改动，暂存区为空时，<code>diff</code>对比的是<code>工作区与最后一次commit提交的仓库的共同文件</code></li><li>当工作区有改动，暂存区不为空，<code>diff</code>对比的是<code>工作区与暂存区的共同文件</code></li></ul></li><li><code>git status</code>：查看仓库状态</li><li><code>git log</code>：查看当前分支的所有版本 -&gt;<code>tips：git log太多的时候会进入翻页状态，命令行会消失，通过PgDn能够向下翻页，按q退出翻页状态</code><ul><li><code>git log --pretty=oneline</code>：用一行来显示</li></ul></li><li><code>git reflog</code>：查看HEAD指针的移动历史（包括被回滚的版本）</li><li><code>git branch</code>：查看所有分支和当前所处分支</li><li><code>git pull</code>：将远程仓库的当前分支与本地仓库的当前分支合并</li></ol><h4 id="删除命令">6.删除命令</h4><ol type="1"><li><code>git rm --cached XX</code>：将文件从仓库索引目录中删掉，不希望管理这个文件</li><li><code>git restore --staged xx</code>：将xx从暂存区里移除</li><li><code>it checkout — XX或git restore XX</code>：将XX文件尚未加入暂存区的修改全部撤销</li></ol><h4 id="代码回滚">7.代码回滚</h4><ol type="1"><li><code>git reset --hard HEAD^</code> 或<code>git reset --hard HEAD~</code>：将代码库回滚到上一个版本</li><li><code>git reset --hard HEAD^^</code>：往上回滚两次，以此类推</li><li><code>git reset --hard HEAD~100</code>：往上回滚100个版本</li><li><code>git reset --hard 版本号</code>：回滚到某一特定版本</li></ol><h4 id="远程仓库">8.远程仓库</h4><ol type="1"><li><code>git remote add origin git@git.acwing.com:xxx/XXX.git</code>：将本地仓库关联到远程仓库</li><li><code>git push -u (第一次需要-u以后不需要)</code>：将当前分支推送到远程仓库<ul><li><code>git push origin branch_name</code>：将本地的某个分支推送到远程仓库</li></ul></li><li><code>git clone git@git.acwing.com:xxx/XXX.git</code>：将远程仓库XXX下载到当前目录下</li><li><code>git push --set-upstream origin branch_name</code>：设置本地的<code>branch_name</code>分支对应远程仓库的<code>branch_name</code>分支</li><li><code>git push -d origin branch_name</code>：删除远程仓库的<code>branch_name</code>分支</li><li><code>git checkout -t origin/branch_name</code>：将远程的<code>branch_name</code>分支拉取到本地</li><li><code>git pull</code>：将远程仓库的当前分支与本地仓库的当前分支合并<ul><li><code>git pull origin branch_name</code>：将远程仓库的<code>branch_name</code>分支与本地仓库的当前分支合并</li></ul></li><li><code>git branch --set-upstream-to=origin/branch_name1 branch_name2</code>：将远程的<code>branch_name1</code>分支与本地的<code>branch_name2</code>分支对应</li></ol><h4 id="分支命令">9.分支命令</h4><ol type="1"><li><code>git branch branch_name</code>：创建新分支</li><li><code>git branch</code>：查看所有分支和当前所处分支</li><li><code>git checkout -b branch_name</code>：创建并切换到<code>branch_name</code>这个分支</li><li><code>git checkout branch_name</code>：切换到<code>branch_name</code>这个分支</li><li><code>git merge branch_name</code>：将分支<code>branch_name</code>合并到当前分支上</li><li><code>git branch -d branch_name</code>：删除本地仓库的<code>branch_name</code>分支</li><li><code>git push --set-upstream origin branch_name</code>：设置本地的<code>branch_name</code>分支对应远程仓库的<code>branch_name</code>分支</li><li><code>git push -d origin branch_name</code>：删除远程仓库的<code>branch_name</code>分支</li><li><code>git checkout -t origin/branch_name</code>：将远程的<code>branch_name</code>分支拉取到本地</li><li><code>git pull</code>：将远程仓库的当前分支与本地仓库的当前分支合并<ul><li><code>git pull origin branch_name</code>：将远程仓库的<code>branch_name</code>分支与本地仓库的当前分支合并</li></ul></li><li><code>git branch --set-upstream-to=origin/branch_name1 branch_name2</code>：将远程的<code>branch_name1</code>分支与本地的<code>branch_name2</code>分支对应</li></ol><h4 id="stash暂存">10.stash暂存</h4><ol type="1"><li><code>git stash</code>：将工作区和暂存区中尚未提交的修改存入栈中</li><li><code>git stash apply</code>：将栈顶存储的修改恢复到当前分支，但不删除栈顶元素</li><li><code>git stash drop</code>：删除栈顶存储的修改</li><li><code>git stash pop</code>：将栈顶存储的修改恢复到当前分支，同时删除栈顶元素</li><li><code>git stash list</code>：查看栈中所有元素</li></ol></blockquote><h2 id="thrift引莫凡笔记">6.thrift(引莫凡笔记)</h2><p>​ <strong>描述：</strong>多敲多敲多敲多敲</p><blockquote><p>本文thrift引用他人笔记：<ahref="https://git.acwing.com/fashen/thrift_learning/-/blob/master/readme.md">莫凡thrift学习</a></p></blockquote><h3 id="目录">目录</h3><ul><li><a href="#第六讲-thrift">第六讲 thrift</a><ul><li><a href="#简介">简介</a></li><li><a href="#thrift-idl">Thrift IDL</a></li><li><a href="#如何创建一个thrift服务">如何创建一个Thrift服务?</a></li></ul></li><li><ahref="#接下来写个栗子来熟悉thrift的使用">接下来写个栗子来熟悉thrift的使用</a><ul><li><a href="#一个游戏的匹配服务分析">一个游戏的匹配服务分析</a><ul><li><a href="#分析总结">分析总结:</a></li></ul></li><li><a href="#实现一个游戏的匹配服务">实现一个游戏的匹配服务</a><ul><li><a href="#名字空间namespace">① 名字空间NameSpace</a></li><li><a href="#结构体struct">② 结构体struct</a></li><li><a href="#-服务定义类型service">③ 服务定义类型Service</a></li><li><a href="#-定义服务接口之后先实现match-server">④定义服务接口之后，先实现match-server</a></li><li><a href="#-如何编译thrift生成的c代码">⑤如何编译thrift生成的C++代码?</a></li><li><a href="#-实现match-client">⑥ 实现match-client</a></li><li><a href="#-将match-client的代码改成从标准输入中获取信息">⑦将match-client的代码改成从标准输入中获取信息</a></li><li><a href="#-完善match-server">⑧ 完善match-server</a></li><li><a href="#-实现save_client">⑨ 实现save_client</a></li><li><a href="#-升级match-server">⑩ 升级match-server</a></li><li><a href="#-将thrift的单独server模式改成多线程server模式">⑪将thrift的单独Server模式改成多线程Server模式</a></li><li><a href="#-添加match-server的规则">⑫ 添加match-server的规则</a></li></ul></li></ul></li><li><a href="#知识点">知识点:</a><ul><li><a href="#c-头文件">C 头文件</a></li><li><a href="#using-namespace-std的作用">using namespacestd的作用</a></li><li><a href="#localhost127001-和-本机ip-三者的区别">localhost，127.0.0.1和 本机IP 三者的区别</a></li><li><a href="#端口">端口)</a></li><li><ahref="#include-thread"><code>#include &lt;thread&gt;</code></a></li><li><a href="#互斥锁">互斥锁</a></li><li><a href="#include-condition_variable">#include<condition_variable></a></li><li><a href="#c中类的定义">C++中类的定义</a></li><li><ahref="#vector的size是无符号整数类型">vector的size()是无符号整数类型。</a></li><li><ahref="#vector的erase是左闭右开">vector的erase()是左闭右开。</a></li><li><a href="#求一个字符串的md5值">求一个字符串的md5值。</a></li><li><a href="#英语知识">英语知识</a></li></ul></li></ul><blockquote><p>我们写一个应用时，这个应用程序并不止一个服务，而且不同的服务分配到不同服务器(或者进程)上，也就是我们常说的<ahref="https://baike.baidu.com/item/%E5%BE%AE%E6%9C%8D%E5%8A%A1/18758759?fr=aladdin">微服务</a>。</p></blockquote><h3 id="简介">简介</h3><p><a href="https://thrift.apache.org/">thrift官网</a><strong>官网教程:进入官网-&gt;Tutorial-&gt;tutorial.thrift</strong></p><p><strong>ApacheThrift</strong>软件框架用于可伸缩的跨语言服务开发，它将<strong>软件栈</strong>和<strong>代码生成引擎</strong>结合在一起，以构建在C++、Java、Python、PHP、Ruby、Erlang、Perl、Haskell、C#、Cocoa、JavaScript、Node.js、Smalltalk、OCaml和Delphi等语言之间高效、无缝地工作的服务。</p><p><strong>Thrift使用C++进行编写</strong>，在安装使用的时候需要安装依赖，windows安装方式见官网即可。安装方式：<ahref="http://thrift.apache.org/docs/install/">thrift官网介绍安装方式</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs d">thrift -<span class="hljs-keyword">version</span> <span class="hljs-comment">//查看thrift版本</span><br></code></pre></td></tr></table></figure><hr /><h3 id="thrift-idl">Thrift IDL</h3><p>Thrift 采用IDL（Interface DefinitionLanguage）来定义通用的服务接口，然后通过Thrift提供的编译器，可以将服务接口编译成不同语言编写的代码，通过这个方式来实现跨语言的功能。</p><ul><li>通过命令调用Thrift提供的编译器将服务接口编译成不同语言编写的代码。</li><li>这些代码又分为服务端和客户端，将所在不同进程(或服务器)的功能连接起来。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">thrift -r --gen <span class="hljs-tag">&lt;<span class="hljs-name">language</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">Thrift</span> <span class="hljs-attr">filename</span>&gt;</span><br></code></pre></td></tr></table></figure><hr /><h3 id="如何创建一个thrift服务">如何创建一个Thrift服务?</h3><ol type="1"><li>定义服务接口(存放接口的文件夹就是thrift文件)</li><li>作为服务端的服务，需要生成server。</li><li>作为请求端的服务，需要生成client。</li></ol><hr /><h3id="接下来写个栗子来熟悉thrift的使用">接下来写个栗子来熟悉thrift的使用</h3><h4 id="一个游戏的匹配服务分析">一个游戏的匹配服务分析</h4><p><strong>一般情况如图所示</strong></p><figure><imgsrc="https://cdn.acwing.com/media/article/image/2021/10/05/97206_32d5aa8525-无标题.png"alt="无标题.png" /><figcaption aria-hidden="true">无标题.png</figcaption></figure><p><strong>分析图示内容</strong>这个游戏的功能可能运行在一个或多个服务器(或进程)上，而thrift就是将不同服务器不同语言的功能连接起来。图中的三个节点(功能)是完全独立的，既可以在同一个服务器上，也可以在不同服务器上。每一个节点就是一个进程，每个进程可以使用不同的语言来实现。</p><ul><li>在GAME节点上实现客户端通过调用匹配系统的服务端中实现的两个服务接口函数获取功能，实现跨语言跨服务的工作。</li><li>每个节点(功能)之间通过thrift定义的服务接口作为有向边进行连接。弧尾所在的节点创建客户端，弧头所在的节点创建服务端。</li><li>匹配系统节点实现服务端，其中有一个匹配池：不断的接收玩家和删除玩家，同时根据一定的规则给每个玩家安排一局游戏。</li><li>匹配系统节点实现客户端，通过调用数据存储节点的服务端中实现的一个服务接口函数获取功能，实现跨语言跨服务的工作。</li><li>每个功能(节点)之间通过thrift定义的服务接口作为有向边进行连接。弧尾所在的节点创建客户端，弧头所在的节点创建服务端。</li><li>数据存储节点实现服务端。别人已经将服务接口和服务端实现好了。</li><li>服务接口功能介绍: add_user：向匹配池中添加玩家。remove_user：从匹配池中删除玩家。 save_data：将匹配信息存储起来。</li></ul><p><strong>补充</strong></p><ul><li>有向边也称弧,边的始点称为弧尾,终点称为弧头。</li><li>当做项目时，可能有人已经将服务接口实现好了，即将服务端实现了，我们只需要创建客户端即可。</li></ul><h4 id="分析总结">分析总结:</h4><p>在实现服务之前，最好先画个图分析，这样目标明确、思路清晰。</p><p><strong>图中的要素</strong></p><ol type="1"><li>不同服务作为节点</li><li>每个服务是在哪个服务器上实现的</li><li>每个服务通过什么语言实现</li><li>服务之间通过怎样的服务接口进行连接。</li><li>通过业务逻辑确认每个服务需要创建哪些服务端和客户端。</li></ol><hr /><h3 id="实现一个游戏的匹配服务">实现一个游戏的匹配服务</h3><p>这里为了方便我们需要创建两个文件夹表示game节点(game)和匹配服务节点(match_system)，其实也可以放在不同的服务器上，不过条件不允许啊😉，而数据存储节点的服务端已经实现好了，只要调用服务接口实现的函数即可。</p><p>接下来创建一个thrift文件夹存储.thrift文件，.thrift文件定义服务接口。其中有两个.thrift文件分别表示两条有向边，一条有向边可以包含多个服务接口。</p><p>先定义服务接口。 定义添加玩家和删除玩家的两个接口。在thrift文件夹中，创建match.thrift文件。然后进行接下来的内容。</p><hr /><h4 id="名字空间namespace">①名字空间NameSpace</h4><p>Thrift中的命名空间类似于C++中的namespace和java中的package，它们提供了一种组织（隔离）代码的简便方式。名字空间也可以用于解决类型定义中的名字冲突。</p><p>由于每种语言均有自己的命名空间定义方式（如:python中有module）,thrift允许开发者针对特定语言定义namespace。</p><p>简单的demo：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">namespace</span> java com.xtxxtx.test<br></code></pre></td></tr></table></figure><p>转换成</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">package</span> <span class="hljs-title">com.xtxxtx.test</span><br></code></pre></td></tr></table></figure><p><strong>教程中的介绍:</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Thrift files can namespace, package, or prefix their output in various</span><br><span class="hljs-comment"> * target languages.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">namespace</span> <span class="hljs-symbol">cl</span> <span class="hljs-symbol">tutorial</span><br><span class="hljs-symbol">namespace</span> <span class="hljs-symbol">cpp</span> <span class="hljs-symbol">tutorial</span>  <br><span class="hljs-symbol">namespace</span> <span class="hljs-symbol">d</span> <span class="hljs-symbol">tutorial</span><br><span class="hljs-symbol">namespace</span> <span class="hljs-symbol">dart</span> <span class="hljs-symbol">tutorial</span><br><span class="hljs-symbol">namespace</span> <span class="hljs-symbol">java</span> <span class="hljs-symbol">tutorial</span><br><span class="hljs-symbol">namespace</span> <span class="hljs-symbol">php</span> <span class="hljs-symbol">tutorial</span><br><span class="hljs-symbol">namespace</span> <span class="hljs-symbol">perl</span> <span class="hljs-symbol">tutorial</span><br><span class="hljs-symbol">namespace</span> <span class="hljs-symbol">haxe</span> <span class="hljs-symbol">tutorial</span><br><span class="hljs-symbol">namespace</span> <span class="hljs-symbol">netstd</span> <span class="hljs-symbol">tutorial</span><br><br>//匹配系统我们用<span class="hljs-symbol">C</span>++实现。<br>//语法:<span class="hljs-symbol">namespace</span> 使用的语言 空间名称<br><span class="hljs-symbol">namespace</span> <span class="hljs-symbol">cpp</span> <span class="hljs-symbol">match_dao</span><br></code></pre></td></tr></table></figure><hr /><h4 id="结构体struct">②结构体struct</h4><p>数据类型在结构体中定义。 struct有以下一些约束：</p><ol type="1"><li>struct不能继承，但是可以嵌套，不能嵌套自己。(0.12.0版本可以支持嵌套自己本身)</li><li>其成员都是有明确类型</li><li>成员是被正整数编号过的，其中的编号使不能重复的，这个是为了在传输过程中编码使用。</li><li>成员分割符可以是逗号（,）或是分号（;），而且可以混用</li><li>字段会有optional和required之分和protobuf一样，但是如果不指定则为无类型–可以不填充该值，但是在序列化传输的时候也会序列化进去，optional是不填充则部序列化，required是必须填充也必须序列化。</li><li>每个字段可以设置默认值</li><li>同一文件可以定义多个struct，也可以定义在不同的文件，进行include引入。</li></ol><p><strong>教程中介绍:</strong></p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs thrift"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Structs are the basic complex data structures. They are comprised of fields</span><br><span class="hljs-comment"> * which each have an integer identifier, a type, a symbolic name, and an</span><br><span class="hljs-comment"> * optional default value.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Fields can be declared &quot;optional&quot;, which ensures they will not be included</span><br><span class="hljs-comment"> * in the serialized output if they aren&#x27;t set.  Note that this requires some</span><br><span class="hljs-comment"> * manual management in some languages.</span><br><span class="hljs-comment"> */</span><br> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Work</span> </span>&#123;<br>  <span class="hljs-number">1</span>: <span class="hljs-type">i32</span> num1 = <span class="hljs-number">0</span>, <span class="hljs-comment">//默认值</span><br>  <span class="hljs-number">2</span>: <span class="hljs-type">i32</span> num2, <span class="hljs-comment">//默认字段类型是optional</span><br>  <span class="hljs-number">3</span>: Operation op,<br>  <span class="hljs-number">4</span>: <span class="hljs-keyword">optional</span> <span class="hljs-type">string</span> comment,<br>  <span class="hljs-number">5</span>: <span class="hljs-keyword">required</span> <span class="hljs-type">string</span> name, <span class="hljs-comment">//本字段必须填充</span><br>&#125;<br><br><span class="hljs-comment">//这里我们定义结构体用来存储用户信息。其中i32表示int，string表示字符串。</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-number">1</span>: <span class="hljs-type">i32</span> id,<br>    <span class="hljs-number">2</span>: <span class="hljs-type">string</span> name,<br>    <span class="hljs-number">3</span>: <span class="hljs-type">i32</span> score,<br>&#125;<br></code></pre></td></tr></table></figure><p>规则：</p><ul><li>如果required标识的域没有赋值，Thrift将给予提示；</li><li>如果optional标识的域没有赋值，该域将不会被序列化传输；</li><li>如果某个optional标识域有缺省值而用户没有重新赋值，则该域的值一直为缺省值；</li><li>如果某个optional标识域有缺省值或者用户已经重新赋值，而不设置它的__isset为true，也不会被序列化传输。</li></ul><hr /><h4 id="服务定义类型service">③ 服务定义类型Service</h4><p>服务的定义方法在语义上等同于面向对象语言中的接口。比如java中的接口，只是参数需要加上编号。</p><p><strong>教程中介绍:</strong></p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs thrift"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Ahh, now onto the cool part, defining a service. Services just need a name</span><br><span class="hljs-comment"> * and can optionally inherit from another service using the extends keyword.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">service</span> <span class="hljs-title">Calculator</span> extends shared.SharedService </span>&#123;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * A method definition looks like C code. It has a return type, arguments,</span><br><span class="hljs-comment">   * and optionally a list of exceptions that it may throw. Note that argument</span><br><span class="hljs-comment">   * lists and exception lists are specified using the exact same syntax as</span><br><span class="hljs-comment">   * field lists in struct or exception definitions.</span><br><span class="hljs-comment">   */</span><br><br>   <span class="hljs-keyword">void</span> ping(),<br><br>   <span class="hljs-type">i32</span> add(<span class="hljs-number">1</span>:<span class="hljs-type">i32</span> num1, <span class="hljs-number">2</span>:<span class="hljs-type">i32</span> num2),<br><br>   <span class="hljs-type">i32</span> calculate(<span class="hljs-number">1</span>:<span class="hljs-type">i32</span> logid, <span class="hljs-number">2</span>:Work w) throws (<span class="hljs-number">1</span>:InvalidOperation ouch),<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * This method has a oneway modifier. That means the client only makes</span><br><span class="hljs-comment">    * a request and does not listen for any response at all. Oneway methods</span><br><span class="hljs-comment">    * must be void.</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">oneway</span> <span class="hljs-keyword">void</span> zip()<br><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 我们需要定义两个接口方法:add_user(), remove_user()</span><br><span class="hljs-comment">  * 其中`2: string info`表示额外信息。</span><br><span class="hljs-comment">  * 作用:以后想要更改接口时，不用更改接口，你可以直接将想传的信息传入到info中，</span><br><span class="hljs-comment">  * 然后对info进行序列化一个jinsen即可。</span><br><span class="hljs-comment">  */</span><br><span class="hljs-class"><span class="hljs-keyword">service</span> <span class="hljs-title">Match</span> </span>&#123;<br>    <span class="hljs-type">i32</span> add_user(<span class="hljs-number">1</span>: User user, <span class="hljs-number">2</span>: <span class="hljs-type">string</span> info),<br><br>    <span class="hljs-type">i32</span> remove_user(<span class="hljs-number">1</span>: User user, <span class="hljs-number">2</span>: <span class="hljs-type">string</span> info),<br>&#125;<br></code></pre></td></tr></table></figure><hr /><h4 id="定义服务接口之后先实现match-server">④定义服务接口之后，先实现match-server</h4><p><strong>如何通过接口生成C++版本的服务端?</strong></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-comment">//通过这个命令就可以实现，不过在此之前需要做一些准备工作。</span><br><span class="hljs-comment">//tutorial.thrift表示从当前目录到定义接口的路径。</span><br>thrift -r --<span class="hljs-keyword">gen</span> cpp <span class="hljs-keyword">tutorial</span>.thrift<br></code></pre></td></tr></table></figure><p>具体操作如图所示: <imgsrc="https://cdn.acwing.com/media/article/image/2021/10/03/97206_24b6e98123-2021-10-02_213443.png"alt="2021-10-02_213443.png" /></p><ul><li>做到这里我们发现:有了接口之后，通过命令就可以生成C++版本的服务端相关的代码。但是具体业务我们还是需要具体写哦!</li><li><spanclass="math inline">\(\color{red}{好习惯:写thrift服务的时候，先编译成功，然后再逐步向文件中添加模块。}\)</span></li></ul><hr /><h4 id="如何编译thrift生成的c代码">⑤ 如何编译thrift生成的C++代码?</h4><p>因为<spanclass="math inline">\(Thrift\)</span>由<code>C++</code>编写，所以编译的过程与<code>C++</code>一样。本质就是编译一堆<code>C++</code>源文件(.cpp)。 <spanclass="math inline">\(\color{green}{C++编译过程:}\)</span> <spanclass="math inline">\(\color{red}{①编译}\)</span> <imgsrc="https://cdn.acwing.com/media/article/image/2021/10/03/97206_13c8927a23-2021-10-03_092958.png"alt="2021-10-03_092958.png" /> <spanclass="math inline">\(\color{red}{②链接}\)</span> <imgsrc="https://cdn.acwing.com/media/article/image/2021/10/03/97206_26c2852823-2021-10-03_095345.png"alt="2021-10-03_095345.png" /> <imgsrc="https://cdn.acwing.com/media/article/image/2021/10/03/97206_5ee3260f23-2021-10-03_100004.png"alt="2021-10-03_100004.png" /> <imgsrc="https://cdn.acwing.com/media/article/image/2021/10/03/97206_d47a471223-2021-10-03_103957.png"alt="2021-10-03_103957.png" /></p><ul><li>好习惯:可执行文件和编译好的文件最好不要加进去，只加.cpp和.h文件。</li></ul><p>C++编译很慢，链接很快。所以每次修改项目，重新编译时，只需要编译修改过的.cpp文件即可，防止编译时间过长。即修改哪个文件就编译哪个文件。基于这一点考虑就有了make和cmake工具。但没啥用。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coq">//前面加上<span class="hljs-built_in">time</span>查看编译和链接的时间。<br><span class="hljs-built_in">time</span> g++ -c .cpp文件<br><span class="hljs-built_in">time</span> g++ -o .o文件 -lthrift -pthread<br></code></pre></td></tr></table></figure><hr /><h4 id="实现match-client">⑥ 实现match-client</h4><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-comment">//使用该命令创建python版本的服务端，然后通过修改得到客户端。</span><br><span class="hljs-comment">//这个命令python2和python3是兼容的。</span><br>thrift -r --<span class="hljs-keyword">gen</span> py <span class="hljs-keyword">tutorial</span>.thrift<br></code></pre></td></tr></table></figure><p><imgsrc="https://cdn.acwing.com/media/article/image/2021/10/03/97206_48b9a10724-2021-10-03_152548.png"alt="2021-10-03_152548.png" /> <imgsrc="https://cdn.acwing.com/media/article/image/2021/10/04/97206_0dfd243725-2021-10-03_131330.png"alt="2021-10-03_131330.png" /> <imgsrc="https://cdn.acwing.com/media/article/image/2021/10/03/97206_90e9ef8424-2021-10-03_154417.png"alt="2021-10-03_154417.png" /> <imgsrc="https://cdn.acwing.com/media/article/image/2021/10/03/97206_e47583d524-2021-10-03_155550.png"alt="2021-10-03_155550.png" /></p><ul><li><spanclass="math inline">\(\color{red}{好习惯:每完成一个客户(服务)端时，推荐使用git进行持久化。}\)</span></li></ul><hr /><blockquote><p>现在client端还不是很方便。因为每次都需要运行一下代码，而且代码是写死的。</p></blockquote><h4 id="将match-client的代码改成从标准输入中获取信息">⑦将match-client的代码改成从标准输入中获取信息</h4><p><imgsrc="https://cdn.acwing.com/media/article/image/2021/10/03/97206_c14535c824-2021-10-03_161948.png"alt="2021-10-03_161948.png" />至此，game的client端就完成了。最后将其持久化作为最终版。</p><ul><li><spanclass="math inline">\(\color{red}{好习惯:在编译和运行时，产生的文件都不要持久化，这没有意义，只会占用网络带宽，会显得你的仓库不专业。}\)</span></li></ul><hr /><blockquote><p>写server端需要分析业务模型。需要进行监控，支持增加用户和删除用户。同时还要有一个线程去不停地进行匹配。这个时候，我们发现需要实现两个功能，添加删除用户和匹配用户，根据微服务的概念需要开两个进程实现两个功能。</p></blockquote><h4 id="完善match-server">⑧ 完善match-server</h4><p>完善server端需要并利用<code>C++</code>实现多线程。视频定位：55:30</p><p>项目代码中有注解。</p><p>编译C++时，如果你用到了线程，需要加上线程的动态链接库的参数<code>-pthread</code>。<code>-lthrift</code>参数将所有thrift动态连接文件连接起来。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">g++ *<span class="hljs-selector-class">.o</span> -o <span class="hljs-selector-tag">main</span> -lthrift -pthread<br></code></pre></td></tr></table></figure><hr /><h4 id="实现save_client">⑨ 实现save_client</h4><p>因为一个节点(功能)只能由一个main方法作为程序的入口，所以匹配系统中的客户端和服务端写在同一个main方法中。我们这里根据逻辑将其实现在一个函数中。</p><ul><li>注意:复制教程中的代码时，一些细节需要更改。例如:其中带Calculator的字段都需要更改。</li><li>一些thrift接口和服务端有人会帮我们实现，这时我们只需调用接口实现的函数即可。例如:这里使用已经实现好的save_data()接口。</li></ul><hr /><blockquote><p>我们现在的匹配系统是傻瓜式匹配，从队头逮到两个人就匹配成功，所以需要制定一些规则进行升级。这里我们指定分差50以内的进行匹配。</p></blockquote><h4 id="升级match-server">⑩ 升级match-server</h4><hr /><blockquote><p>一个线程处理输入输出，如果以后要处理并发量时，需要开多个线程处理。</p></blockquote><h4 id="将thrift的单独server模式改成多线程server模式">⑪将thrift的单独Server模式改成多线程Server模式</h4><figure><imgsrc="https://cdn.acwing.com/media/article/image/2021/10/05/97206_d6beb85525-2021-10-05_092449.png"alt="2021-10-05_092449.png" /><figcaption aria-hidden="true">2021-10-05_092449.png</figcaption></figure><hr /><h4 id="添加match-server的规则">⑫ 添加match-server的规则</h4><p>匹配机制：等待时间越长，阈值越大。即匹配的范围随时间的推移而变大故需要记录当前玩家在匹配池中等待的秒数。</p><p>至此，游戏的匹配服务就全部完成了。</p><hr /><hr /><hr /><h3 id="知识点">知识点</h3><h4 id="c-头文件"><ahref="https://www.runoob.com/cprogramming/c-header-files.html">C头文件</a></h4><p>C 语言中 include &lt;&gt; 与include "" 的区别?<code>#include &lt; &gt;</code>:引用的是编译器的类库路径里面的头文件。<code>#include " "</code>:引用的是你程序目录的相对路径中的头文件，如果在程序目录没有找到引用的头文件则到编译器的类库路径的目录下找该头文件。</p><h4 id="using-namespace-std的作用"><ahref="https://baike.baidu.com/item/using%20namespace%20std/10360651?fr=aladdin">usingnamespace std的作用</a></h4><p>C++标准程序库中的所有标识符都被定义于一个名为std的namespace中。由于namespace的概念，使用C++标准程序库的任何标识符时，可以有三种选择，具体看百度百科。但是如果加上这段代码，就不用前缀。 比如:<code>std::cout &lt;&lt; std::endl;</code>加上using namespacestd后，就可以写成这样<code>cout &lt;&lt; endl</code>。<code>std::ios::sync_with_stdio(false);</code>加上using namespacestd后，就可以写成这样<code>ios::sync_with_stdio(false);</code>。(想了解<ahref="https://blog.csdn.net/weixin_51333606/article/details/116738816">ios::sync_with_stdio(false);</a>用法开这篇文章)</p><h4 id="localhost127.0.0.1-和-本机ip-三者的区别">localhost，127.0.0.1 和本机IP 三者的区别</h4><h5 id="端口"><ahref="https://baike.baidu.com/item/%E7%AB%AF%E5%8F%A3/103505?fr=aladdin">端口</a>)</h5><p>如果把IP地址比作一间房子，端口就是出入这间房子的门。真正的房子只有几个门，但是一个IP地址的端口可以有65536（即：2^16）个之多！端口是通过端口号来标记的，端口号只有整数，范围是从0到65535（2^16-1）。同一个端口只能由一个进程来监听。所以我们一旦启动了一个服务，那么这个服务就不能在被另一个进程启动了。服务器的端口号要与客户端的端口号相同。</p><hr /><blockquote><p>每执行一个程序就是开了一个进程。每一个进程可以开一堆线程。开多线程的开销是很小的，开多进程的开销是很大的。</p></blockquote><h4 id="include-thread"><code>#include &lt;thread&gt;</code></h4><p>C++中有一个thread的库，可以用来开线程。通过定义一个变量将函数名作为参数，就能开一个线程了。首先定义线程的操作。 并行中经典的生产者和消费者模型。生产者、消费者是两个线程。 生产者:add_user()、remove_user()消费者:匹配用户的功能。 生产者和消费者之间需要一个媒介。这个媒介可以有很多种方法。比如:消费队列。很多语言都有自己实现的消费队列，也可以自己实现消费队列。实现消费队列，就需要用到一些锁(mutex)。 并行编程的基本概念:锁。</p><hr /><h4 id="互斥锁">互斥锁</h4><p>在编程中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。每个对象都对应于一个可称为"互斥锁"的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。</p><p>锁🔒有两个操作。一个P操作(上锁)，一个V操作(解锁)。 定义互斥锁:mutexm;锁一般使用信号量来实现的，mutex其实就是一个信号量(它特殊也叫互斥量)。互斥量就是同一时间能够分给一个人，即S=1。信号量S:S=10表示可以将信号量分给10个人来用。</p><p>P操作的主要动作是: ①S减1；②若S减1后仍大于或等于0，则进程继续执行；<br />③若S减1后小于0，则该进程被阻塞后放入等待该信号量的等待队列中，然后转进程调度。<br />V操作的主要动作是： ①S加1； ②若相加后结果大于0，则进程继续执行；③若相加后结果小于或等于0，则从该信号的等待队列中释放一个等待进程，然后再返回原进程继续执行或转进程调度。</p><p>对于P和V都是原子操作，就是在执行P和V操作时，不会被插队。从而实现对共享变量操作的原子性。特殊:S=1表示互斥量，表示同一时间，信号量只能分配给一个线程。</p><p>多线程为啥要用锁?因为多线程可能共享一个内存空间，导致出现重复读取并修改的现象。</p><hr /><h4 id="include">#include <condition_variable></h4><hr /><h4 id="c中类的定义">C++中类的定义</h4><hr /><h4id="vector的size是无符号整数类型">vector的size()是无符号整数类型。</h4><hr /><h4 id="vector的erase是左闭右开">vector的erase()是左闭右开。</h4><hr /><h4 id="求一个字符串的md5值">求一个字符串的md5值。</h4><p>输入命令"md5sum"，输入字符串回车然后<code>Ctrl + d</code>就行了。md5加密</p><hr /><blockquote><p>随着学习的深入，用到英语的地方越来越多，很多技术都是外国实现，中国的计算机技术还需要我辈去完善创新。先从英语开始吧。每篇一记。</p></blockquote><h4 id="英语知识">英语知识</h4><ul><li>IDL:接口定义语言（Interface Definition Language）</li><li>RPC:远程过程调用（Remote Procedure Call）</li><li>client:客户，客户端</li></ul><p><font face="楷书" color=red>最后说一句，会了英语学编程真香，不说了，我去学英语了。</font></p><h2 id="管道环境变量与常用命令">7.管道、环境变量与常用命令</h2><p>​ <strong>描述：</strong>多敲多敲多敲多敲</p><blockquote><h3 id="管道">管道</h3><p><strong>概念：</strong></p><p>管道类似于文件重定向，可以将前一个命令的<code>stdout</code>重定向到下一个命令的<code>stdin</code>。</p><hr /><p><strong>要点：</strong></p><ol type="1"><li>管道命令仅处理<code>stdout</code>，会忽略<code>stderr</code>。</li><li>管道右边的命令必须能接受<code>stdin</code>。</li><li>多个管道命令可以串联。</li></ol><hr /><p><strong>与文件重定向的区别：</strong></p><ul><li>文件重定向左边为命令，右边为文件。</li><li>管道左右两边均为命令，左边有<code>stdout</code>，右边有<code>stdin</code>。</li></ul><hr /><p><strong>举例：</strong></p><p>统计当前目录下所有<code>python</code>文件的总行数，其中<code>find</code>、<code>xargs</code>、<code>wc</code>等命令可以参考常用命令这一节内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find . -name &#x27;*.py&#x27; | xargs cat | wc -l<br></code></pre></td></tr></table></figure><h3 id="环境变量">环境变量</h3><p><strong>概念：</strong>Linux系统中会有很多环境变量来记录<strong>配置信息</strong></p><p>环境变量类似于全局变量，可以被各个进程访问到。我们可以通过修改环境变量来方便地修改系统变量。</p><hr /><p><strong>查看：</strong></p><p>列出当前环境下的所有环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">env # 显示当前用户的变量<br>set #显示当前shell的变量，包括当前用户的变量<br>export # 显示当前导出成用户变量的shell变量<br></code></pre></td></tr></table></figure><p>输出某个环境变量的值：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo $PATH<br></code></pre></td></tr></table></figure><hr /><p><strong>修改：</strong></p><p>环境变量的定义、修改、删除操作可以参考<ahref="#3.shell语法">3.shell语法——变量</a>这一节的内容。</p><p>为了将对环境变量的修改应用到未来所有环境下，可以将修改应用到当前的<code>~/.bashrc</code>文件中。</p><p>修改完<code>~/.bashrc</code>文件后，记得执行<code>source ~/.bashrc</code>,来将修改应用到当前的<code>bash</code>环境下。</p><p>为何将修改命令放到<code>~/.bashrc</code>文件后，就可以确保修改会影响未来所有的环境呢？</p><ul><li>每次启动<code>bash</code>，都会先执行<code>~/.bashrc</code>。</li><li>每次<code>ssh</code>登录远程服务器，都会启动一个<code>bash</code>命令行给我们。</li><li>每次<code>tmux</code>新开一个<code>pane</code>,都会启动一个<code>bash</code>命令行给我们。</li><li>所有未来所有新开的环境都会加载我们修改的内容。</li></ul><hr /><p><strong>常见环境变量：</strong></p><ol type="1"><li><code>HOME</code>:用户的家目录。</li><li><code>PATH</code>:可执行文件（命令）的存储路径之间用<code>:</code>分隔。当某个可执行文件同时出现在多个路径中时，会选择从左到右数第一个路径中的执行。<strong>下列所有存储路径的环境变量，均采用从左到右的优先顺序。</strong></li><li><code>LD_LIBRARY_PATH</code>:用于指定动态链接库(.so文件)的路径，其内容是以冒号分割的路径列表。</li><li><code>C_INCLUDE_PATH</code>:C语言的头文件路径，内容是以冒号分隔的路径列表</li><li><code>CPLUS_INCLUDE_PATH</code>:CPP的头文件路径，内容是以冒号分隔的路径列表。</li><li><code>PYTHONPATH</code>:Python导入包的路径，内容是以冒号分隔的路径列表。</li><li><code>JAVA_HOME</code>:jdk的安装目录。</li><li><code>CLASS_PATH</code>:存放Java导入类的路径，内容是以冒号分隔的路径列表。</li></ol><h3 id="常用命令-1">常用命令</h3><p>Linux命令非常多，本节讲解几个常用的命令。其他命令依赖于大家根据实际操作系统，边用边查。</p><hr /><p><strong>系统状况：</strong></p><ol type="1"><li><code>top</code>:查看所有进程的信息（Linux的任务管理器）<ul><li>打开后，输入<code>M</code>:按使用内存排序</li><li>打开后，输入<code>P</code>:按使用CPU排序</li><li>打开后，输入<code>q</code>:退出</li></ul></li><li><code>df -h</code>:查看硬盘使用情况</li><li><code>free -h</code>:查看内存使用情况</li><li><code>du -sh</code>:查看当前目录占用的硬盘空间</li><li><code>ps aux</code>:查看所有进程</li><li><code>kill -9 pid</code>:杀死编号为<code>pid</code>的进程<ul><li>传递某个具体的信号：<code>kill -s SIGTERM pid</code></li></ul></li><li><code>netstat -nt</code>:查看所有的网络连接</li><li><code>w</code>:列出当前登陆的用户</li><li><code>ping www.baidu.com</code>:查看是否联网</li></ol><hr /><p><strong>文件权限：</strong></p><ol type="1"><li><code>chmod</code>:修改文件权限<ul><li><code>chmod +x xxx</code>:给<code>xxx</code>添加可执行权限</li><li><code>chmod -x xxx</code>:去掉<code>xxx</code>的可执行权限</li><li><code>chmod 777 xxx</code>:将<code>xxx</code>的权限改为777</li><li><code>chmod 777 xxx -R</code>:递归修改整个文件夹的权限</li></ul></li></ol><hr /><p><strong>文件检索：</strong></p><ol type="1"><li><code>find /path/to/directory/ -name '*.py'</code>:搜索某个文件路径下的所有`*.py'文件</li><li><code>grep xxx</code>:从<code>stdin</code>中读入若干行数据，如果某行中包含<code>xxx</code>，则输出该行；否则忽略改行。</li><li><code>wc</code>:统计行数、单词数、字节数<ul><li>即可以从<code>stdin</code>中直接读入内容；也可以在命令行参数中传入文件名列表；</li><li><code>wc -l</code>:统计行数</li><li><code>wc -w</code>:统计单词数</li><li><code>wc -c</code>:统计字节数</li></ul></li><li><code>tree</code>:展示当前目录的文件结构<ul><li><code>tree /path/to/directory/</code>:展示某个目录的文件结构</li><li><code>tree -a</code>:展示隐藏文件</li></ul></li><li><code>ag xxx</code>:搜索当前目录下的所有文件，检索<code>xxx</code>字符串</li><li><code>cut</code>:分割一行内容<ul><li>从<code>stdin</code>中读入多行数据</li><li><code>echo $PATH | cut -d ':' -f 3,5</code>:输出<code>PATH</code>用<code>:</code>分割后第3、5行数据</li><li><code>echo $PATH | cut -d ':' -f 3-5</code>:输出<code>PATH</code>用<code>:</code>分割后第3-5行数据</li><li><code>echo $PATH | cut -c 3,5</code>:输出<code>PATH</code>的第3、5个字符</li><li><code>echo $PATH | cut -c 3-5</code>:输出<code>PATH</code>的第3-5个字符</li></ul></li><li><code>sort</code>：将每行内容按字典序排序<ul><li>可以从<code>stdin</code>中读取多行数据</li><li>可以从命令行参数中读取文件名列表</li></ul></li><li><code>xargs</code>：将<code>stdin</code>中的数据用空格或回车分割成命令行参数<ul><li><code>find . -name '*.py' | xargs cat | wc -1</code>:统计当前目录下所有python文件的总行数</li></ul></li></ol><hr /><p><strong>查看文件内容：</strong></p><ol type="1"><li><code>more</code>:浏览文件内容<ul><li>回车：下一行</li><li>空格：下一页</li><li><code>b</code>:上一页</li><li><code>q</code>:退出</li></ul></li><li><code>less</code>：与<code>more</code>类似，功能更全<ul><li>回车：下一行</li><li><code>y</code>:上一行</li><li><code>Page Down</code>:上一页</li><li><code>q</code>:退出</li></ul></li><li><code>head -3 xxx</code>:展示<code>xxx</code>的前3行内容<ul><li>同时支持从<code>stdin</code>读入内容</li></ul></li><li><code>tail -3 xxx</code>:展示<code>xxx</code>末尾3行内容<ul><li>同时支持从<code>stdin</code>读入内容</li></ul></li></ol><hr /><p><strong>用户相关：</strong></p><ol type="1"><li><code>md5sum</code>:计算<code>md5</code>哈希值<ul><li>可以从<code>stdin</code>读入内容</li><li>也可以在命令行参数中传入文件名列表</li></ul></li><li><code>time command</code>:统计<code>command</code>命令的执行时间</li><li><code>ipython</code>:交互式python3环境。可以当作计算器，或者批量管理文件<ul><li><code>! echo "Hello World"</code>:<code>!</code>表示<code>shell</code>脚本</li></ul></li><li><code>watch -n 0.1 command</code>:每0.1秒执行一次<code>command</code>命令</li><li><code>tar</code>：压缩文件<ul><li><code>tar -zcvf xxx.tar.gz /path/to/file/*</code>:压缩</li><li><code>tar -zxvf xxx.tar.gz</code>:解压缩</li></ul></li><li><code>diff xxx yyy</code>:查找文件<code>xxx</code>和<code>yyy</code>的不同点</li></ol><hr /><p><strong>安装软件：</strong></p><ol type="1"><li><code>sudo command</code>:以<code>root</code>身份执行<code>command</code>命令</li><li><code>apt-get install xxx</code>:安装软件</li><li><code>pip install xxx --user --upgrade</code>:安装python包</li></ol></blockquote><h2 id="租云服务器及配置环境">8.租云服务器及配置环境</h2><p>​ <strong>描述：</strong>多练多练多练多练</p><blockquote><p><strong>云平台的作用:</strong></p><ol type="1"><li><p>存放我们的docker容器，让计算跑在云端。</p></li><li><p>获得公网IP地址，让每个人可以访问到我们的服务。</p></li></ol><hr /><p><strong>任选一个云平台即可，推荐配置：</strong></p><ol type="1"><li>1核 2GB（后期可以动态扩容，前期配置低一些没关系）</li><li>网络带宽采用按量付费，最大带宽拉满即可（费用取决于用量，与最大带宽无关）</li><li>系统版本：ubuntu 20.04LTS（推荐用统一版本，避免后期出现配置不兼容的问题）</li></ol></blockquote><blockquote><p>阿里云地址：<ahref="https://www.aliyun.com/">https://www.aliyun.com/</a></p><p><strong>创建工作用户<code>andii</code>并赋予<code>sudo</code>权限</strong></p><p>登陆到新服务器，打开AC Terminal，然后：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh root@xxx.xxx.xxx.xxx # xxx.xxx.xxx.xxx替换成新服务器的公网IP<br></code></pre></td></tr></table></figure><p>创建<code>andii</code>用户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">adduser andii # 创建用户<br>usermod -aG sudo andii # 给用户andii分配sudo权限<br></code></pre></td></tr></table></figure><p>删除<code>andii</code>用户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">userdel andii # 删除用户<br></code></pre></td></tr></table></figure><hr /><p><strong>配置免密登录方式</strong></p><p>退回ACTerminal，然后配置<code>andii</code>用户的别名和免密登录，可参考<ahref="#4.ssh">4.ssh</a>。</p><hr /><p><strong>配置新服务器上的工作环境</strong></p><p>将AC Terminal的配置传到新的服务器上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ssh">scp .bashrc .vimrc .tmux.conf server_name: # server_name需要换成自己配置的别名<br></code></pre></td></tr></table></figure><hr /><p><strong>安装<code>tmux</code>和<code>docker</code></strong></p><p>登录到自己的服务器，然后安装<code>tmux</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get update<br>sudo apt-get install tmux<br></code></pre></td></tr></table></figure><p>打开<code>tmux</code>。（养成好习惯，所有工作都在<code>tmux</code>里进行，防止意外关闭终端后，工作进度丢失）</p><p>然后在<code>tmux</code>中根据<ahref="https://docs.docker.com/engine/install/ubuntu/">docker安装教程</a>安装<code>docker</code>即可。</p></blockquote><h3 id="docker教程">docker教程</h3><blockquote><p><strong>将当前用户添加到<code>docker</code>用户组</strong></p><p>为了避免每次使用<code>docker</code>命令都需要加上<code>sudo</code>权限，可以将当前用户加入安装中自动创建的<code>docker</code>用户组（可以参照<ahref="https://docs.docker.com/engine/install/linux-postinstall/">官方文档</a>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo usermod -aG docker $USER<br></code></pre></td></tr></table></figure><p>执行完此操作后，需要退出服务器，在重新登陆回来，才可以省去<code>sudo</code>权限</p><hr /><p><strong>镜像（imgaes）</strong></p><ol type="1"><li><code>docker pull ubuntu:20.04</code>：拉取一个镜像</li><li><code>docker images</code>：列出本地的所有镜像</li><li><code>docker image rm ubuntu:20.04</code>或<code>docker rmi ubuntu:20.04</code>：删除镜像<code>ubuntu:20.04</code></li><li><code>docker [container] commit CONTAINER IMAGE_NAME:TAG</code>：创建某个<code>container</code>镜像</li><li><code>docker save -o ubuntu_20_04.tar ubuntu:20.04</code>：将镜像<code>ubuntu:20.04</code>导出到本地文件夹<code>ubuntu_20_04.tar</code>中</li><li><code>docker load -i ubuntu_20_04.tar :</code>：将镜像<code>ubuntu:20.04</code>从本地文件<code>ubuntu_20_04.tar</code>中加载出来</li></ol><hr /><p><strong>容器（container）</strong></p><ol type="1"><li><code>docker [container] create -it ubuntu:20.04</code>：利用镜像<code>ubuntu:20.04</code>创建一个容器</li><li><code>docker ps -a</code>：查看本地的所有容器<ol type="1"><li><code>docker [container] start CONTAINER</code>：启动容器</li></ol></li><li><code>docker [container] stop CONTAINER</code>：停止容器</li><li><code>docker [container] restart CONTAINER</code>：重启容器</li><li><code>docker [container] run -itd ubuntu:20.04</code>：创建并启动一个容器</li><li><code>docker [container] attach CONTAINER</code>：进入容器<ul><li>先按住<code>Ctrl+p</code>，再按<code>Ctrl+q</code>可以挂起容器</li></ul></li><li><code>docker [container] exec CONTAINER COMMAND</code>：在容器中执行命令</li><li><code>docker [container] rm CONTAINER</code>：删除容器</li><li><code>docker container prune</code>：删除所有已经停止的容器</li><li><code>docker export -o xxx.tar CONTAINER</code>：将容器<code>CONTAINER</code>导出到本地文件<code>xxx.tar</code>中</li><li><code>docker import xxx.tar image_name:tag</code>：将本地文件<code>xxx.tar</code>导入成镜像，并将镜像命名为<code>image_name:tag</code></li><li><code>docker export/import</code>与<code>docker save/load</code>的区别：<ul><li><code>export/import</code>会丢失历史记录和元数据信息，仅保存容器当时的快照状态</li><li><code>save/load</code>会保存完整记录，体积会更大</li></ul></li><li><code>docker top CONTAINER</code>：查看某个容器内的进程</li><li><code>docker stats</code>：查看所有容器的统计信息，包括CPU、内存、网络等信息</li><li><code>docker cp xxx CONTAINER:xxx</code>或<code>docker cp CONTAINER:xxx xxx</code>：在本地和容器之间复制文件</li><li><code>docker rename CONTAINER1　CONTAINER2</code>：重命名容器</li><li><code>docker update CONTAINER --mermory 500MB</code>：修改容器限制</li></ol><hr /><p><strong>实战</strong>：<font color='green'>使用同一个docker镜像可以保证减少环境不一致导致的开发的耗时</font></p><p>进入AC Terminal，然后：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp /var/lib/acwing/docker/images/docker_lesson_1_0.tar server_name:  # 将镜像上传到自己租的云端服务器<br>ssh server_name  # 登录自己的云端服务器<br><br>docker load -i docker_lesson_1_0.tar  # 将镜像加载到本地<br>docker run -p 20000:22 --name my_docker_server -itd docker_lesson:1.0  # 创建并运行docker_lesson:1.0镜像<br><br>docker attach my_docker_server  # 进入创建的docker容器<br>passwd  # 设置root密码<br></code></pre></td></tr></table></figure><p>去云平台控制台中修改安全组配置，放行端口<code>20000</code>。</p><p>返回ACTerminal，即可通过<code>ssh</code>登录自己的<code>docker</code>容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh root@xxx.xxx.xxx.xxx -p 20000  # 将xxx.xxx.xxx.xxx替换成自己租的服务器的IP地址<br></code></pre></td></tr></table></figure><p>然后，可以仿照上节课内容，创建工作账户<code>acs</code>。</p><p>最后，可以参考<ahref="#4.ssh">4.ssh</a>登录配置<code>docker</code>容器的别名和免密登录。</p><hr /><p><strong>小Tips</strong></p><p>如果<code>apt-get</code>下载软件速度较慢，可以参考<ahref="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">清华大学开源软件镜像站</a>中的内容，修改软件源。</p></blockquote><blockquote><p>注意：本次作业的3个题目不是独立的，每个题目会依赖于前一个题目，因此评测时如果当前题目错误，则不再评测后续题目。</p><p>创建好作业后，先进入文件夹/home/acs/homework/lesson_8/，然后：</p><ol start="0" type="1"><li>进入homework_0文件夹，然后： [1] 租一台云服务器 [2]配置服务器别名及免密登录 [3]将服务器别名写在当前目录下的server_name.txt文件中</li><li>进入homework_1文件夹，然后： [1] 在租好的云服务器中安装docker</li><li>进入homework_2文件夹，然后： [1] 将ACTerminal中的/var/lib/acwing/docker/images/docker_lesson_1_0.tar镜像上传到租好的服务器中[2] 登录到租好的服务器 [3] 将上传的镜像提取出来 [4]创建该镜像的容器，设置端口映射：20000:22。 [5]去云平台控制台中修改安全组配置，放行端口20000。 [6]进入该容器，创建新账户acs [7] 返回ACTerminal。配置容器中acs账户的别名及免密登录。 [8]将别名写在当前目录下的server_name.txt文件中</li></ol></blockquote><h1 id="linux-c-编译连接问题">Linux C++ 编译连接问题</h1><h2 id="链接出问题">1.链接出问题：</h2><ol type="1"><li>自定义类函数没有重载操作符</li><li>判断是否所有的头文件都已经被编译过生成了<code>.o</code>文件</li><li>检车一下是否是服务器掉线了</li><li>一个可执行文件的编译保证只有一个<code>.cpp</code>文件中有<code>main</code>函数</li><li>仔细查看调用的接口的<code>ip</code>地址和端口号是否写错</li></ol>]]></content>
    
    
    <categories>
      
      <category>acwing</category>
      
      <category>工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>acwing</tag>
      
      <tag>学习</tag>
      
      <tag>工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>acwing_基础算法</title>
    <link href="/2023/07/23/acwing_%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    <url>/2023/07/23/acwing_%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>郑重声明：</p><p>注意本文章所有内容都是在acwing网站学习记录需要请前往acwing网站学习获取</p><ul><li>链接：https://www.acwing.com</li><li>来源：AcWing</li><li>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</li></ul><h1 id="基础算法">基础算法</h1><h2 id="一基础部分">一、基础部分</h2><h3 id="快速排序">1.快速排序</h3><p>​ <strong>描述：</strong></p><blockquote><p><strong>第一步：</strong></p></blockquote><h3 id="归并排序">2.归并排序</h3><p>​ <strong>描述：</strong></p><blockquote><figure><img src="/img/learning/acwing/basic_algorithm/归并排序步骤.png"alt="归并排序步骤" /><figcaption aria-hidden="true">归并排序步骤</figcaption></figure><p><strong>第一步：</strong></p><p>确定分界点</p><p><strong>第二步：</strong></p><p>递归排序左边和右边</p><p><strong>第三步：</strong></p><p>合并那个排序好（从小到大 或 从大到小）的两个序列</p><p><strong>求逆序对的数量：</strong><code>AcWing.788</code></p><figure><imgsrc="/img/learning/acwing/basic_algorithm/归并排序求逆序对的数量.png"alt="归并排序求逆序对的数量png" /><figcaption aria-hidden="true">归并排序求逆序对的数量png</figcaption></figure></blockquote><h3 id="二分">3.二分</h3><p>​<strong>描述：</strong>整数二分：有单调性的一定可以二分，没有单调性的也有可以二分的可能。二分的本质并非单调性，而是是边界问题。<strong>二分是一种思想，二分查找是二分思想的一个应用</strong></p><blockquote><p>下图中左右两个边界位置即为二分所要找寻的位置</p><figure><img src="/img/learning/acwing/basic_algorithm/整数二分步骤.png"alt="整数二分步骤" /><figcaption aria-hidden="true">整数二分步骤</figcaption></figure><p><strong>第一步：</strong></p><p>确定所求为左边界点还是右边界点，采用不同的二分方法</p></blockquote><h3 id="高精度算法">4.高精度算法</h3><h4 id="加法">加法</h4><p>​ <strong>描述：</strong></p><blockquote><p><strong>第一步：</strong></p></blockquote><h4 id="减法">减法</h4><p>​ <strong>描述：</strong></p><blockquote><p><strong>第一步：</strong></p></blockquote><h4 id="乘法">乘法</h4><p>​ <strong>描述：</strong></p><blockquote><p><strong>第一步：</strong></p></blockquote><h4 id="除法">除法</h4><p>​ <strong>描述：</strong></p><blockquote><p><strong>第一步：</strong></p></blockquote><h3 id="前缀和差分">5.前缀和差分</h3><h4 id="前缀">前缀</h4><p>​ <strong>描述：</strong></p><blockquote><p>能够提前准备前<code>i</code>个数的和，再次计算<code>l,r</code>之间的和时可以在O(1)的时间内完成计算</p><figure><img src="/img/learning/acwing/basic_algorithm/前缀和.png"alt="前缀和" /><figcaption aria-hidden="true">前缀和</figcaption></figure><p><strong>第一步：</strong></p></blockquote><h4 id="差分">差分</h4><p>​ <strong>描述：</strong></p><blockquote><p>-|可以用来快速处理区间内的操作，比如在原来数组a的l,r区间都加上c或者减去c|-</p><p>给定一个a数组，构造一个b数组，使得a数组是b数组的前缀和,</p><p><span class="math inline">\(b_1 = a_1\)</span></p><p><span class="math inline">\(b_2 = a_2 - a_1\)</span></p><p><span class="math inline">\(b_3 = a_3 - a_2\)</span></p><p>​ .</p><p>​ .</p><p>​ .</p><p><span class="math inline">\(b_n = a_n - a_{n - 1}\)</span></p><figure><img src="/img/learning/acwing/basic_algorithm/差分.png" alt="差分" /><figcaption aria-hidden="true">差分</figcaption></figure><p><strong>第一步：</strong></p></blockquote><h3 id="双指针算法">6.双指针算法</h3><p>​ <strong>描述：</strong></p><blockquote><p>-| 主要是处理两重for循环 |-</p><p>首选 在不考虑时间复杂度的情况下写出多个for循环的处理方法</p><p>然后 再去考虑优化内部的for循环，降低时间复杂度</p><p><strong>第一步：</strong></p></blockquote><h3 id="位运算">7.位运算</h3><p>​ <strong>描述：</strong></p><blockquote><p>可以使用向右移运算操作符<code>&gt;&gt;</code>处理相关问题</p><p><strong>第一步：</strong></p></blockquote><h3 id="离散化">8.离散化</h3><p>​<strong>描述：</strong>将需要处理的点离散到一个较小的区间内完成对大区间分散数据的集中化处理</p><blockquote><p><strong>第一步：</strong></p></blockquote><h3 id="区间合并">9.区间合并</h3><p>​ <strong>描述：</strong></p><blockquote><p>将所有出现的左右区间进行左端点从小到大的顺序进行排序，依次遍历所有区间，如果前后两区间有交集做相应的操作（更新右边界| 不更新右边界）</p><figure><img src="/img/learning/acwing/basic_algorithm/区间合并.png"alt="区间合并" /><figcaption aria-hidden="true">区间合并</figcaption></figure><p><strong>第一步：</strong></p></blockquote><hr /><h2 id="二数据结构">二、数据结构</h2><h3 id="单链表">1.单链表</h3><p>​ <strong>描述：</strong></p><blockquote><p><strong>第一步：</strong></p></blockquote><h3 id="双链表">2.双链表</h3><p>​ <strong>描述：</strong></p><blockquote><p><strong>第一步：</strong></p></blockquote><h3 id="栈">3.栈</h3><p>​<strong>描述：</strong>可以用数组模拟栈，当前下标<code>tt</code>是栈顶下标，实际只需要调整<code>tt</code>即可实现栈的所有操作</p><blockquote><p>模拟栈实现方式</p><figure><img src="/img/learning/acwing/basic_algorithm/模拟栈代码.png"alt="模拟栈代码" /><figcaption aria-hidden="true">模拟栈代码</figcaption></figure><p><strong>第一步：</strong></p></blockquote><h3 id="队列">4.队列</h3><p>​<strong>描述：</strong>可以用数组模拟队列，<code>hh</code>是对头下标<code>tt</code>是队尾下标，实际只需要调整<code>hh</code>和<code>tt</code>即可实现队列的所有操作</p><blockquote><p>模拟数组实现方式</p><figure><img src="/img/learning/acwing/basic_algorithm/模拟队列代码.png"alt="模拟队列代码" /><figcaption aria-hidden="true">模拟队列代码</figcaption></figure><p><strong>第一步：</strong></p></blockquote><h3 id="单调栈">5.单调栈</h3><p>​ <strong>描述：</strong></p><blockquote><p>最常见的情况：给定一个序列，求一下每一个数左边（右边）离他最近的且比它小（大）的数在什么地方</p><p>例子：</p><table><thead><tr class="header"><th style="text-align: left;">一个序列：</th><th>3</th><th>4</th><th>2</th><th>7</th><th>5</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">左边离他最小数：</td><td>-1</td><td>3</td><td>-1</td><td>2</td><td>2</td></tr></tbody></table><p><strong>第一步：</strong></p><p>先两重循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 先考虑暴力做法</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i  ++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i; j &gt;= <span class="hljs-number">0</span>; j -- )<br><span class="hljs-keyword">if</span>(ai &gt; aj)<br> &#123;<br>      cout &lt;&lt; aj &lt;&lt; endl;<br>      <span class="hljs-keyword">break</span>;<br> &#125;<br></code></pre></td></tr></table></figure><p>栈相当于存储了ai前面所有的值，从栈里面一个一个的寻找看是否能够找到第一个比ai小的数为止</p><figure><img src="/img/learning/acwing/basic_algorithm/单调栈.png"alt="单调栈" /><figcaption aria-hidden="true">单调栈</figcaption></figure><p>优化：根据所求条件的单调性如果栈里面存在一个点ak比al小或者相等而且ak在al的右边（也就是说离ai更近且比ai小）把al弹出把ak压入</p></blockquote><h3 id="单调队列----不熟练">6.单调队列 -- 不熟练</h3><p>​ <strong>描述：</strong></p><blockquote><p>最常见可以通过朴素的队列存储当前窗口的值，然后再通过优化队列中维护的值提高算法效率</p><figure><img src="/img/learning/acwing/basic_algorithm/单调队列.png"alt="单调队列" /><figcaption aria-hidden="true">单调队列</figcaption></figure><p>维护一个队列，队列中不存在前面一个数比后面的数大的情况（将需要维护的队列中不需要的数删除），使队列具有单调性，用O(1)时间内取出需要找到的值</p><p><strong>第一步：</strong></p></blockquote><h3 id="kmp----不熟练">7.KMP -- 不熟练</h3><p>​ <strong>描述：</strong></p><blockquote><p>KMP图解，其实是需要找到模式串P中从第1个字符开始到以i结尾的字符结束这段字符中前缀字符串和后缀字符串相同的最长，计入next[i]中以便后续继续做处理</p><figure><img src="/img/learning/acwing/basic_algorithm/KMP图解.png"alt="KMP图解" /><figcaption aria-hidden="true">KMP图解</figcaption></figure><p>1.暴力算法怎么做</p><figure><img src="/img/learning/acwing/basic_algorithm/KMP朴素做法.png"alt="KMP朴素做法" /><figcaption aria-hidden="true">KMP朴素做法</figcaption></figure><p>2.如何去优化</p><p>需要先预处理出相关的a[i]的最长前后缀匹配长度</p><p><strong>第一步：</strong></p></blockquote><h3 id="trie">8.Trie</h3><p>​ <strong>描述：</strong>高效地存储和查找字符串集合地数据结构</p><blockquote><p>例子：求字符串出现次数</p><figure><img src="/img/learning/acwing/basic_algorithm/Trie举例.png"alt="Trie举例" /><figcaption aria-hidden="true">Trie举例</figcaption></figure><p>例子：求最大异或值模拟<imgsrc="/img/learning/acwing/basic_algorithm/Trie求最大异或值模拟.png"alt="Trie求最大异或值模拟" /></p><p><strong>第一步：</strong></p></blockquote><h3 id="并查集----不熟练">9.并查集 -- 不熟练</h3><p>​ <strong>描述：</strong>并查集可以维护一个关系</p><blockquote><p>并查集能够在近乎O(1)的时间完成的操作</p><p>1.将两个集合合并</p><p>2.询问两个元素是否在一个集合当中</p><p><strong>基本原理：</strong>每个集合用一颗树来表示。树根的编号就是整个集合的编号。每个节点存储的是它的父节点，p[x]表示x的父节点</p><p><strong>问题一：</strong>如何判断树根：if(p[x] == x)</p><p><strong>问题二：</strong>如何求x的集合编号：while(p[x] != x) x = p[x]|<code>实际上每次查询根节点的时间复杂度挺高的，需要路径压缩优化（实际就是把每个节点都指向根节点）</code></p><p><strong>问题三：</strong>如何合并两个集合：px是x的集合编号，py是y的集合编号。p[x]= y</p><figure><img src="/img/learning/acwing/basic_algorithm/并查集树形结构.png"alt="并查集树形结构" /><figcaption aria-hidden="true">并查集树形结构</figcaption></figure><p>例子：acwing 240.食物链</p><p>根据每个点跟根节点之间的关系，可以判断这两点之间的关系</p><figure><img src="/img/learning/acwing/basic_algorithm/240.食物链图解.png"alt="240.食物链图解" /><figcaption aria-hidden="true">240.食物链图解</figcaption></figure><p><strong>第一步：</strong></p></blockquote><h3 id="堆">10.堆</h3><p>​ <strong>描述：</strong></p><blockquote><p>基本的三个操作：一维数组下标从1开始比较好实现！</p><p>1.插入一个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">heap[ ++ size] = x<br></code></pre></td></tr></table></figure><p>2.求集合当中的最小值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">heap[<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>3.删除最小值</p><p>将堆的最后一个数放到堆头的部分，主要是堆使用一维数组来实现的删除最后一个数比删除堆头元素的实现简单size --；</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">heap[<span class="hljs-number">1</span>] <span class="hljs-operator">=</span> heap[size]<span class="hljs-comment">;</span><br>size -- <span class="hljs-comment">;</span><br>down(<span class="hljs-number">1</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><font color='red'>4.删除任意一个元素</font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">heap[k] = heap[size];<br>size -- ;<br><span class="hljs-built_in">down</span>(k);<br><span class="hljs-built_in">up</span>(k);<br></code></pre></td></tr></table></figure><p><font color='red'>5.修改任意一个元素</font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">heap[k] = x;<br><span class="hljs-built_in">down</span>(k);<br><span class="hljs-built_in">up</span>(k);<br></code></pre></td></tr></table></figure><p><strong>小根堆：</strong>每个节点都比他的左右节点小</p><p><strong>大根堆：</strong>每个节点都比他的左右节点大s</p><p>使用一个一维数组来存堆，根节点为1，节点x的左儿子为2x，节点x的右儿子为2x+1。down操作是如果一个值变大了就将这个值向下降，up操作是如果一个值小了就将这个值向上升</p><figure><img src="D:\学习\基础算法\堆操作图解.png" alt="堆操作图解" /><figcaption aria-hidden="true">堆操作图解</figcaption></figure></blockquote><h3 id="哈希表">11.哈希表</h3><p>​ <strong>描述：</strong></p><blockquote><p><strong>作用：</strong></p><p>​ 将一个较大范围的数映射到一个较小的范围内进行操作</p><p><strong>存储结构（按数据映射冲突处理方式来分）：</strong></p><p>​ <font color='red'>注意：mod x 的 x最好去一个质数，而且最好是距离2的整数次幂最远的质数</font></p><ul><li><strong>开放寻址法：</strong>开一个一维数组来存储映射到的位置，每次映射都返回未被使用的空位下标，如果已被使用就<code>++</code>继续寻找直到找到空位位置</li></ul><p>​ <code>经验来说，一维数组大小休要开到题目范围的2~3倍</code></p><ul><li><strong>拉链法：</strong>开一个一维数组来存储映射到的位置，每次映射都向该映射位置增加一个节点</li></ul><p>​ <code>注意:在c++中，负数求模为负数</code></p><figure><img src="/img/learning/acwing/basic_algorithm/哈希表-拉链法.png"alt="哈希表-拉链法" /><figcaption aria-hidden="true">哈希表-拉链法</figcaption></figure><p><strong>字符串哈希方式：</strong></p><p>将一个字符串映射成P进制的数</p><p><font color='red'>注意：不能映射为0</font></p><p><font color='red'>当前<spanclass="math inline">\(Ｐ＝131\)</span>或者<spanclass="math inline">\(P=13331\)</span>时候<spanclass="math inline">\(Q=2^{64}\)</span>的时候有<spanclass="math inline">\(99.99\%\)</span>的情况不会发生冲突 | 同时如果使用unsigned long long 来存储的话溢出就是相当于mod的效果了</font></p><p>例子：acwing 841.字符串哈希</p></blockquote><hr /><h2 id="三搜索与图论">三、搜索与图论</h2><h3 id="深度优先遍历dfs">1.深度优先遍历DFS</h3><p>==算法框图==</p><h3 id="图的最短路径算法">2.图的最短路径算法</h3><p>==算法框图==</p><p><imgsrc="/img/learning/acwing/basic_algorithm/图的最短路径算法.png" /></p><p>​</p><h4 id="单源最短路径算法">单源最短路径算法</h4><h5id="基础的dijkstra算法所有边权都是正数">1.基础的Dijkstra算法（<u>所有边权都是正数</u>）</h5><p>​ <strong>描述：</strong>一般的戴克斯特拉算法是最为朴素的做法，即求一个源点到任意一点的最短路径，每一个结点存取的是当前点到源点的待定最小距离初始时是无穷大，在一步一步的迭代过程中更新并确定该最小距离以至完成对除源点以外所有点到源点的最小距离的求解</p><p>==算法步骤==</p><blockquote><p><strong>第一步：</strong></p><p><u>初始化所有点的距离</u></p><p>1、起点距离确定 <code>dist[1] = 0, dist[others] = +∞</code></p><figure><img src="D:\学习\基础算法\代码34827.png" alt="代码34827" /><figcaption aria-hidden="true">代码34827</figcaption></figure></blockquote><blockquote><p><strong>第二步：</strong></p><p><u>找一个最小值，找到当前没有确定最短路径长度的点当中距离最小值的那一个</u></p><p>1、先给定一个 <code>Si</code> 当前已确定最短距离的点</p><p>2、<code>for i</code> 从 <code>0 ~ n</code> 循环<code>n</code>遍 不在<code>Si</code> 中的距离最近的点赋值给 t ： t &lt;- not in Si andmin(dist)</p><ul><li><p>也就是进行n次迭代去确定每个点到起点的最小值，所以说最后需要找寻的终点的最短距离就是dist[n]</p><figure><img src="D:\学习\基础算法\代码483.png" alt="代码483" /><figcaption aria-hidden="true">代码483</figcaption></figure></li><li><p>每次迭代过程中我们都先找到当前未确定的最短距离的点中距离最短的点（该点就是最短距离—— 搜证明）</p></li></ul><p>3、把 <code>t</code> 加到 <code>S</code> 中</p><ul><li>标记当前最短路径点被查询过</li></ul><p>4、用 <code>t</code> 更新其他点的距离</p><ul><li><p>每一个点到起点的最短距离通过当前加入的点进行更新，同时不需要考虑之前已经加入点（因为之前加入的点已经是最小值了）</p><figure><img src="D:\学习\基础算法\代码4332.png" alt="代码4332" /><figcaption aria-hidden="true">代码4332</figcaption></figure></li></ul></blockquote><h5id="堆优化后的dijkstra算法所有边权都是正数">2.堆优化后的Dijkstra算法（<u>所有边权都是正数</u>）</h5><p>​ <strong>描述：</strong>堆优化后的戴克斯特拉算法是在基础算法上面完成了对找寻未确定的最短路径长度的点中找到最短的点的优化从而算法时间复杂度降低，引入优选队列（小根堆）完成对最小路径长度点在<code>O(1)</code> 时间复杂度内取出，插入队列中</p><p>==算法步骤==</p><blockquote><h5 id="第一步">第一步：</h5><p><u>初始化所有点的距离</u></p><p>1、起点距离确定 <code>dist[1] = 0, dist[others] = +∞</code></p><figure><img src="/img/learning/acwing/basic_algorithm/代码34827.png"alt="代码34827" /><figcaption aria-hidden="true">代码34827</figcaption></figure></blockquote><blockquote><h5 id="第二步">第二步：</h5><p>1、源点已经确定，将源点的压入堆<code>heap.push(&#123;0, 1&#125;); first</code>为结点到源点的距离<code>second</code>为结点编号</p><p>2、遍历除源点以外的所有点，更新并确定当前点的最短路径</p><figure><img src="/img/learning/acwing/basic_algorithm/代码4583.png"alt="代码4583" /><figcaption aria-hidden="true">代码4583</figcaption></figure></blockquote><h5id="贝尔曼-福特算法bellman-ford-存在负权边">3.贝尔曼-福特算法（Bellman-Ford<u>存在负权边</u>）</h5><p>​ <strong>描述：</strong>贝尔曼福特算法是通过遍历所有的边更新最短路径</p><blockquote><h5 id="第一步-1">第一步：</h5><p><u>初始化所有点到源点的距离</u></p><p>执行<code>n</code>次，<code>for n</code>次</p><figure><img src="/img/learning/acwing/basic_algorithm/笔记397.png"alt="笔记397" /><figcaption aria-hidden="true">笔记397</figcaption></figure><p>上图k次 从1号点经过不超过k条边到每号点的最短距离</p></blockquote><blockquote><h5 id="第二步-1">第二步:</h5><p>遍历所有边<code>a b w</code>，更新当前点到源点的最短路径距离</p></blockquote><h5id="贝尔曼-福特算法队列优化算法-最短路径快速算法spfashortest-path-faster-algorithm-存在负权边">4.贝尔曼-福特算法队列优化算法| 最短路径快速算法（SPFA（Shortest Path Faster Algorithm）<u>存在负权边</u>）</h5><p>​ <strong>描述：</strong>是一个用于求解有向带权图单源最短路径的算法。这一算法在随机的稀疏图上表现出色，并且适用于带有负边权的图。然而<code>SPFA</code>在最坏情况的时间复杂度与<code>Bellman-Ford</code>算法相同，因此在非负边权的图中使用堆优化的Dijkstra算法效率可能优于<code>SPFA</code>。（只要图当中没有负环，都可以用<code>SPFA</code>来求）主要是优化<code>dist[b] = dist[a] + w;</code>中的<code>dist[a]</code>如果<code>dist[a]</code>变小了之后<code>dist[b]</code>才会变小，才会有优化的可能</p><p>==算法步骤==</p><blockquote><p><strong>第一步：</strong></p><p><u>初始化所有点到源点的距离</u></p><p>初始化队列，源点已确定 -&gt; 入队列</p></blockquote><blockquote><p><strong>第二步：</strong></p><figure><img src="/img/learning/acwing/basic_algorithm/笔记21984.png"alt="笔记21984" /><figcaption aria-hidden="true">笔记21984</figcaption></figure><p>将源点放入队列中，遍历当前队列中取出的队头元素（该点是已经被更新过的点，也即该点之后的点再更新才有意义），根据队头元素遍历其所相邻的所有点并更新其最短距离并将这些点压入队列中重复上述操作</p><figure><img src="/img/learning/acwing/basic_algorithm/代码34923.png"alt="代码34923" /><figcaption aria-hidden="true">代码34923</figcaption></figure></blockquote><h4 id="多源最短路径算法">多源最短路径算法</h4><h5id="弗洛伊德-沃歇尔算法floyd-warshall">1.弗洛伊德-沃歇尔算法（Floyd-Warshall）</h5><p>​ <strong>描述：</strong>是一种在具有正边权重或负边权重（但没有负循环）的有向加权图中查找最短路径的算法</p><p>==算法步骤==</p><blockquote><p><strong>第一步：</strong></p><p><code>n</code>为点总数，用矩阵存储边权，每次更新当前遍历到的结点到任意源点最短距离直到所有距离都更新完</p><figure><img src="/img/learning/acwing/basic_algorithm/代码34847.png"alt="代码34847" /><figcaption aria-hidden="true">代码34847</figcaption></figure></blockquote><h3 id="最小生成树">3.最小生成树</h3><p>==算法框图==</p><figure><img src="/img/learning/acwing/basic_algorithm/最小生成树.png"alt="最小生成树" /><figcaption aria-hidden="true">最小生成树</figcaption></figure><h5 id="普利姆算法prim">1.普利姆算法（Prim）</h5><p>​ <strong>描述：</strong></p><p>==算法步骤==</p><blockquote><p><strong>第一步：</strong></p><p><u>初始化所有距离为<code>+∞</code></u></p><figure><img src="/img/learning/acwing/basic_algorithm/笔记259234.png"alt="笔记259234" /><figcaption aria-hidden="true">笔记259234</figcaption></figure></blockquote><blockquote><p><strong>第二步：</strong></p><p><u>集合：当前已经在连通块中的所有点</u></p><p>迭代n遍找到集合外能够到达集合内部距离最近的点放入t，用t更新其他点到集合的距离（此时t为待定加入集合）最后并将t加入到集合中</p><figure><img src="/img/learning/acwing/basic_algorithm/代码48957.png"alt="代码48957" /><figcaption aria-hidden="true">代码48957</figcaption></figure></blockquote><h5id="普利姆算法堆优化版算法与堆优化版dijkstra算法类似">2.普利姆算法堆优化版算法（与堆优化版dijkstra算法类似）</h5><h5 id="克鲁斯卡尔算法kruskal">3.克鲁斯卡尔算法（Kruskal）</h5><p>​ <strong>描述：</strong></p><p>==算法步骤==</p><blockquote><p><strong>第一步：</strong></p><p>先对所有边权按照大小排序，然后枚举每条边的权重</p><figure><imgsrc="C:\Users\Adrew\AppData\Roaming\Typora\typora-user-images\image-20230726141215523.png"alt="image-20230726141215523" /><figcaption aria-hidden="true">image-20230726141215523</figcaption></figure></blockquote><blockquote><p><strong>Kruskal算法代码：</strong></p><figure><img src="/img/learning/acwing/basic_algorithm/代码490562.png"alt="代码490562" /><figcaption aria-hidden="true">代码490562</figcaption></figure></blockquote><h3 id="二分图">4.二分图</h3><p>​ <strong>描述：</strong>可以将所有的点划分到两边使得所有的边在集合之间存在，集合内部不存在边的图可称为二分图。一个图是二分图当且仅当图中不含奇数环，反之如果一个图含有奇数环他就不可能是二分图</p><p>==算法框图==</p><figure><img src="/img/learning/acwing/basic_algorithm/二分图.png"alt="二分图" /><figcaption aria-hidden="true">二分图</figcaption></figure><h5 id="染色法">1.染色法</h5><h5id="描述-通过对每一个点进行染色一个接一个染如果最后某一种颜色出现了奇数次就错误了返回false在dfs或者是bfs中出现了一条边上面的两个点都是相同颜色也出错误了返回false"><strong>描述：</strong>通过对每一个点进行染色，一个接一个染，如果最后某一种颜色出现了奇数次就错误了返回<code>false</code>，在<code>dfs</code>或者是<code>bfs</code>中出现了一条边上面的两个点都是相同颜色也出错误了返回<code>false</code></h5><p>==算法步骤==</p><blockquote><p><strong>第一步：</strong></p><p>遍历所有点，给每个点染色，<code>dfs</code>递归处理所有点染色</p><figure><img src="/img/learning/acwing/basic_algorithm/笔记2449457.png"alt="笔记2449457" /><figcaption aria-hidden="true">笔记2449457</figcaption></figure></blockquote><blockquote><p><strong>代码实现：</strong></p><figure><img src="/img/learning/acwing/basic_algorithm/代码39547.png"alt="代码39547" /><figcaption aria-hidden="true">代码39547</figcaption></figure></blockquote><h5 id="匈牙利算法">2.匈牙利算法</h5><p>​ <strong>描述：</strong> 不存在两条边是共用了一个点的为成功的匹配 |并且可以返回匹配成功时匹配数量最大的是多少</p><blockquote><p><strong>有趣的实例：</strong></p><ul><li><p>第一个男生有看上两个心意的你女生，而且第一个女生是单身状态就牵红线</p></li><li><p>第二个男生也看上两个心仪的女生，刚好第一个心仪的女生为单身状态就牵红线了</p></li><li><p>第三个男生只看上一个心仪的女生，当前这个女生在跟第一个男生热恋中，但是第三个男生不放弃去询问第一个男生还有没有其他的可能，发现有其他的可能第一个男生就去与他心仪的第二女生牵红线，当前男生根这个被空出女生牵红线了</p></li><li><p>第四个男生只看上一个心仪的女生，刚好当前心仪的女生为单身状态，就牵红线了</p></li></ul><figure><img src="/img/learning/acwing/basic_algorithm/笔记2584.png"alt="笔记2584" /><figcaption aria-hidden="true">笔记2584</figcaption></figure><p>就是讲的是匈牙利算法当遇到没法连接的点时就去不断地询问他希望连接的点已经对应的点是否还有其他连接的可能，如果有就更改连接匹配成功，如果没有就表示匹配不成功，再进行下一个点的匹配操作</p></blockquote><blockquote><p><strong>第一步：</strong></p><p>遍历左半部点集依次为每一个点匹配一个右半部的点，匹配成功返回<code>true</code>匹配失败返回<code>false</code>，然后再进行下一个点的匹配操作</p><figure><img src="/img/learning/acwing/basic_algorithm/代码35937.png"alt="代码35937" /><figcaption aria-hidden="true">代码35937</figcaption></figure></blockquote><hr /><h2 id="四数学知识">四、数学知识</h2><h3 id="质数">1.质数</h3><p>​ <strong>描述：</strong></p><blockquote><p><strong>1.判断质数：</strong></p><p><strong>2.分解质因数：</strong></p><p>​<strong>概念：质因数</strong>（<strong>素因数</strong>或<strong>质因子</strong>）在<ahref="https://baike.baidu.com/item/数论/3700?fromModule=lemma_inlink">数论</a>里是指能整除给定正<ahref="https://baike.baidu.com/item/整数?fromModule=lemma_inlink">整数</a>的<ahref="https://baike.baidu.com/item/质数/263515?fromModule=lemma_inlink">质数</a>。除了1以外，两个没有其他共同质因子的正整数称为<ahref="https://baike.baidu.com/item/互质/577412?fromModule=lemma_inlink">互质</a>。因为1没有质因子，1与任何正整数（包括1本身）都是互质。正整数的<ahref="https://baike.baidu.com/item/因数分解/5827933?fromModule=lemma_inlink">因数分解</a>可将正整数表示为一连串的质因子相乘，质因子如重复可以用<ahref="https://baike.baidu.com/item/指数/3519666?fromModule=lemma_inlink">指数</a>表示。根据<ahref="https://baike.baidu.com/item/算术基本定理/10920095?fromModule=lemma_inlink">算术基本定理</a>，任何正整数皆有独一无二的质因子分解式。只有一个质因子的正整数为质数。</p><p>​ <strong>性质：</strong>n当中最多只包含一个大于<spanclass="math inline">\(\sqrt{n}\)</span>的质因子</p><p><strong>3.筛选质数：</strong></p><p>​ <strong>概念</strong>晒出1到n中任意个数的所有质数个数</p><p>​ <strong>朴素版：</strong></p><figure><img src="/img/learning/acwing/basic_algorithm/筛质数朴素版.png"alt="筛质数朴素版" /><figcaption aria-hidden="true">筛质数朴素版</figcaption></figure><p>​当筛到一个数p时，将他后面所有的倍数都删除，如果遍历到p时判断它没有被删除可以确定在2到p-1没有p的约数，也即p不是2到p-1所有数的倍数，所以说p即质数</p><p>​ 时间复杂度：<span class="math inline">\(\frac n2+\frac n3+\fracn4+\frac n5+...+\frac nn\)</span>为调和级数<spanclass="math inline">\(ln^n+C\)</span>可以看作<spanclass="math inline">\(O(log_e^n)\)</span>或者看作<spanclass="math inline">\(O(nlog^n)\)</span>,</p><p>​<strong>埃氏筛法（埃拉特斯特尼筛法）：</strong><code>朴素版经过简单的优化</code>不需要筛除所有数的倍数，而只需要将2到p-1所有的质数筛出掉就可以了，优化过后时间复杂度可以降低到<spanclass="math inline">\(O(log^{log^{n}})\)</span>（准确来说）（质数定理：1到n当中有<spanclass="math inline">\(\frac n{ln^n}\)</span>个质数）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )<br>&#123;<br>  <span class="hljs-keyword">if</span>(!st[i])<br>  &#123;<br>      prime[cnt ++ ] = i;<br>  &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + i; j &lt;= n; j += i) st[j] = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​ <strong>线性筛法（欧拉线性筛、欧拉筛）：</strong></p><p>​blog：https://majorli.github.io/algo_guide/ch05/sec01/511_euler_seive.html</p><p>​ 争取把每一个和数用它的最小质因子筛掉</p><p>​ <code>重点：n只会被最小质因子筛掉</code></p><p>​ 1、i % primes[j] == 0</p><p>​ primes[j] 一定是i的最小质因子，primes[j]也已经是primes[j] *i的最小质因子</p><p>​ 2、i % primes[j] != 0</p><p>​ primes[j]一定是小于i的所有质因子，primes[j]也一定是primes[j] *i的最小质因子</p><p>​ 对于一个和数，假设primes[j]是x的最小质因子，当i枚举到 x / primes[j]的时候会被筛出掉</p><p>​以上两种情况下都可以筛出最小质因子的倍数所以，最后每个数只会被筛一次</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )<br>&#123;<br>  <span class="hljs-keyword">if</span>(!st[i]) prime[cnt ++ ] = i;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; prime[j] &lt;= n / i; j ++)<br>  &#123;<br>      st[prime[j] * i] = <span class="hljs-literal">true</span>;<br>      <span class="hljs-keyword">if</span>(i % prime[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// prime[j] 一定是i的最小质因子</span><br>  &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h3 id="约数">2.约数</h3><p>​ <strong>描述：</strong></p><blockquote><p><strong>1.判断约数：</strong></p><p>​<strong>试除法：</strong><code>for(int i = 1; i &lt;= n / i; i ++)</code>遍历每一个数判断当前这个数i是否使n的约束是则存储，最后输出</p><p><strong>2.约数个数：</strong></p><p>​<strong>算数基本定理：</strong>又称为<strong>正整数</strong>的<strong>唯一分解定理</strong>,即:每个大于1的自然数均可写为质数的积,而且这些素因子按大小排列之后,写法仅有一种方式。</p><p>​ 公式：<span class="math inline">\(N = {p_1}^{r_1} + {p_2}^{r_2} +{p_3}^{r_3} + {p_4}^{r_4} + ... +{p_n}^{r_n}\)</span>（pi是质数却ri&gt;=0）</p><p>​ 而<strong>求N因子个数</strong>可以用<spanclass="math inline">\(r_1,r_2,r_3,...,r_n\)</span>来求</p><p>​ 而N的约束可以由约数<span class="math inline">\(d = {p_1}^{\beta_1} +{p_2}^{\beta_2} + {p_3}^{\beta_3} + {p_4}^{\beta_4} + ...+{p_n}^{\beta_n}\)</span>来分析，中的<spanclass="math inline">\(\beta_1,\beta_2,...,\beta_n\)</span>都是从[0,r1],[0,r2],...,[0,rn]中取值的，最后不同的取值得到的d不同且唯一（<strong>算数基本定理</strong>）所以得到数因子个数公式</p><p>​ 公式：<span class="math inline">\(ans1 =(1+r_1)*(1+r_2)*(1+r_3)*...*(1+r_n)\)</span></p><p>​这个式子：例如<strong>1+r1就是p1的选择有0个至r1个，有1+r1种情况</strong>，其他的一个道理，最后把它们乘起来，主要是运用了排列组合</p><p><strong>3.约数之和：</strong></p><p>​ 公式：<span class="math inline">\(ans2=({p_1}^0 + {p_1}^1 + {p_1}^2+ ... + {p_1}^ {\alpha _{1}}) \times ({p_2}^0 + {p_2}^1 + {p_2}^2 + ...+ {p_2}^{\alpha _{2}}) \times ... \times ({p_k}^0 + {p_k}^1 + {p_k}^2 +... + {p_k}^{\alpha _{k}})\)</span></p><p>​ 相当于有<span class="math inline">\(ans1\)</span>个<spanclass="math inline">\(sub={p_1}^{\beta_1}\times{p_2}^{\beta_2}\times...\times{p_k}^{\beta_k}\)</span>（<spanclass="math inline">\(\beta_1\in[0,\alpha_1], \beta_2\in[0,\alpha_2],...\)</span>）相加而成，所么每一个<spanclass="math inline">\(sub\)</span>其实就是<spanclass="math inline">\(ans2\)</span>的一个约数，所有不重复的组合每一个约数不同且唯一（<strong>算数基本定理</strong>）所以最后只用求最后<spanclass="math inline">\(ans2\)</span>总和的约数和即可</p><p><strong>4.最大公约数</strong></p><p>​ 如果有一个整数b，满足 b / a 和 b / d能整除， 则有 <spanclass="math inline">\(\frac b{x*a+y*d}\)</span>能整除</p><p>​ <strong>核心公式：</strong><span class="math inline">\(gcd(a, b) =gcd(a, a \% b)\)</span></p><p>​ <strong>1、辗转相除法：</strong></p><p>​又称<strong><font color='green'>欧几里德算法</font></strong>，是求两个数的<em>最大公约数（greatestcommondivisor）</em>的一种方法。用较大的数除以较小的数，再以除数和余数反复做除法运算，当余数为0时，取当前算式除数为最大公约数。</p><p>​ 求30和18的最大公约数：</p><p>​ 30/18=1余12</p><p>​ 18/12=1余6</p><p>​ 30和18的最大公约数为6</p><p>​ <strong>2、更相减损法</strong></p><p>​更相减损法原本是为了约分而设计的：可半者半之，不可半者，副置分母、子之数，以少减多，更相减损，求其等也。以等数约之。</p><p>​1.任意给定两个正整数，判断他们是否都是偶数。若是，则用2约简；若不是则执行第二步</p><p>​2.以较大的数减较小的数，接着把所得的差与较小的数比较，并以大数减小数。继续操作2直到所得到的减数和差相等为止</p><p>​ <strong>辗转相除法与更相减损术的比较</strong></p><p>​（1）两者都是求最大公因数的方法，计算上辗转相除法以除法为主，更相减损术以减法为主，计算次数上辗转相除法计算次数相对较少，特别当两个数字大小区别较大时计算次数的区别较明显。</p><p>​（2）从结果体现形式来看，辗转相除法体现结果是以相除余数为0则得到，而更相减损术则以减数与差相等而得到。</p></blockquote><h3 id="欧拉函数">3.欧拉函数</h3><p>​ <strong>描述：</strong></p><blockquote><p><strong>说法：</strong>记号<spanclass="math inline">\(\phi(n)\)</span>表示<span class="math inline">\(1\sim n\)</span>当中与<spanclass="math inline">\(n\)</span>互质的数的个数</p><p>N分解质因数后的公式：<span class="math inline">\(N = {p_1}^{\alpha_1}+ {p_2}^{\alpha_2} + {p_3}^{\alpha_3} + {p_4}^{\alpha_4} + ...+{p_n}^{\alpha_n}\)</span>（<spanclass="math inline">\(p_i\)</span>是质数却<spanclass="math inline">\(\alpha_i&gt;=0\)</span>）</p><p>有公式<spanclass="math inline">\(\phi_1(n)=N(1-\frac1{p_1})(1-\frac1{p_2})(1-\frac1{p_3})...(1-\frac1{p_n})\)</span>(<strong>容斥原理证明</strong>)</p><p><strong>容斥原理证明：</strong></p><p>1.从<span class="math inline">\(1 \sim N\)</span>当中减去<spanclass="math inline">\(p_1，p_2，...,p_n\)</span>的所有倍数</p><p>2.从<span class="math inline">\(1 \sim N\)</span>当中加上<spanclass="math inline">\(p_1*p_2,p_1*p_3,...,p_i*p_j\)</span>的倍数</p><p>3.从<span class="math inline">\(1\sim N\)</span>当中减去<spanclass="math inline">\(p_1*p_2*p_3,p_1*p_3*p_4,...,p_i*p_j*p_k\)</span>的倍数</p><p>...</p><p>得到<span class="math inline">\(\phi_2(n)=N-{\frac N{p_1}}-{\fracN{p_2}}-{\frac N{p_3}}-...-{\frac N{p_n}}+{\frac N{p_1p_2}}+{\fracN{p_1p_3}}+...+{\frac N{p_ip_j}}-{\frac N{p_1p_2p_3}}-{\fracN{p_1p_3p_4}}-...-{\frac N{p_ip_jp_k}}+...\)</span></p><p>最后<spanclass="math inline">\(\phi(n)=\phi_1(n)=\phi_2(n)\)</span>即欧拉函数</p><p><strong>筛法（优化找到质因数）：</strong></p><p>见上素数筛法一讲</p><p><code>acwing 874.筛法求欧拉函数</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000010</span>;<br><span class="hljs-type">int</span> primes[N], phi[N], cnt;<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function">LL <span class="hljs-title">get_eulers</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>phi[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++)<br>&#123;<br>  <span class="hljs-keyword">if</span>(!st[i])<br>  &#123;<br>      primes[cnt ++] = i;<br>      phi[i] = i - <span class="hljs-number">1</span>;   <br>  &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; primes[j] &lt;= n / i; j ++)<br>  &#123;<br>      st[primes[j] * i] = <span class="hljs-literal">true</span>;<br>      <span class="hljs-keyword">if</span>(i % primes[j] == <span class="hljs-number">0</span>)<br>      &#123;<br>          phi[primes[j] * i] = primes[j] * phi[i];<br>          <span class="hljs-keyword">break</span>;<br>      &#125;<br>      phi[primes[j] * i] = (primes[j] - <span class="hljs-number">1</span>) * phi[i];<br>  &#125;<br>&#125;<br><br>LL res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) res += phi[i];<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<br><br>cout &lt;&lt; <span class="hljs-built_in">get_eulers</span>(n) &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h3 id="快速幂">4.快速幂</h3><p>​ <strong>描述：</strong></p><blockquote><p><strong>1.快速幂</strong></p><p>​ 快速的求出<span class="math inline">\(a^k \bmodp\)</span>的结果，在<spanclass="math inline">\(O(log^k)\)</span>时间复杂度内求出来</p><p><strong>反复平方法：</strong></p><p>需要预处理出来一些结果,目标就是将<spanclass="math inline">\(k\)</span>拆成<spanclass="math inline">\(2^{x_1},2^{x_2},2^{x_3},...,2^{x_k}\)</span>累加和，例：<spanclass="math inline">\((5)_{10}=(101)_{2}\)</span>就可以拆成<spanclass="math inline">\(k=2^0+2^2\)</span>:</p><p><span class="math inline">\(mod_0=a^{2^0} (\bmod p)\)</span></p><p><span class="math inline">\(mod_1=a^{2^1} (\bmod p)\)</span></p><p><span class="math inline">\(mod_2=a^{2^2} (\bmod p)\)</span></p><p>...</p><p><span class="math inline">\(mod_{log_k}=a^{2^{log_k}} (\bmodp)\)</span></p><p>需要将上面结果的数先存储下来，最终需要求<spanclass="math inline">\(2^k \bmod p\)</span>的结果的话就只用求，<spanclass="math inline">\(mod_1,...,mod_{log_k}\)</span>中k权值为1的书的累乘即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(k)<br>&#123;<br>  <span class="hljs-keyword">if</span>(k &amp; <span class="hljs-number">1</span>) res = (LL)res * a % p;<br>  k &gt;&gt;= <span class="hljs-number">1</span>;<br>  a = a * a % p;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2.快速幂求逆元</strong></p><p>​ 如果<span class="math inline">\(\fracab\)</span>是一个整数的话，我们希望不做除法（取余数出发比较麻烦），如果能够找到一个数<spanclass="math inline">\(x\)</span>使得<span class="math inline">\(\frac ab\equiv a \times x \ \ (\bmod m)\)</span> (1)余数相同的话，就把<spanclass="math inline">\(x\)</span>叫做<spanclass="math inline">\(b\)</span>模<spanclass="math inline">\(m\)</span>的逆元，这个<spanclass="math inline">\(x\)</span>记作标记符<spanclass="math inline">\(b^{-1}\)</span>,将式(1)变换一下</p><p>​ 通俗来讲就是给定一个<spanclass="math inline">\(b\)</span>找到一个<spanclass="math inline">\(x\)</span>使得<span class="math inline">\(b \timesx \equiv 1 \ \ (\bmodp)\)</span>,又根据<strong>费马小定理</strong>，如果b是质数的话即只需要求出<spanclass="math inline">\(b·b^{p-2} \equiv 1\ \ (\bmod p)\)</span>中的<spanclass="math inline">\(b^{p-2}\)</span>即可，又因为p是质数所以p-2是合法的</p><p><strong>费马小定理：</strong></p><p>是数论中的一个定理。假如a是一个整数，p是一个质数，那么<spanclass="math inline">\(a^p-a\)</span>是<spanclass="math inline">\(p\)</span>的倍数，可以表示为</p><p><span class="math display">\[a^p \equiv a\ \ (\bmod p)\]</span></p><p>如果<span class="math inline">\(a\)</span>不是<spanclass="math inline">\(p\)</span>的倍数，这个定理也可以写成<strong>更加常用的形式</strong></p><p><span class="math display">\[a^{p-1} \equiv 1\ \ (\bmodp)\]</span></p><p>费马小定理的逆叙述不成立，即假如<spanclass="math inline">\(a^p-a\)</span>是<spanclass="math inline">\(p\)</span>的倍数，<spanclass="math inline">\(p\)</span>不一定是一个质数。例如<spanclass="math inline">\(2^{341}−2\)</span>是<spanclass="math inline">\(341\)</span>的倍数，但<spanclass="math inline">\(341=11×31\)</span>,不是质数。满足费马小定理的合数被称为费马伪素数。</p></blockquote><h3 id="扩展欧几里得算法">5.扩展欧几里得算法</h3><p>​ <strong>描述：</strong></p><blockquote><p><strong>扩展欧几里得算法</strong></p><p>在原先欧几里算法基础上进行扩展完成对裴蜀定理中x，y的求解，即典型求<code>给定 n 对正整数 ai,bi对于每对数，求出一组 xi,yi使其满足 ai×xi+bi×yi=gcd(ai,bi)</code></p><p><strong>裴蜀定理：</strong></p><p>1、对于任意一对正整数a,b,那么一定存在非零整数x,y,使得ax+by=GCD(a,b),a和b最大公约数就是a和b能够凑出来的最小的正整数</p><p>2、而扩展欧几里得算法就是给定任意正整数a，b都可以构造出来非零整数x，y使得满足ax+by=GCD(a,b)</p><p>3、凡是能够有x,y凑出来的数都是GCD(a,b)的倍数</p><p><code>acwing 877.扩展欧几里得算法</code></p><figure><img src="/img/learning/acwing/basic_algorithm/扩展欧几里得算法推导.png"alt="扩展欧几里得算法推导" /><figcaption aria-hidden="true">扩展欧几里得算法推导</figcaption></figure><p><strong>线性同余方程：</strong></p><p>给定任意正整数<span class="math inline">\(a, b,m\)</span>求得一个<span class="math inline">\(x\)</span>使得其满足<spanclass="math inline">\(a \times x \equiv b \ (\bmod m)\)</span></p><p>设<span class="math inline">\(y\)</span>使得上述等式转换<spanclass="math inline">\(a \times x = b + m \times y\)</span>，即求<spanclass="math inline">\(a \times x - m \times y= b\)</span>，令<spanclass="math inline">\(y^‘=-y\)</span>则<span class="math inline">\(a\times x + m \times {y^‘}= b\)</span>其实就是求满足a,b最大公约数时候<span class="math inline">\((a \times x + m \times {y^‘})\times \frac bd= d \times \fracbd\)</span>，所以x，y的值最终结果就是<span class="math inline">\(\fracbd \timesx\)</span>(<code>d=exgcd(int a, int b, int&amp; x, int&amp; y)</code>最大公约数等式右边)</p></blockquote><h3 id="中国剩余定理">6.中国剩余定理</h3><p>​ <strong>描述：</strong></p><blockquote><p>​</p></blockquote><h3 id="高斯消元">7.高斯消元</h3><p>​ <strong>描述：</strong></p><blockquote><p>将方程组的系数抽出来，再加一列方程组的值bi形成一个<spanclass="math inline">\(n \times (n + 1)\)</span>的矩阵</p><p><strong>初等行列变换：</strong></p><p>​ 1.把某一行乘一个非零的数 === 方程等式左右两边乘上一个相同的数</p><p>​ 2.交换某两行 === 两个方程上下位置交换</p><p>​ 3.把某行的若干倍加到另一行 ===某一个方程乘上若干倍加到另一个方程上消元</p><p>最后变换成的矩阵是上三角的形式：</p><figure><img src="/img/learning/acwing/basic_algorithm/高斯消元上三角矩阵.png"alt="高斯消元上三角矩阵" /><figcaption aria-hidden="true">高斯消元上三角矩阵</figcaption></figure><p>​ 1.完美阶梯形 -&gt; 唯一解(0)</p><p>​ 2.0 != 非零 -&gt; 无解(2)</p><p>​ 3.0 == 0 -&gt; 无穷多组解(1)</p><p><strong>高斯消元步骤：</strong></p><p>​ 枚举每一列c</p><p>​ 1、找到当前这一列绝对值最大的一行</p><p>​ 2、将这一行换到最上面去</p><p>​ 3、将该行的第一个数转成1</p><p>​ 4、将下面所有行的第c列消成0</p><p><strong>异或方程组消元步骤：</strong></p><p>异或：不进位的加法</p><p>​ 1.消成三角矩阵</p><p>​ 1 找到当前这一列绝对值最大的一行</p><p>​ 2 将这一行换到最上面去</p><p>​ 3 将该行的第一个数转成1</p><p>​ 4 将下面所有行的第c列消成0</p><p>​ 2.判断</p><p>​ 1 完美 -&gt; 有唯一解</p><p>​ 2 有矛盾 -&gt; 无解</p><p>​ 3 无 -&gt; 无穷解</p></blockquote><h3 id="求组合数">8.求组合数</h3><p>​ <strong>描述：</strong></p><blockquote><p><strong>组合数:</strong> <span class="math display">\[C_{a}^{b}={\frac {a \times {(a - 1)} \times ... \times {(a - b + 1)}} {1\times 2 \times 3 \times ... \times {b}}}=\frac {a!} {b! \times {(a -b)!}}\]</span> <strong>多种情况：</strong></p><p>1、10万种询问，1 &lt;= b &lt;= a &lt;= 2000 -&gt;采用递推模式：先预处理出来所有<spanclass="math inline">\(C_{a}^{b}\)</span></p><p><strong>递推模式：</strong></p><figure><img src="/img/learning/acwing/basic_algorithm/组合数递推式1.png"alt="组合数递推式1" /><figcaption aria-hidden="true">组合数递推式1</figcaption></figure><p>2、1万种询问，1 &lt;= b &lt;= a &lt;= 1e5 -&gt;预处理出来阶乘：先预处理出来所有的<spanclass="math inline">\(a!\)</span> , 询问的时候直接计算输出 <spanclass="math display">\[\frac {a!} {b! \times {(a - b)!}}\]</span> 3、20中询问，1 &lt;= b &lt;= a &lt;= 1e18 1 &lt;= p &lt;= 1e5-&gt; <strong>卢卡斯定理 Lucas：</strong> <spanclass="math inline">\(C_{a}^{b} \equiv C_{a \ \bmod \ p}^{b \ \bmod \p}·C_{a / p}^{b / p} \ (\bmod \ p)\)</span></p><p><strong>卢斯定理简单证明：</strong></p><figure><img src="/img/learning/acwing/basic_algorithm/卢卡斯定理简单证明.png"alt="卢卡斯定理简单证明" /><figcaption aria-hidden="true">卢卡斯定理简单证明</figcaption></figure><p>​<strong>详细证明：</strong>见https://www.cnblogs.com/onlyblues/p/15339937.html</p><p>4、只算一个，但是需要将该数的组合数输出，且是一个非常大的数</p><p>​ 从定义出发：</p><p>​ 1.先把 <span class="math display">\[C_{a}^{b}=\frac {a \times {(a - 1)} \times ... \times {(a - b + 1)}} {1\times 2 \times 3 \times ... \timesb}=p_1^{\alpha_1}·p_2^{\alpha_2}·p_3^{\alpha_3}···p_k^{\alpha_k}\]</span> ​ 分解质因数</p><p>​ 2.写一个高精度乘法</p><figure><img src="/img/learning/acwing/basic_algorithm/组合数+高精度乘法.png"alt="组合数+高精度乘法" /><figcaption aria-hidden="true">组合数+高精度乘法</figcaption></figure><p>​</p><p>​<strong>问题：</strong><code>acwing 889.满足条件的01序列：</code>给定 n个 0 和 n 个 1，它们将按照某种顺序排成长度为 2n的序列，求它们能排列成的所有序列中，能够满足任意前缀序列中 0的个数都不少于 1 的个数的序列有多少个。</p><p>​ <strong>卡塔兰数：</strong> <span class="math display">\[C_{2n}^{n}-C_{2n}^{n-1}=\frac {C_{2n}^{n}} {n+1}\]</span> ​ 所有的方案都可以找到(n,n)这个点</p><figure><img src="/img/learning/acwing/basic_algorithm/卡特兰数.png"alt="卡特兰数" /><figcaption aria-hidden="true">卡特兰数</figcaption></figure></blockquote><h3 id="容斥原理">9.容斥原理</h3><p>​ <strong>描述：</strong></p><blockquote><p><strong>韦恩图</strong></p><p>举例一个三个圆拼起来的总面积：<span class="math inline">\(S_1 + S_2 +S_3 - S_1 \cap S_2 - S_1 \cap S_3 - S_2 \cap S_3 + S_1 \cap S_2 \capS_3\)</span></p><figure><img src="/img/learning/acwing/basic_algorithm/容斥原理韦恩图.png"alt="容斥原理韦恩图" /><figcaption aria-hidden="true">容斥原理韦恩图</figcaption></figure><p><strong>总的方案数 == 从n个数中选出任意多个数的方案数</strong></p><p>​ <spanclass="math inline">\(\cancel{C_{n}^{0}}+C_{n}^{1}+C_{n}^{3}+...+C_{n}^{n}\)</span>即所有从n个数种选0个数的方案加成选1个数的方案加上选2个数的方案加加加 加到选n个数的方案</p><p>​ <span class="math inline">\(2^n -1\)</span>表示的就是从n个数中选任意多个数的数量</p><p>上面两个求出的是一个问题，所以等式两边是成立的</p><p><span class="math inline">\(|S_1 \cup S_2 \cup S_3 \cup ··· \cup S_n|= \sum_{i}|S_i| - \sum_{i·j}|S_i \cap S_j| + \sum_{i·j·k}|S_i \cap S_j\cap S_k| - ···\)</span></p><figure><img src="/img/learning/acwing/basic_algorithm/容斥原理举例.png"alt="容斥原理举例" /><figcaption aria-hidden="true">容斥原理举例</figcaption></figure></blockquote><h3 id="博弈论">10.博弈论</h3><p>​ <strong>描述：</strong></p><blockquote><p><strong>Nim游戏：</strong></p><p>​ <strong>先手必胜状态：可以走到某一个必败状态</strong></p><p>​ <strong>先手必败状态：走不到任何一个必败状态</strong></p><p><strong>一个栗子：</strong>给定 n堆石子，两位玩家轮流操作，每次操作可以从任意一堆石子中拿走任意数量的石子（可以拿完，但不能不拿），最后无法进行操作的人视为失败。</p><p>问如果<strong>两人都采用最优策略，先手是否必胜。</strong></p><p>有这样一个<strong>性质</strong>：<span class="math inline">\(a_1\oplus a_2 \oplus a_3 \oplus ... \oplus a_n =0\)</span>则先手必败，反之先手必胜</p><p><strong>简单证明:</strong></p><p>如果当前状态不是0的话，那么一定可以存在一个数x使得拿完x个石子后剩下的石子堆数量异或后为0</p><figure><img src="/img/learning/acwing/basic_algorithm/Nim简单证明.png"alt="Nim简单证明" /><figcaption aria-hidden="true">Nim简单证明</figcaption></figure><p>如果当前石子数量状态时所有异或后是0，那么在拿完一个数x的石子之后，原石子堆各个数量异或值一定不会是0(反证法)</p><figure><img src="/img/learning/acwing/basic_algorithm/Nim简单证明2.png"alt="Nim简单证明2" /><figcaption aria-hidden="true">Nim简单证明2</figcaption></figure><p><strong>台阶Nim游戏：</strong></p><p><strong>mex{}函数是从集合当中找到不存在的最小自然数</strong></p><p><strong>SG函数：</strong><spanclass="math inline">\(SG(x)=mex({SG(y_1), SG(y_2), SG(y_3), SG(y_4), ..., SG(y_k)})\)</span></p><p>小结：任何一种非零的状态都可以有一种方案走到零，任何一种零的状态都走到不了零</p><figure><img src="/img/learning/acwing/basic_algorithm/SG函数.png"alt="SG函数" /><figcaption aria-hidden="true">SG函数</figcaption></figure><p><strong>拆分Nim游戏：</strong></p></blockquote><h2 id="五动态规划">五、动态规划</h2><p>​ <strong>描述：</strong></p><h3 id="背包问题">1.背包问题</h3><p>​<strong>描述：</strong>给定一些物品，这些物品的选择满足一定的<strong>条件</strong>(有选择方面的容量体积类别等限制)，问能够选择的物品<strong>属性</strong>(价值总和最大、价值总和最小、选法数量...等等)是多少</p><p>​ <strong>注意：</strong>背包不一定装满</p><blockquote><p><strong>1. 0 1 背包：</strong>每件物品最多只用一次</p><p>​ 每一件物品都有体积和权重两个属性，从前i个物品中选选出不超过背包最大体积的选法中总价值最大的选法的价值</p><figure><img src="/img/learning/acwing/basic_algorithm/01背包问题状态分析.png"alt="01背包问题状态分析" /><figcaption aria-hidden="true">01背包问题状态分析</figcaption></figure><p><strong>2. 完全背包：</strong>每件物品有无限个</p><p>​ 所有只考虑前i个物品，且总体积不大于j的所有选法</p><p>​ <strong>1、朴素版：</strong></p><figure><img src="/img/learning/acwing/basic_algorithm/完全背包问题状态分析.png"alt="完全背包问题状态分析" /><figcaption aria-hidden="true">完全背包问题状态分析</figcaption></figure><p>​ <strong>2、优化版：</strong></p><p>​ 问题优化</p><figure><img src="/img/learning/acwing/basic_algorithm/完全背包问题优化.png"alt="完全背包问题优化" /><figcaption aria-hidden="true">完全背包问题优化</figcaption></figure><p><strong>3. 多重背包：</strong>每个物品有确定的个数</p><p>​ <strong>1、朴素版：</strong></p><figure><img src="/img/learning/acwing/basic_algorithm/多重背包问题状态分析.png"alt="多重背包问题状态分析" /><figcaption aria-hidden="true">多重背包问题状态分析</figcaption></figure><p>​ <strong>2、优化版：</strong></p><p>问题优化：先按照多重背包优化方式考虑</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">f[i,j]=<span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>,j],f[i<span class="hljs-number">-1</span>,j-v]+w,f[i<span class="hljs-number">-1</span>,j<span class="hljs-number">-2</span>v]+<span class="hljs-number">2</span>w,...,f[i<span class="hljs-number">-1</span>,j-sv]+sw)<br>f[i,j-v]=<span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>,j-v],  f[i<span class="hljs-number">-1</span>,j<span class="hljs-number">-2</span>v]+w, ...,f[i<span class="hljs-number">-1</span>,j-sv]+(s<span class="hljs-number">-1</span>)w,f[i<span class="hljs-number">-1</span>,j-(s+<span class="hljs-number">1</span>)v]+sw)<br></code></pre></td></tr></table></figure><p>已知前s个方案的最大值是无法求出第s个方案的最大值的所以多重背包不能用完全背包的优化方式来优化</p><p><strong>二进制优化方式：</strong></p><p>将一个物品拆分成数量为1，2，4，8，16，...，c的物品，再按照01背包问题处理即可</p><p><strong>4.分组背包：</strong>每一个组里面最多选择一个物品</p><p>​例如在<strong>水果</strong>这一个组别中选择了苹果就不能选择其他水果了</p></blockquote><h3 id="线性dp">2.线性DP</h3><p>​<strong>描述：</strong>多维状态有一个大概的的线性顺序的推理方式的话，就可称其为线性DP</p><p>​ 一般动态规划问题<strong>时间复杂度</strong>计算 <strong>状态数量 ×状态转移计算量</strong></p><blockquote><p><strong>1.数字三角形：</strong></p><figure><img src="/img/learning/acwing/basic_algorithm/线性DP数字三角形.png"alt="线性DP线性三角形" /><figcaption aria-hidden="true">线性DP线性三角形</figcaption></figure><p><strong>2.最长上升子序列：</strong></p><p>​ <strong>Ⅰ：朴素版</strong><spanclass="math inline">\(O(n^2)\)</span></p><figure><img src="/img/learning/acwing/basic_algorithm/线性DP最长上升子序列.png"alt="线性DP最长上升序列" /><figcaption aria-hidden="true">线性DP最长上升序列</figcaption></figure><p>状态转移公式：<span class="math inline">\(if(a[i] &gt;a[j]) \ \f[i]=max(f[j] + 1), \ \ a_j&lt;a_i, \ \ j=0,1,2,3,...,i-1\)</span></p><p>​ <strong>Ⅱ：优化版</strong></p><p>​</p><p><strong>３．最长公共子序列：</strong></p><p>​</p><figure><img src="/img/learning/acwing/basic_algorithm/线性DP最长公共子序列.png"alt="线性DP最长公共子序列" /><figcaption aria-hidden="true">线性DP最长公共子序列</figcaption></figure><p>f[i-1,j]和f[i,j-1]其实就已经包含了f[i-1,j-1]所以计算时不需要把f[i-1,j-1]计算也行</p></blockquote><h3 id="区间dp">3.区间DP</h3><p>​ <strong>描述：</strong>状态表示一般就是表示某一个区间</p><blockquote><p><strong>合并石子：</strong><code>Acwing.282</code></p><p>以最后一次合并的两堆石子来分类，最后一定是左边一堆若干个石子，右边那一堆若干个石子</p><figure><img src="/img/learning/acwing/basic_algorithm/区间DP石子合并.png"alt="区间DP堆石子" /><figcaption aria-hidden="true">区间DP堆石子</figcaption></figure><p>状态转移公式：<span class="math inline">\(f[i,j]= min(f[i,k], f[i][k]+ f[k + 1][j] + s[k] - s[i - 1]), \  k=i \sim j-1\)</span></p></blockquote><h3 id="计数类dp">4.计数类DP</h3><p>​ <strong>描述：</strong></p><blockquote><p><strong>整数划分:</strong> <code>AcWing.900</code></p><p>​ 一个正整数 n可以表示成若干个正整数之和，形如：n=n1+n2+…+nk，其中n1≥n2≥…≥nk,k≥1。</p><p>​ 我们将这样的一种表示称为正整数 n 的一种划分。</p><p>​ 现在给定一个正整数 n，请你求出 n 共有多少种不同的划分方法。</p><p><strong>思路：</strong>问题可以从背包问题思考模式进入，将题目了看成有n种物品（1~ n 数字）每种物品（每个数字）有无限个，考虑放进容量为n的背包中看有多少种方案<strong>其实这个问题就转换成一个完全背包问题 只是所需要求的属性是数量</strong></p><figure><img src="/img/learning/acwing/basic_algorithm/计数类DP整数划分.png"alt="计数类DP整数划分" /><figcaption aria-hidden="true">计数类DP整数划分</figcaption></figure><p>集合：考虑从前i个数中选择数使得这些数的总和恰好是j的方案数</p><p>属性：Num</p><p><strong>优化：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">f[i][j] = f[i - <span class="hljs-number">1</span>][j] + f[i - <span class="hljs-number">1</span>][j - i] + f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">2</span> * i] + f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">3</span> * i] + ... + f[i - <span class="hljs-number">1</span>][j - s * i]<br>f[i][j - i] =           f[i - <span class="hljs-number">1</span>][j - i] + f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">2</span> * i] + f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">3</span> * i] + ... + f[i - <span class="hljs-number">1</span>][j - s * i]<br><span class="hljs-comment">// 得到 f[i][j] = f[i - 1][j] + f[i][j - i]</span><br><span class="hljs-comment">// f[j] = f[j] + f[j - i]</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="数位统计类dp">5.数位统计类DP</h3><p>​ <strong>描述：</strong></p><blockquote><p><strong>记数问题：</strong><code>AcWing.338</code></p><p>​ 分情况讨论！</p><p>​ [a, b], 0 ~ 9</p><p>​ 实现一个count(n, x), 返回1 ~ n当中 x 出现的次数</p><p>​ [a, b] 当中x出现的次数 = count(b, x) - count(a - 1, x);</p><p>求出前n个数的<code>0~9</code>数字出现总个数采用前缀和处理任意一个[a,b]区间内把某一个数字出现的个数</p><figure><img src="/img/learning/acwing/basic_algorithm/数位统计DP计数问题.png"alt="数位统计DP计数问题" /><figcaption aria-hidden="true">数位统计DP计数问题</figcaption></figure></blockquote><h3 id="状态压缩dp">6.状态压缩DP</h3><p>​ <strong>描述：</strong></p><blockquote><p><strong>蒙德里安的梦想：</strong><code>AcWing.291</code></p><figure><imgsrc="/img/learning/acwing/basic_algorithm/状态压缩DP蒙德里安的梦想2.png"alt="状态压缩DP蒙德里安的梦想2" /><figcaption aria-hidden="true">状态压缩DP蒙德里安的梦想2</figcaption></figure><p>​ <strong>动态规划：</strong></p><p>​ -状态表示：f[i,j]表示已经将前i-1列摆好，且从第i-1列伸出到第i列状态是j的所有方案数（j是一个二进制数）</p><p>​ -状态计算：因为前i-1列都是已经摆好的所以，由f[i-1,k]来计算f[i,j]，k表示当前所有从i-2伸出来到i-1的合法的方案，然后再继续判断记录当前状态j的所有合法方案</p><p><strong>最短Hamilton路径：</strong><code>AcWing.91</code></p><p>用一个<strong>整数</strong>表示状态，<strong>整数可以拆分成二进制表达方式</strong>，因此可以表示31个点的状态</p><figure><imgsrc="/img/learning/acwing/basic_algorithm/状态压缩DP最短Hamilton路径.png"alt="状态压缩DP最短Hamilton路径" /><figcaption aria-hidden="true">状态压缩DP最短Hamilton路径</figcaption></figure></blockquote><h3 id="树形dp">7.树形DP</h3><p>​ <strong>描述：</strong></p><blockquote><p><strong>没有上司的舞会：</strong><code>AcWing.285</code></p><figure><img src="/img/learning/acwing/basic_algorithm/树形DP没有上司的舞会.png"alt="树形DP没有上司的舞会" /><figcaption aria-hidden="true">树形DP没有上司的舞会</figcaption></figure><p>状态计算：</p><figure><imgsrc="/img/learning/acwing/basic_algorithm/树形DP没有上司的舞会状态计算.png"alt="树形DP没有上司的舞会状态计算" /><figcaption aria-hidden="true">树形DP没有上司的舞会状态计算</figcaption></figure></blockquote><h3 id="记忆化搜索">8.记忆化搜索</h3><p>​ <strong>描述：</strong></p><blockquote><p><strong>滑雪：</strong><code>AcWing.901</code></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>acwing</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>acwing</tag>
      
      <tag>学习</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
