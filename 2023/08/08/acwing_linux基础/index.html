

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Andy">
  <meta name="keywords" content="">
  
    <meta name="description" content="郑重声明： 注意本文章所有内容都是在acwing网站学习记录需要请前往acwing网站学习获取  链接：https:&#x2F;&#x2F;www.acwing.com 来源：AcWing 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。  Linux基础 1.常用文件管理命令 ​ 描述：多敲多敲多敲 linux文件结构：&#x2F;(根目录) -&gt; home | bin | va">
<meta property="og:type" content="article">
<meta property="og:title" content="acwing_linux基础">
<meta property="og:url" content="https://example.com/2023/08/08/acwing_linux%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Andyのblog">
<meta property="og:description" content="郑重声明： 注意本文章所有内容都是在acwing网站学习记录需要请前往acwing网站学习获取  链接：https:&#x2F;&#x2F;www.acwing.com 来源：AcWing 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。  Linux基础 1.常用文件管理命令 ​ 描述：多敲多敲多敲 linux文件结构：&#x2F;(根目录) -&gt; home | bin | va">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://example.com/img/bg/mygirl.jpg">
<meta property="article:published_time" content="2023-08-08T11:23:00.000Z">
<meta property="article:modified_time" content="2023-12-15T11:31:25.481Z">
<meta property="article:author" content="Andy">
<meta property="article:tag" content="acwing">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="工程">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://example.com/img/bg/mygirl.jpg">
  
  
  
  <title>acwing_linux基础 - Andyのblog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.5-a","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Andyのblog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/bg/mygirl.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="acwing_linux基础"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-08-08 19:23" pubdate>
          2023年8月8日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          35k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          292 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">acwing_linux基础</h1>
            
            
              <div class="markdown-body">
                
                <p>郑重声明：</p>
<p>注意本文章所有内容都是在acwing网站学习记录需要请前往acwing网站学习获取</p>
<ul>
<li>链接：https://www.acwing.com</li>
<li>来源：AcWing</li>
<li>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</li>
</ul>
<h1 id="linux基础">Linux基础</h1>
<h2 id="常用文件管理命令">1.常用文件管理命令</h2>
<p>​ <strong>描述：</strong>多敲多敲多敲</p>
<p>linux文件结构：/(根目录) -&gt; home | bin | var | lib | proc | etc |
root and so on...</p>
<blockquote>
<p>根目录 -&gt; /</p>
<p>家目录 -&gt; /home/xxx (xxx -&gt; 当前用户名)</p>
<p>绝对路径：从根目录开始描述的路径 -&gt; 开头是/</p>
<p>相对路径：从当前目录开始描述的路径 -&gt; 开头不是/</p>
</blockquote>
<blockquote>
<p>常见操作：</p>
<p>.. -&gt; 上一级目录</p>
<p>. -&gt; 当前目录</p>
<p>~/ -&gt; 家目录</p>
</blockquote>
<blockquote>
<p>常用命令介绍：</p>
<ol type="1">
<li><p>ctrl c: 取消命令，并且换行</p></li>
<li><p>ctrl u: 清空本行命令</p></li>
<li><p>tab键：可以补全命令和文件名，如果补全不了快速按两下tab键，可以显示备选选项</p></li>
<li><p>ls:
列出当前目录下所有文件，蓝色的是文件夹，白色的是普通文件，绿色的是可执行文件</p></li>
<li><p>pwd: 显示当前路径</p></li>
<li><p>cd XXX: 进入XXX目录下, cd .. 返回上层目录</p>
<p>cd . cd .. cd 等等</p></li>
<li><p>cp XXX YYY: （复制+粘贴+重命名
<code>将一个文件复制一份到另一个地方，原来那个地方文件还有</code>）将XXX文件复制成YYY，XXX和YYY可以是一个路径，比如../dir_c/a.txt，表示上层目录下的dir_c文件夹下的文件a.txt</p>
<p>cp a/tmp.txt b/ cp a/tmp.txt b/tmp2.txt cp a b -r 等等</p></li>
<li><p>mkdir XXX: 创建目录XXX</p></li>
<li><p>rm XXX: 删除普通文件; rm XXX -r: 删除文件夹</p></li>
<li><p>mv XXX YYY: （剪切 + 重命名
<code>将一个文件移动到另一个地方，原来那个地方文件没了</code>）将XXX文件移动到YYY，和cp命令一样
，XXX和YYY可以是一个路径；重命名也是用这个命令</p></li>
<li><p>touch XXX: 创建一个文件</p></li>
<li><p>cat XXX: 展示文件XXX中的内容</p></li>
<li><p>复制文本 windows/Linux下：Ctrl + insert，Mac下：command +
c</p></li>
<li><p>粘贴文本 windows/Linux下：Shift + insert，Mac下：command +
v</p></li>
</ol>
</blockquote>
<h2 id="tmux和vim">2.tmux和vim</h2>
<p>​ <strong>描述：</strong>多敲多敲多敲</p>
<p>tmux可以开很多的session（session1， session2， ... ），
每一个session可以包含很多的window（window1， window2， window3，... ），
每一个window可以开很多的pane（pane1， pane2， pane3，
...），每一个pane都会打开一个shell对话框</p>
<figure>
<img src="/img/learning/acwing/linux_basic/2.tmux和vim/1.tmux结构.png" srcset="/img/loading.gif" lazyload
alt="1.tmux结构" />
<figcaption aria-hidden="true">1.tmux结构</figcaption>
</figure>
<blockquote>
<p><strong>1.tmux教程</strong> <strong>功能：</strong> (1) 分屏。 (2)
允许断开Terminal连接后，继续运行进程。 <strong>结构：</strong>
一个tmux可以包含多个session，一个session可以包含多个window，一个window可以包含多个pane。
实例： tmux: session 0: window 0: pane 0 pane 1 pane 2 ... window 1
window 2 ... session 1 session 2 ... <strong>操作：</strong> (1)
tmux：新建一个session，其中包含一个window，window中包含一个pane，pane里打开了一个shell对话框。
(2) 按下Ctrl + a后手指松开，然后按%：将当前pane左右平分成两个pane。 (3)
按下Ctrl + a后手指松开，然后按"：将当前pane上下平分成两个pane。 (4) Ctrl
+
d：关闭当前pane；如果当前window的所有pane均已关闭，则自动关闭window；如果当前session的所有window均已关闭，则自动关闭session。
(5) 鼠标点击可以选pane。 (6) 按下ctrl +
a后手指松开，然后按方向键：选择相邻的pane。 (7)
鼠标拖动pane之间的分割线，可以调整分割线的位置。 (8) 按住ctrl +
a的同时按方向键，可以调整pane之间分割线的位置。 (9) 按下ctrl +
a后手指松开，然后按z：将当前pane全屏/取消全屏。 (10) 按下ctrl +
a后手指松开，然后按d：挂起当前session。 (11) tmux
a：打开之前挂起的session。 (12) 按下ctrl +
a后手指松开，然后按s：选择其它session。 方向键 —— 上：选择上一项
session/window/pane 方向键 —— 下：选择下一项 session/window/pane 方向键
—— 右：展开当前项 session/window 方向键 —— 左：闭合当前项 session/window
(13) 按下Ctrl +
a后手指松开，然后按c：在当前session中创建一个新的window。 (14) 按下Ctrl
+ a后手指松开，然后按w：选择其他window，操作方法与(12)完全相同。 (15)
按下Ctrl + a后手指松开，然后按PageUp：翻阅当前pane内的内容。 (16)
鼠标滚轮：翻阅当前pane内的内容。 (17)
在tmux中选中文本时，需要按住shift键。（仅支持Windows和Linux，不支持Mac，不过该操作并不是必须的，因此影响不大）
(18) tmux中复制/粘贴文本的通用方式： (1) 按下Ctrl + a后松开手指，然后按[
(2) 用鼠标选中文本，被选中的文本会被自动复制到tmux的剪贴板 (3) 按下Ctrl
+ a后松开手指，然后按]，会将剪贴板中的内容粘贴到光标处</p>
<p><strong>2.vim教程</strong> <strong>功能：</strong> (1)
命令行模式下的文本编辑器。 (2)
根据文件扩展名自动判别编程语言。支持代码缩进、代码高亮等功能。 (3)
使用方式：vim filename 如果已有该文件，则打开它。
如果没有该文件，则打开个一个新的文件，并命名为filename
<strong>模式：</strong> (1) 一般命令模式
默认模式。命令输入方式：类似于打游戏放技能，按不同字符，即可进行不同操作。可以复制、粘贴、删除文本等。
(2) 编辑模式 在一般命令模式里按下i，会进入编辑模式。
按下ESC会退出编辑模式，返回到一般命令模式。 (3) 命令行模式
在一般命令模式里按下:/?三个字母中的任意一个，会进入命令行模式。命令行在最下面。
可以查找、替换、保存、退出、配置编辑器等。 <strong>操作：</strong> (1)
i：进入编辑模式 (2) ESC：进入一般命令模式 (3) h 或
左箭头键：光标向左移动一个字符 (4) j 或 向下箭头：光标向下移动一个字符
(5) k 或 向上箭头：光标向上移动一个字符 (6) l 或
向右箭头：光标向右移动一个字符 (7)
n&lt;Space&gt;：n表示数字，按下数字后再按空格，光标会向右移动这一行的n个字符
(8) 0 或 功能键[Home]：光标移动到本行开头 (9) $ 或
功能键[End]：光标移动到本行末尾 (10) G：光标移动到最后一行 (11) :n 或
nG：n为数字，光标移动到第n行 (12) gg：光标移动到第一行，相当于1G (13)
n&lt;Enter&gt;：n为数字，光标向下移动n行 (14)
/word：向光标之下寻找第一个值为word的字符串。 (15)
?word：向光标之上寻找第一个值为word的字符串。 (16) n：重复前一个查找操作
(17) N：反向重复前一个查找操作 (18)
:n1,n2s/word1/word2/g：n1与n2为数字，在第n1行与n2行之间寻找word1这个字符串，并将该字符串替换为word2
(19) :1,$s/word1/word2/g：将全文的word1替换为word2 (20)
:1,$s/word1/word2/gc：将全文的word1替换为word2，且在替换前要求用户确认。
(21) v：选中文本<br />
(22) d：删除选中的文本 (23) dd: 删除当前行 (24) y：复制选中的文本 (25)
yy: 复制当前行 (26) p: 将复制的数据在光标的下一行/下一个位置粘贴 (27)
u：撤销 (28) Ctrl + r：取消撤销 (29) 大于号
&gt;：将选中的文本整体向右缩进一次 (30) 小于号
&lt;：将选中的文本整体向左缩进一次 (31) :w 保存 (32) :w! 强制保存 (33)
:q 退出 (34) :q! 强制退出 (35) :wq 保存并退出 (36) :set paste
设置成粘贴模式，取消代码自动缩进 (37) :set nopaste
取消粘贴模式，开启代码自动缩进 (38) :set nu 显示行号 (39) :set nonu
隐藏行号 (40) gg=G：将全文代码格式化 (41) :noh 关闭查找关键词高亮 (42)
Ctrl + q：当vim卡死时，可以取消当前正在执行的命令
<strong>异常处理：</strong>
每次用vim编辑文件时，会自动创建一个.filename.swp的临时文件。
如果打开某个文件时，该文件的swp文件已存在，则会报错。此时解决办法有两种：
(1) 找到正在打开该文件的程序，并退出 (2) 直接删掉该swp文件即可</p>
</blockquote>
<h2 id="shell语法">3.shell语法</h2>
<p>​ <strong>描述：</strong>多敲多敲多敲！</p>
<h3 id="概论">1.概论：</h3>
<blockquote>
<p>shell是我们通过命令行与操作系统沟通的<strong>语言</strong>，跟我们正常学习的C/C++类似就是一个交互语言。</p>
<p>shell脚本可以直接在命令行中执行，也可以将一套逻辑组织成<strong>一个文件</strong>，方便复用。
AC Terminal中的命令行可以看成是一个“shell脚本在逐行执行”。</p>
<p>Linux中常见的shell脚本有很多种，常见的有：</p>
<ul>
<li>Bourne Shell(/usr/bin/sh或/bin/sh)</li>
<li><font color='blue'>Bourne Again Shell(/bin/bash)</font></li>
<li>C Shell(/usr/bin/csh)</li>
<li>K Shell(/usr/bin/ksh)</li>
<li>zsh</li>
<li>…</li>
</ul>
<p>Linux系统中一般默认使用bash，所以接下来讲解bash中的语法。</p>
<p><strong>文件开头需要写#!
/bin/bash，指明bash为脚本解释器。</strong></p>
<hr />
<p><strong>学习技巧</strong></p>
<p>不要死记硬背，遇到含糊不清的地方，可以在 <code>Terminal</code>
里实际运行一遍。</p>
<p><strong>脚本示例</strong></p>
<p>新建一个 <code>test.sh</code> 文件，内容如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">! /bin/bash</span><br>echo &quot;Hello World!&quot;<br></code></pre></td></tr></table></figure>
<hr />
<p><strong>运行方式</strong></p>
<p>作为可执行文件 -&gt; <strong>需要权限</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">acs@9e0ebfcd82d7:~\$ chmod +x test.sh  # 使脚本具有可执行权限<br>acs@9e0ebfcd82d7:~\$ ./test.sh  # 当前路径下执行<br>Hello World!  # 脚本输出<br>acs@9e0ebfcd82d7:~$ /home/acs/test.sh  # 绝对路径下执行<br>Hello World!  # 脚本输出<br>acs@9e0ebfcd82d7:~$ ~/test.sh  # 家目录路径下执行<br>Hello World!  # 脚本输出<br></code></pre></td></tr></table></figure>
<p>用解释器执行 -&gt; <strong>无需权限</strong></p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">acs<span class="hljs-variable">@9e0ebfcd82d7</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>bash test.sh<br><span class="hljs-title class_">Hello</span> <span class="hljs-title class_">World</span>!  <span class="hljs-comment"># 脚本输出</span><br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="注释">2.注释:</h3>
<blockquote>
<p>单行注释 每行中 <code>#</code> 之后的内容均是注释。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">这是一行注释</span><br><br>echo &#x27;Hello World&#x27;  #  这也是注释	<br></code></pre></td></tr></table></figure>
<hr />
<p><strong>多行注释:</strong></p>
<p>格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">:&lt;&lt;EOF<br>第一行注释<br>第二行注释<br>第三行注释<br>EOF<br></code></pre></td></tr></table></figure>
<p>其中 <code>EOF</code> 可以换成其它任意字符串。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">:&lt;&lt;abc<br>第一行注释<br>第二行注释<br>第三行注释<br>abc<br><br>:&lt;&lt;!<br>第一行注释<br>第二行注释<br>第三行注释<br>!<br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="变量">3.变量：</h3>
<blockquote>
<p>定义变量 定义变量，不需要加 <code>$</code> 符号，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">name1=&#x27;yxc&#x27;  # 单引号定义字符串<br>name2=&quot;yxc&quot;  # 双引号定义字符串<br>name3=yxc    # 也可以不加引号，同样表示字符串<br></code></pre></td></tr></table></figure>
<hr />
<p><strong>使用变量:</strong></p>
<p>使用变量，需要加上 <code>$</code> 符号，或者 <code>$&#123;&#125;</code>
符号。花括号是可选的，主要为了帮助解释器识别变量边界。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">name=yxc<br>echo $name  # 输出yxc<br>echo $&#123;name&#125;  # 输出yxc<br>echo $&#123;name&#125;acwing  # 输出yxcacwing<br>echo $&#123;name&#125;’s acwing is such a good website to learn having fun # 输出 yxc acwing is such a good website to learn having fun<br></code></pre></td></tr></table></figure>
<hr />
<p><strong>只读变量:</strong></p>
<p>使用 <code>readonly</code> 或者 <code>declare</code>
可以将变量变为只读。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">name=yxc<br>readonly name<br>declare -r name  # 两种写法均可<br><br>name=abc  # 会报错，因为此时name只读<br></code></pre></td></tr></table></figure>
<hr />
<p><strong>删除变量:</strong></p>
<p><code>unset</code> 可以删除变量。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">name=yxc<br>unset name<br>echo $name  # 输出空行<br></code></pre></td></tr></table></figure>
<hr />
<p><strong>变量类型:</strong></p>
<ol type="1">
<li><p>自定义变量（局部变量）</p>
<p>子进程不能访问的变量</p></li>
<li><p>环境变量（全局变量）</p>
<p>子进程可以访问的变量</p></li>
</ol>
<p>自定义变量改成环境变量：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">acs@9e0ebfcd82d7:~$ name=yxc  # 定义变量<br>acs@9e0ebfcd82d7:~$ export name  # 第一种方法<br>acs@9e0ebfcd82d7:~$ declare -x name  # 第二种方法<br></code></pre></td></tr></table></figure>
<p>环境变量改为自定义变量：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">acs@9e0ebfcd82d7:~$ export name=yxc  # 定义环境变量<br>acs@9e0ebfcd82d7:~$ declare +x name  # 改为自定义变量<br></code></pre></td></tr></table></figure>
<hr />
<p><strong>字符串</strong></p>
<p>字符串可以用单引号，也可以用双引号，也可以不用引号。</p>
<p>单引号与双引号的区别：</p>
<ul>
<li>单引号中的内容会原样输出，不会执行、不会取变量；</li>
<li>双引号中的内容可以执行、可以取变量；</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">name=yxc  # 不用引号<br>echo &#x27;hello, $name \&quot;hh\&quot;&#x27;  # 单引号字符串，输出 hello, $name \&quot;hh\&quot;<br>echo &quot;hello, $name \&quot;hh\&quot;&quot;  # 双引号字符串，输出 hello, yxc &quot;hh&quot;<br></code></pre></td></tr></table></figure>
<p>获取字符串长度</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">name=&quot;yxc&quot;<br>echo $&#123;#name&#125;  # 输出3<br></code></pre></td></tr></table></figure>
<p>提取子串</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">name=&quot;hello, yxc&quot;<br>echo $&#123;name:0:5&#125;  # 提取从0开始的5个字符<br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="默认变量">4.默认变量：</h3>
<p>​ <strong>描述：</strong></p>
<blockquote>
<p>文件参数变量 在执行shell脚本时，可以向脚本传递参数。<code>$1</code>
是第一个参数，<code>$2</code>是第二个参数，以此类推。特殊的，<code>$0</code>
是文件名（包含路径）。例如：</p>
<p>创建文件 <code>test.sh</code> ：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs SHELL"><span class="hljs-meta prompt_">#</span><span class="language-bash">! /bin/bash</span><br><br>echo &quot;文件名：&quot;$0<br>echo &quot;第一个参数：&quot;$1<br>echo &quot;第二个参数：&quot;$2<br>echo &quot;第三个参数：&quot;$3<br>echo &quot;第四个参数：&quot;$4<br></code></pre></td></tr></table></figure>
<p>然后执行脚本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">acs@9e0ebfcd82d7:~$ chmod +x test.sh <br>acs@9e0ebfcd82d7:~$ ./test.sh 1 2 3 4<br>文件名：./test.sh<br>第一个参数：1<br>第二个参数：2<br>第三个参数：3<br>第四个参数：4<br></code></pre></td></tr></table></figure>
<hr />
<p><strong>其他参数相关变量</strong></p>
<table>

<thead>
<tr class="header">
<th><strong>参数</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>$#</code></td>
<td>代表文件传入的参数个数，如上例中值为4</td>
</tr>
<tr class="even">
<td><code>$*</code></td>
<td>由所有参数构成的用空格隔开的字符串，如上例中值为<code>"$1 $2 $3 $4"</code></td>
</tr>
<tr class="odd">
<td><code>$@</code></td>
<td>每个参数分别用双引号括起来的字符串，如上例中值为<code>"$1" "$2" "$3" "$4"</code></td>
</tr>
<tr class="even">
<td><code>$$</code></td>
<td>脚本当前运行的进程ID</td>
</tr>
<tr class="odd">
<td><code>$?</code></td>
<td>上一条命令的退出状态（注意不是stdout，而是exit
code）。0表示正常退出，其他值表示错误</td>
</tr>
<tr class="even">
<td><code>$(command)</code></td>
<td>返回<code>command</code>这条命令的stdout（可嵌套）</td>
</tr>
<tr class="odd">
<td>`command`</td>
<td>返回<code>command</code>这条命令的stdout（不可嵌套）</td>
</tr>
</tbody>
</table>
</blockquote>
<h3 id="数组">5.数组</h3>
<p>​ <strong>描述：</strong></p>
<blockquote>
<p>数组中可以存放多个不同类型的值，只支持一维数组，初始化时不需要指明数组大小。
数组<strong>下标从0开始</strong>。</p>
<p><strong>特殊：</strong>shell语法中的数组支持开放指定位置i的数组内容的，实际数组大小不是最大下标而是当前数组用了多少个下标的内容就是多少</p>
<hr />
<p><strong>定义：</strong></p>
<p>数组用小括号表示，元素之间空格隔开。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">array=(1 abc &quot;def&quot; yxc)<br></code></pre></td></tr></table></figure>
<p>也可以直接定义数组中的某个元素的值：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">array[0]=1<br>array[1]=abc<br>array[2]=&quot;def&quot;<br>array[3]=yxc<br></code></pre></td></tr></table></figure>
<hr />
<p><strong>读取数组中某个元素的值</strong></p>
<p>格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;array[index]&#125;</span><br></code></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">array=(1 abc &quot;def&quot; yxc)<br>echo $&#123;array[0]&#125; # 输出数组中单独一个元素的值<br>echo $&#123;array[1]&#125;<br>echo $&#123;array[2]&#125;<br>echo $&#123;array[3]&#125;<br></code></pre></td></tr></table></figure>
<hr />
<p><strong>读取整个数组</strong></p>
<p>格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;array[@]&#125;  <span class="hljs-comment"># 第一种写法 将数组中所有的值输出到一行</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;array[*]&#125;  <span class="hljs-comment"># 第二种写法 将数组中所有的值输出到一行</span></span><br></code></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">array=(1 abc &quot;def&quot; yxc)<br><br>echo $&#123;array[@]&#125;  # 第一种写法<br>echo $&#123;array[*]&#125;  # 第二种写法<br></code></pre></td></tr></table></figure>
<hr />
<p><strong>数组长度</strong></p>
<p>类似于字符串</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;<span class="hljs-comment">#array[@]&#125;  # 第一种写法 输出的是数组中元素的个数</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;<span class="hljs-comment">#array[*]&#125;  # 第二种写法 输出的是数组中元素的个数</span></span><br></code></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">array=(1 abc &quot;def&quot; yxc)<br><br>echo $&#123;#array[@]&#125;  # 第一种写法<br>echo $&#123;#array[*]&#125;  # 第二种写法<br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="expr命令">6.expr命令</h3>
<p>​ <strong>描述：</strong>其实是第三方实现的: 命令窗输入
<code>type expr</code> 输出 <code>expr is /usr/bin/expr</code></p>
<blockquote>
<p><code>expr</code>命令用于求表达式的值，格式为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">expr 表达式<br></code></pre></td></tr></table></figure>
<p>表达式说明：</p>
<ul>
<li>用空格隔开每一项</li>
<li>用反斜杠放在<code>shell</code>特定的字符前面（发现表达式运行错误时，可以试试转义）</li>
<li>对包含空格和其他特殊字符的字符串要用引号括起来</li>
<li><code>expr</code>会在<code>stdout</code>中输出结果。如果为逻辑关系表达式，则结果为真时，<code>stdout</code>输出<code>1</code>，否则输出<code>0</code>。</li>
<li><code>expr</code>的<code>exit code</code>：如果为逻辑关系表达式，则结果为真时，<code>exit code</code>为<code>0</code>，否则为<code>1</code>。</li>
</ul>
<hr />
<p><strong>字符串表达式</strong></p>
<ul>
<li><p><code>length STRING</code></p>
<p>返回<code>STRING</code>的长度</p></li>
<li><p><code>index STRING CHARSET</code></p>
<p><code>CHARSET</code>中任意单个字符在<code>STRING</code>中最前面的字符位置，<strong>下标从1开始</strong>。如果在<code>STRING</code>中完全不存在<code>CHARSET</code>中的字符，则返回0。</p></li>
<li><p><code>substr STRING POSITION LENGTH</code></p>
<p>返回<code>STRING</code>字符串中从<code>POSITION</code>开始，长度最大为<code>LENGTH</code>的子串。如果<code>POSITION</code>或<code>LENGTH</code>为负数，0或非数值，则返回空字符串。</p></li>
</ul>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">str=&quot;Hello World!&quot;<br><br>echo `expr length &quot;$str&quot;`  # ``不是单引号，表示执行该命令，输出12<br>echo `expr index &quot;$str&quot; aWd`  # 输出7，下标从1开始<br>echo `expr substr &quot;$str&quot; 2 3`  # 输出 ell<br></code></pre></td></tr></table></figure>
<hr />
<p><strong>整数表达式</strong></p>
<p><code>expr</code>支持普通的算数运算，算术表达式优先级低于字符串表达式，高于逻辑表达式</p>
<ul>
<li><p><code>+ -</code>
加减运算。两端参数会转换为整数，如果转换失败则报错。</p></li>
<li><p><code>/ %</code>
乘，除，取模运算。两端参数会转换为整数，如果转换失败则报错。</p></li>
<li><p><code>()</code>可以改变优先级，但需要用反斜杠转义</p></li>
</ul>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">a=3<br>b=4<br><br>echo `expr $a + $b`  # 输出7<br>echo `expr $a - $b`  # 输出-1<br>echo `expr $a \* $b`  # 输出12，*需要转义<br>echo `expr $a / $b`  # 输出0，整除<br>echo `expr $a % $b` # 输出3<br>echo `expr \( $a + 1 \) \* \( $b + 1 \)`  # 输出20，值为(a + 1) * (b + 1)<br></code></pre></td></tr></table></figure>
<hr />
<p><strong>逻辑表达式</strong></p>
<ul>
<li><p><code>|</code></p></li>
<li><p>如果第一个参数非空且非0，则返回第一个参数的值，否则返回第二个参数的值，但要求第二个参数的值也是非空或非0，否则返回0。如果第一个参数是非空或非0时，不会计算第二个参数。</p></li>
<li><p><code>&amp;</code></p></li>
<li><p>如果两个参数都非空且非0，则返回第一个参数，否则返回0。如果第一个参为0或为空，则不会计算第二个参数。</p></li>
<li><p><code>&lt; &lt;= = == != &gt;= &gt;</code></p></li>
<li><p>比较两端的参数，如果为true，则返回1，否则返回0。”==”是”=”的同义词。”expr”首先尝试将两端参数转换为整数，并做算术比较，如果转换失败，则按字符集排序规则做字符比较。</p></li>
<li><p><code>()</code> 可以改变优先级，但需要用反斜杠转义</p></li>
</ul>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">a=3<br>b=4<br><br>echo `expr $a \&gt; $b`  # 输出0，&gt;需要转义<br>echo `expr $a &#x27;&lt;&#x27; $b`  # 输出1，也可以将特殊字符用引号引起来<br>echo `expr $a &#x27;&gt;=&#x27; $b`  # 输出0<br>echo `expr $a \&lt;\= $b`  # 输出1<br><br>c=0<br>d=5<br><br>echo `expr $c \&amp; $d`  # 输出0<br>echo `expr $a \&amp; $b`  # 输出3<br>echo `expr $c \| $d`  # 输出5<br>echo `expr $a \| $b`  # 输出3<br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="read命令">7.read命令</h3>
<p>​ <strong>描述：</strong></p>
<blockquote>
<p><code>read</code>命令用于从标准输入中读取单行数据。当读到文件结束符时，<code>exit code</code>为1，否则为0。</p>
<p>参数说明</p>
<ul>
<li><code>-p</code>: 后面可以接提示信息</li>
<li><code>-t</code>：后面跟秒数，定义输入字符的等待时间，超过等待时间后会自动忽略此命令</li>
</ul>
<p>实例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs SHELL">acs@9e0ebfcd82d7:~$ read name  # 读入name的值<br>acwing yxc  # 标准输入<br>acs@9e0ebfcd82d7:~$ echo $name  # 输出name的值<br>acwing yxc  #标准输出<br>acs@9e0ebfcd82d7:~$ read -p &quot;Please input your name: &quot; -t 30 name  # 读入name的值，等待时间30秒<br>Please input your name: acwing yxc  # 标准输入<br>acs@9e0ebfcd82d7:~$ echo $name  # 输出name的值<br>acwing yxc  # 标准输出<br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="echo命令">8.echo命令</h3>
<p>​ <strong>描述：</strong></p>
<blockquote>
<p><code>echo</code>用于输出字符串。命令格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo STRING<br></code></pre></td></tr></table></figure>
<hr />
<p><strong>显示普通的字符串</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &quot;Hello AC Terminal&quot;<br>echo Hello AC Terminal  # 引号可以省略<br></code></pre></td></tr></table></figure>
<hr />
<p><strong>显示转义字符</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &quot;\&quot;Hello AC Terminal\&quot;&quot;  # 注意只能使用双引号，如果使用单引号，则不转义<br>echo \&quot;Hello AC Terminal\&quot;  # 也可以省略双引号<br></code></pre></td></tr></table></figure>
<hr />
<p><strong>显示变量</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">name=yxc<br>echo &quot;My name is $name&quot;  # 输出 My name is yxc<br></code></pre></td></tr></table></figure>
<hr />
<p><strong>显示换行</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo -e &quot;Hi\n&quot;  # -e 开启转义<br>echo &quot;acwing&quot;<br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">Hi<br><br>acwing<br></code></pre></td></tr></table></figure>
<hr />
<p><strong>显示不换行</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo -e &quot;Hi \c&quot; # -e 开启转义 \c 不换行<br>echo &quot;acwing&quot;<br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Hi acwing<br></code></pre></td></tr></table></figure>
<hr />
<p><strong>显示结果定向至文件</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &quot;Hello World&quot; &gt; output.txt  # 将内容以覆盖的方式输出到output.txt中<br></code></pre></td></tr></table></figure>
<hr />
<p><strong>原样输出字符串，不进行转义或取变量（用单引号）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell'">name=acwing<br>echo &#x27;$name\&quot;&#x27;<br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">name\&quot;</span><br></code></pre></td></tr></table></figure>
<hr />
<p><strong>显示命令的执行结果</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo `date`<br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Wed Sep 1 11:45:33 CST 2021<br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="printf命令">9.printf命令</h3>
<p>​ <strong>描述：</strong></p>
<blockquote>
<p><code>printf</code>命令用于格式化输出，类似于<code>C/C++</code>的<code>printf</code>函数</p>
<p>默认<strong>不会在字符串末尾添加换行符</strong></p>
<p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">printf format-string [arguments...]<br></code></pre></td></tr></table></figure>
<hr />
<p><strong>用法示例</strong></p>
<p>脚本内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">printf &quot;%10d.\n&quot; 123  # 占10位，右对齐<br>printf &quot;%-10.2f.\n&quot; 123.123321  # 占10位，保留2位小数，左对齐<br>printf &quot;My name is %s\n&quot; &quot;yxc&quot;  # 格式化输出字符串<br>printf &quot;%d * %d = %d\n&quot;  2 3 `expr 2 \* 3` # 表达式的值作为参数<br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">    123.<br>123.12    .<br>My name is yxc<br>2 * 3 = 6<br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="test命令与判断符号">10.test命令与判断符号[]</h3>
<p>​ <strong>描述：</strong></p>
<blockquote>
<p><strong>逻辑运算符&amp;&amp;和||</strong></p>
<ul>
<li><code>&amp;&amp;</code> 表示与，<code>||</code> 表示或</li>
<li>二者具有短路原则：
<code>expr1 &amp;&amp; expr2</code>：当<code>expr1</code>为假时，直接忽略<code>expr2</code>
<code>expr1 || expr2</code>：当<code>expr1</code>为真时，直接忽略<code>expr2</code></li>
<li>表达式的<code>exit code</code>为0，表示真；为非零，表示假。（与C/C++中的定义相反）</li>
</ul>
<hr />
<p><strong>test命令</strong></p>
<p>在命令行中输入<code>man test</code>，可以查看<code>test</code>命令的用法。</p>
<ul>
<li><p><code>test</code>命令用于判断文件类型，以及对变量做比较。</p></li>
<li><p><code>test</code>命令用<code>exit code</code>返回结果，而不是使用<code>stdout</code>。0表示真，非0表示假。</p></li>
</ul>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">test 2 -lt 3  # 为真，返回值为0<br>echo $?  # 输出上个命令的返回值，输出0<br></code></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">acs@9e0ebfcd82d7:~$ ls  # 列出当前目录下的所有文件<br>homework  output.txt  test.sh  tmp<br>acs@9e0ebfcd82d7:~$ test -e test.sh &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;<br>exist  # test.sh 文件存在<br>acs@9e0ebfcd82d7:~$ test -e test2.sh &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;<br>Not exist  # testh2.sh 文件不存在<br></code></pre></td></tr></table></figure>
<hr />
<p><strong>文件类型判断</strong></p>
<p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">test -e filename  # 判断文件是否存在<br></code></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th><strong>测试参数</strong></th>
<th><strong>代表意义</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-e</td>
<td>文件是否存在</td>
</tr>
<tr class="even">
<td>-f</td>
<td>是否为(普通)文件</td>
</tr>
<tr class="odd">
<td>-d</td>
<td>是否为目录</td>
</tr>
</tbody>
</table>
<hr />
<p><strong>文件权限判断</strong></p>
<p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">test -r filename  # 判断文件是否可读<br></code></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th><strong>测试参数</strong></th>
<th><strong>代表意义</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-r</td>
<td>文件是否可读</td>
</tr>
<tr class="even">
<td>-w</td>
<td>文件是否可写</td>
</tr>
<tr class="odd">
<td>-x</td>
<td>文件是否可执行</td>
</tr>
<tr class="even">
<td>-s</td>
<td>是否为非空文件</td>
</tr>
</tbody>
</table>
<hr />
<p><strong>整数间的比较</strong></p>
<p>命令比较：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">test $a -eq $b  # a是否等于b<br></code></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th><strong>测试参数</strong></th>
<th><strong>代表意义</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-eq</td>
<td>a是否等于b</td>
</tr>
<tr class="even">
<td>-ne</td>
<td>a是否不等于b</td>
</tr>
<tr class="odd">
<td>-gt</td>
<td>a是否大于b</td>
</tr>
<tr class="even">
<td>-lt</td>
<td>a是否小于b</td>
</tr>
<tr class="odd">
<td>-ge</td>
<td>a是否大于等于b</td>
</tr>
<tr class="even">
<td>-le</td>
<td>a是否小于等于b</td>
</tr>
</tbody>
</table>
<hr />
<p><strong>字符串比较</strong></p>
<table>

<thead>
<tr class="header">
<th><strong>测试参数</strong></th>
<th><strong>代表意义</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>test -z STRING</td>
<td>判断STRING是否为空，如果为空，则返回true</td>
</tr>
<tr class="even">
<td>test -n STRING</td>
<td>判断STRING是否非空，如果非空，则返回true（-n可以省略）</td>
</tr>
<tr class="odd">
<td>test str1 == str2</td>
<td>判断str1是否等于str2</td>
</tr>
<tr class="even">
<td>test str1 != str2</td>
<td>判断str1是否不等于str2</td>
</tr>
</tbody>
</table>
<hr />
<p><strong>多重条件判定</strong></p>
<p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">test -r filename -a -x filename<br></code></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th><strong>测试参数</strong></th>
<th><strong>代表意义</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-a</td>
<td>两条件是否同时成立</td>
</tr>
<tr class="even">
<td>-o</td>
<td>两条件是否至少一个成立</td>
</tr>
<tr class="odd">
<td>！</td>
<td>取反。如 test ! -x file，当file不可执行时，返回true</td>
</tr>
</tbody>
</table>
<hr />
<p><strong>判断符号[]</strong></p>
<p><code>[]</code>与<code>test</code>用法几乎一模一样，更常用于<code>if</code>语句中。另外<code>[[]]</code>是<code>[]</code>的加强版，支持的特性更多。</p>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[ 2 -lt 3 ]  # 为真，返回值为0<br>echo $?  # 输出上个命令的返回值，输出0<br></code></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">acs@9e0ebfcd82d7:~$ ls  # 列出当前目录下的所有文件<br>homework  output.txt  test.sh  tmp<br>acs@9e0ebfcd82d7:~$ [ -e test.sh ] &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;<br>exist  # test.sh 文件存在<br>acs@9e0ebfcd82d7:~$ [ -e test2.sh ] &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;<br>Not exist  # testh2.sh 文件不存在<br></code></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li><code>[]</code>内的每一项都要用空格隔开</li>
<li>中括号内的变量，最好用双引号括起来</li>
<li>中括号内的常数，最好用单或双引号括起来</li>
</ul>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">name=&quot;acwing yxc&quot;<br>[ $name == &quot;acwing yxc&quot; ]  # 错误，等价于 [ acwing yxc == &quot;acwing yxc&quot; ]，参数太多<br>[ &quot;$name&quot; == &quot;acwing yxc&quot; ]  # 正确<br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="判断语句">11.判断语句</h3>
<p>​ <strong>描述：</strong></p>
<blockquote>
<p><strong>if…then形式</strong>
类似于<code>C/C++</code>中的<code>if-else</code>语句。</p>
<hr />
<p><strong>单层if</strong></p>
<p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">if condition<br>then<br> 语句1<br> 语句2<br> ...<br>fi<br></code></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">a=3<br>b=4<br><br>if [ &quot;$a&quot; -lt &quot;$b&quot; ] &amp;&amp; [ &quot;$a&quot; -gt 2 ]<br>then<br> echo $&#123;a&#125;在范围内<br>fi<br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">3在范围内<br></code></pre></td></tr></table></figure>
<hr />
<p><strong>单层if-else</strong></p>
<p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">if condition<br>then<br> 语句1<br> 语句2<br> ...<br>else<br> 语句1<br> 语句2<br> ...<br>fi<br></code></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">a=3<br>b=4<br><br>if ! [ &quot;$a&quot; -lt &quot;$b&quot; ]<br>then<br> echo $&#123;a&#125;不小于$&#123;b&#125;<br>else<br> echo $&#123;a&#125;小于$&#123;b&#125;<br>fi<br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">3小于4<br></code></pre></td></tr></table></figure>
<hr />
<p><strong>多层if-elif-elif-else</strong></p>
<p>命令格式</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">if condition<br>then<br> 语句1<br> 语句2<br> ...<br>elif condition<br>then<br> 语句1<br> 语句2<br> ...<br>elif condition<br>then<br> 语句1<br> 语句2<br>else<br> 语句1<br> 语句2<br> ...<br>fi<br></code></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">a=4<br><br>if [ $a -eq 1 ]<br>then<br> echo $&#123;a&#125;等于1<br>elif [ $a -eq 2 ]<br>then<br> echo $&#123;a&#125;等于2<br>elif [ $a -eq 3 ]<br>then<br> echo $&#123;a&#125;等于3<br>else<br> echo 其他<br>fi<br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">其他<br></code></pre></td></tr></table></figure>
<hr />
<p><strong>case...esac形式</strong></p>
<p>类似于<code>C/C++</code>中的<code>switch</code>语句</p>
<p>命令格式</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">case $变量名称 in<br> 值1)<br>     语句1<br>     语句2<br>     ...<br>     ;;  # 类似于C/C++中的break<br> 值2)<br>     语句1<br>     语句2<br>     ...<br>     ;;<br> *)  # 类似于C/C++中的default<br>     语句1<br>     语句2<br>     ...<br>     ;;<br>esac<br></code></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">a=4<br><br>case $a in<br> 1)<br>     echo $&#123;a&#125;等于1<br>     ;;<br> 2)<br>     echo $&#123;a&#125;等于2<br>     ;;<br> 3)                                                <br> 	echo $&#123;a&#125;等于3<br> 	 ;;<br> *)<br>	echo 其他<br>	 ;;  s<br>esac<br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">其他<br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="循环语句">12.循环语句</h3>
<p>​ <strong>描述：</strong></p>
<blockquote>
<p><strong>for…in…do…done</strong></p>
<p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">for var in val1 val2 val3<br>do<br>语句1<br>语句2<br>...<br>done<br></code></pre></td></tr></table></figure>
<p>示例1，输出a 2 cc，每个元素一行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">for i in a 2 cc<br>do<br>echo $i<br>done<br></code></pre></td></tr></table></figure>
<p>示例2，输出当前路径下的所有文件名，每个文件名一行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">for file in `ls`<br>do<br>echo $file<br>done<br></code></pre></td></tr></table></figure>
<p>示例3，输出1-10</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">for i in $(seq 1 10)<br>do<br>echo $i<br>done<br></code></pre></td></tr></table></figure>
<p>示例4，使用<code>&#123;1...10&#125;</code>或者<code>&#123;a...z&#125;</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">for i in &#123;a..z&#125;<br>do<br>echo $i<br>done<br></code></pre></td></tr></table></figure>
<hr />
<p><strong>for ((…;…;…)) do…done</strong></p>
<p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">for ((expression; condition; expression))<br>do<br>语句1<br>语句2<br>done<br></code></pre></td></tr></table></figure>
<p>示例，输出1-10，每一个数占一行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">for (( i = 1; i &lt;= 10; i ++ ))<br>do<br>echo $i<br>done<br></code></pre></td></tr></table></figure>
<hr />
<p><strong>while...do...done循环</strong></p>
<p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">while condition<br>do<br>语句1<br>语句2<br>...<br>done<br></code></pre></td></tr></table></figure>
<p>示例，文件结束符<code>Ctrl+d</code>，输入文件结束符后<code>read</code>指令返回<code>false</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">while read name<br>do<br>echo $name<br>done<br></code></pre></td></tr></table></figure>
<hr />
<p><strong>until...do...done循环</strong></p>
<p>当条件为真时结束</p>
<p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">until condition<br>do<br>语句1<br>语句2<br>...<br>done<br></code></pre></td></tr></table></figure>
<p>示例，当用户输入<code>yes</code>或者<code>YES</code>时结束，否则一直等待读入</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">until [ &quot;$&#123;word&#125;&quot; == &quot;yes&quot; ] || [ &quot;$&#123;word&#125;&quot; == &quot;YES&quot; ]<br>do<br>read -p &quot;Please input yes/YES to stop this program: &quot; word<br>done<br></code></pre></td></tr></table></figure>
<hr />
<p><strong>break命令</strong></p>
<p>跳出当前一层循环，注意与<code>C/C++</code>不同的是：<code>break</code>不能跳出<code>case</code>语句。</p>
<p>示例</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">while read name<br>do<br>for (( i=1; i &lt;= 10; i++ ))<br>do<br>  case $i in<br>      8)<br>          break<br>          ;;<br>      *)<br>          echo $i<br>          ;;<br>  esac<br>done<br>done<br></code></pre></td></tr></table></figure>
<p>该示例每读入非EOF的字符串，会输出一遍1-7</p>
<p>该程序可以输入<code>Ctrl+d</code>文件结束符来结束，也可以直接用<code>Ctrl+c</code>杀掉该进程。</p>
<hr />
<p><strong>contiune命令</strong></p>
<p>跳出当前循环。</p>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">for ((i=1;i&lt;=10;i++))<br>do<br>if [ `expr $i % 2` -eq 0 ]<br>then<br>  continue<br>fi<br>echo $i<br>done<br></code></pre></td></tr></table></figure>
<p>该程序输出1-10中的所有奇数</p>
<p><strong>死循环的处理方式</strong></p>
<p>如果<code>AC Terminal</code>可以打开该程序，则输入<code>Ctrl+c</code>即可。</p>
<p>否则可以直接关闭进程：</p>
<ol type="1">
<li>使用<code>top</code>命令找到进程的<code>PID</code></li>
<li>输入<code>kill -9 PID</code>即可关掉此进程</li>
</ol>
</blockquote>
<h3 id="函数">13.函数</h3>
<p>​ <strong>描述：</strong></p>
<blockquote>
<p><code>bash</code>中的函数类似于<code>C/C++</code>中的函数，但<code>return</code>的返回值与<code>C/C++</code>不同，返回的是<code>exit code</code>，取值为<code>0-255</code>，<code>0</code>表示正常结束。</p>
<p>如果想获取函数的输出结果，可以通过<code>echo</code>输出到<code>stdout</code>中，然后通过<code>$(function_name)</code>来获取<code>stdout</code>中的结果。</p>
<p>函数的<code>return</code>值可以通过<code>$?</code>来获取。</p>
<p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[function] func_name() &#123;  # function关键字可以省略<br>语句1<br>语句2<br>...<br>&#125;<br></code></pre></td></tr></table></figure>
<hr />
<p><strong>不获取<code>return</code>值和<code>stdout</code>值</strong></p>
<p>示例</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">func() &#123;<br>name=yxc<br>echo &quot;Hello $name&quot;<br>&#125;<br><br>func<br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Hello yxc<br></code></pre></td></tr></table></figure>
<hr />
<p><strong>获取<code>return</code>值和<code>stdout</code>值</strong></p>
<p>不写<code>return</code>时，默认<code>return 0</code></p>
<p>示例</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">func() &#123;<br>name=yxc<br>echo &quot;Hello $name&quot;<br><br>return 123<br>&#125;<br><br>output=$(func)<br>ret=$?<br><br>echo &quot;output = $output&quot;<br>echo &quot;return = $ret&quot;<br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">output = Hello yxc<br>return = 123<br></code></pre></td></tr></table></figure>
<p><strong>函数的输入参数</strong></p>
<p>在函数内，<code>$1</code>表示第一个输入参数，<code>$2</code>表示第二个输入参数，依此类推。</p>
<p>注意：函数内的<code>$0</code>仍然是文件名，而不是函数名。</p>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell">func() &#123;  # 递归计算 $1 + ($1 - 1) + ($1 - 2) + ... + 0<br>word=&quot;&quot;<br>while [ &quot;$&#123;word&#125;&quot; != &#x27;y&#x27; ] &amp;&amp; [ &quot;$&#123;word&#125;&quot; != &#x27;n&#x27; ]<br>do<br>  read -p &quot;要进入func($1)函数吗？请输入y/n：&quot; word<br>done<br><br>if [ &quot;$word&quot; == &#x27;n&#x27; ]<br>then<br>  echo 0<br>  return 0<br>fi  <br><br>if [ $1 -le 0 ] <br>then<br>  echo 0<br>  return 0<br>fi  <br><br>sum=$(func $(expr $1 - 1))<br>echo $(expr $sum + $1)<br>&#125;<br><br>echo $(func 10)<br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">55<br></code></pre></td></tr></table></figure>
<p><strong>函数内部的局部变量</strong></p>
<p>可以在函数内定义局部变量，作用范围仅在当前函数内。</p>
<p>可以在递归函数中定义局部变量。</p>
<p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">local 变量名=变量值<br></code></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">! /bin/bash</span><br><br>func() &#123;<br>local name=yxc<br>echo $name<br>&#125;<br>func<br><br>echo $name<br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">yxc<br><br></code></pre></td></tr></table></figure>
<p>第一行为函数内的name变量，第二行为函数外调用name变量，会发现此时该变量不存在。</p>
</blockquote>
<h3 id="exit命令">14.exit命令</h3>
<p>​ <strong>描述：</strong></p>
<blockquote>
<p><code>exit</code>命令用来退出当前<code>shell</code>进程，并返回一个退出状态；使用<code>$?</code>可以接收这个退出状态。</p>
<p><code>exit</code>命令可以接受一个整数值作为参数，代表退出状态。如果不指定，默认状态值是
<code>0</code>。</p>
<p><code>exit</code>退出状态只能是一个介于 <code>0~255</code>
之间的整数，其中只有 <code>0</code> 表示成功，其它值都表示失败。</p>
<hr />
<p>示例：</p>
<p>创建<code>test.ch</code>，内容如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">! /bin/bash</span><br><br>if [ $# -ne 1 ]  # 如果传入参数个数等于1，则正常退出；否则非正常退出。<br>then<br> echo &quot;arguments not valid&quot;<br> exit 1<br>else<br> echo &quot;arguments valid&quot;<br> exit 0<br>fi<br></code></pre></td></tr></table></figure>
<p>执行该脚本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">acs@9e0ebfcd82d7:~$ chmod +x test.sh <br>acs@9e0ebfcd82d7:~$ ./test.sh acwing<br>arguments valid<br>acs@9e0ebfcd82d7:~$ echo $?  # 传入一个参数，则正常退出，exit code为0<br>0<br>acs@9e0ebfcd82d7:~$ ./test.sh <br>arguments not valid<br>acs@9e0ebfcd82d7:~$ echo $?  # 传入参数个数不是1，则非正常退出，exit code为1<br>1<br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="文件重定向">15.文件重定向</h3>
<p>​ <strong>描述：</strong></p>
<blockquote>
<p>每个进程默认打开3个文件描述符：</p>
<ul>
<li><code>stdin</code>标准输入，从命令行读取数据，文件描述符为0</li>
<li><code>stdout</code>标准输出，向命令行输出数据，文件描述符为1</li>
<li><code>stderr</code>标准错误输出，向命令行输出数据，文件描述符为2</li>
</ul>
<p>可以用文件重定向将这三个文件重定向到其他文件中。</p>
<hr />
<table>
<thead>
<tr class="header">
<th><strong>命令</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>command &gt; file</code></td>
<td>将<code>stdout</code>重定向到<code>file</code>中</td>
</tr>
<tr class="even">
<td><code>command &lt; file</code></td>
<td>将<code>stdin</code>重定向到<code>file</code>中</td>
</tr>
<tr class="odd">
<td><code>command &gt;&gt; file</code></td>
<td>将<code>sidout</code>以追加的方式重定向到<code>file</code>中</td>
</tr>
<tr class="even">
<td><code>command n &gt; file</code></td>
<td>将文件描述符<code>n</code>重定向到<code>file</code>中</td>
</tr>
<tr class="odd">
<td><code>command n &gt;&gt; file</code></td>
<td>将文件描述符<code>n</code>以追加的方式重定向到<code>file</code>中</td>
</tr>
</tbody>
</table>
<hr />
<p><strong>输入和输出重定向</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo -e &quot;Hello \c&quot; &gt; output.txt  # 将stdout重定向到output.txt中<br>echo &quot;World&quot; &gt;&gt; output.txt  # 将字符串追加到output.txt中<br><br>read str &lt; output.txt  # 从output.txt中读取字符串<br><br>echo $str  # 输出结果：Hello World<br></code></pre></td></tr></table></figure>
<hr />
<p><strong>同时重定向stdin和stdout</strong></p>
<p>创建bash脚本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">! /bin/bash</span><br><br>read a<br>read b<br><br>echo $(expr &quot;$a&quot; + &quot;$b&quot;)<br></code></pre></td></tr></table></figure>
<p>创建input.txt，里面的内容为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell'">3<br>4<br></code></pre></td></tr></table></figure>
<p>执行命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">acs@9e0ebfcd82d7:~$ chmod +x test.sh  # 添加可执行权限<br>acs@9e0ebfcd82d7:~$ ./test.sh &lt; input.txt &gt; output.txt  # 从input.txt中读取内容，将输出写入output.txt中<br>acs@9e0ebfcd82d7:~$ cat output.txt  # 查看output.txt中的内容<br>7<br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="引入外部脚本">16.引入外部脚本</h3>
<p>​ <strong>描述：</strong></p>
<blockquote>
<p>类似于<code>C/C++</code>中的<code>include</code>操作，<code>bash</code>也可以引入其他文件中的代码。</p>
<p>语法格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">. filename  # 注意点和文件名之间有一个空格<br><br>或<br><br>source filename<br></code></pre></td></tr></table></figure>
<hr />
<p><strong>示例</strong></p>
<p>创建<code>test1.sh</code>，内容为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">! /bin/bash</span><br><br>name=yxc  # 定义变量name<br></code></pre></td></tr></table></figure>
<p>创建<code>test2.sh</code>，内容为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">! /bin/bash</span><br><br>source test1.sh # 或 . test1.sh<br><br>echo My name is: $name  # 可以使用test1.sh中的变量<br></code></pre></td></tr></table></figure>
<p>执行命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">acs@9e0ebfcd82d7:~$ chmod +x test2.sh <br>acs@9e0ebfcd82d7:~$ ./test2.sh <br>My name is: yxc<br></code></pre></td></tr></table></figure>
</blockquote>
<h2 id="ssh">4.ssh</h2>
<p>​ <strong>描述：</strong>多敲多敲多敲</p>
<blockquote>
<h3
id="ssh登录ctrld快速logout"><em>ssh登录</em>：<code>ctrl+d</code>快速logout</h3>
<h4 id="基本用法">基本用法</h4>
<p>远程登录服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs usd">ssh user@hostname<br></code></pre></td></tr></table></figure>
<ul>
<li><code>user</code>：用户名</li>
<li><code>hostname</code>：IP地址或域名</li>
</ul>
<p>第一次登录时会提示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">The authenticity of host &#x27;123.57.47.211 (123.57.47.211)&#x27; can&#x27;t be established.<br>ECDSA key fingerprint is SHA256:iy237yysfCe013/l+kpDGfEG9xxHxm0dnxnAbJTPpG8.<br>Are you sure you want to continue connecting (yes/no/[fingerprint])?<br></code></pre></td></tr></table></figure>
<p>输入<code>yes</code>，然后回车即可</p>
<p>这样会将该服务器的信息记录在<code>~/ .ssh/kown_hosts</code>文件中。</p>
<p>然后输入密码即可登录到远程服务中。</p>
<hr />
<p>默认登录端口为22。如果想登录某一个特定端口</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh user@hostname -p 22<br></code></pre></td></tr></table></figure>
<hr />
<h4 id="配置文件">配置文件</h4>
<p>创建文件<code>~/ .ssh/config</code></p>
<p>然后在文件输入：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">Host myserver1<br>	HostName IP地址或域名<br>	User 用户名<br><br>Host myserver2<br>	HostName IP地址或域名<br>	User 用户名<br></code></pre></td></tr></table></figure>
<p>之后再使用服务器时，可以直接使用别名<code>myserver1</code>、<code>myserver2</code>。</p>
<hr />
<h4 id="密钥登录">密钥登录</h4>
<p>创建密钥：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen<br></code></pre></td></tr></table></figure>
<p>然后一直回车即可。</p>
<p>执行结束后，<code>~/ .ssh/</code>目录下会多两个文件</p>
<ul>
<li><code>id_rsa</code>：私钥</li>
<li><code>id_rsa.pub</code>：公钥</li>
</ul>
<hr />
<p>之后想免密码登录哪一台服务器，就将公钥传给哪个服务器即可。</p>
<p>例如，想免密登录<code>myserver</code>服务器。则将公钥中的内容，复制到<code>myserver</code>中的<code>~/.ssh/authorized_keys</code>文件里即可。</p>
<p>也可以使用如下命令一键添加公钥：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-copy-id myserver<br></code></pre></td></tr></table></figure>
<hr />
<h4 id="执行命令">执行命令</h4>
<p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh user@hostname command<br></code></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh user@hostname ls -a<br></code></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">单引号中的<span class="hljs-variable">$i</span>可以求值（<span class="hljs-variable">$i</span>可以解析）</span><br>ssh myserver &#x27;for ((i = 0; i &lt; 10; i ++ )) do echo $i; done&#x27;<br></code></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">双引号中的<span class="hljs-variable">$i</span>不可以求值（<span class="hljs-variable">$i</span>不被解析）</span><br>ssh myserver &quot;for ((i = 0; i &lt; 10; i ++ )) do echo $i; done&quot;<br></code></pre></td></tr></table></figure>
<h3 id="scp传文件"><em>scp传文件</em></h3>
<h4 id="基本用法-1">基本用法</h4>
<p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp source destination<br></code></pre></td></tr></table></figure>
<p>将<code>source</code>路径下的文件复制到<code>destination</code>中</p>
<p>一次复制多个文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp source1 source2 destination<br></code></pre></td></tr></table></figure>
<hr />
<p>赋值文件夹：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp -r ~/tmp myserver:/home/acs<br></code></pre></td></tr></table></figure>
<p>将本地家目录中的<code>tmp</code>文件复制到<code>myserver</code>服务器中的<code>/home/acs</code>目录下。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp -r ~/tmp myserver:homework/<br></code></pre></td></tr></table></figure>
<p>将本地家目录中的<code>tmp</code>文件夹复制到<code>myserver</code>服务器中<code>~/homework/</code>目录下。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp -r myserver:homework.<br></code></pre></td></tr></table></figure>
<p>将<code>myserver</code>服务器中的<code>~/homework/</code>文件夹复制到本地的当前路径下。</p>
<hr />
<p>指定服务器的端口号：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp -P 22 source1 source2 destination<br></code></pre></td></tr></table></figure>
<hr />
<p><strong>注意：</strong><code>scp</code>的<code>-r -p</code>等参数尽量加在<code>source</code>和<code>destination</code>之前</p>
<hr />
<h4
id="使用scp配置其他服务器的vim和tmux">使用<code>scp</code>配置其他服务器的<code>vim</code>和<code>tmux</code></h4>
<p><code>Ac Terminal</code>中的<code>.vimrc</code>和<code>.tmux.conf</code>文件是旷视公司leader留下来的
是经验的集大成配置文件</p>
<p>其实就是修改根目录下的<code>.vimrc</code>和<code>.tmux.conf</code>文件即可（具体修改操作查询）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp ~/.vimrc ~/.tmux.conf myserver:<br></code></pre></td></tr></table></figure>
</blockquote>
<h2 id="git">5.git</h2>
<p>​ <strong>描述：</strong>多敲多敲多敲多敲</p>
<p>一般情况开发的话不会在主分支上开发，会在旁分支上开发</p>
<blockquote>
<h4 id="git平台">1.git平台</h4>
<p>代码托管平台：<a href="git.acwing.com">acgit</a>、<a
target="_blank" rel="noopener" href="https://github.com/">github</a>、<a
target="_blank" rel="noopener" href="https://gitee.com/">gitee</a></p>
<h4 id="git基本概念">2.git基本概念</h4>
<ul>
<li><strong>工作区</strong>：仓库的目录。工作区是独立于各个分支的</li>
<li><strong>暂存区</strong>：数据暂时存放的区域，类似于工作区写入版本前的缓存区。缓存区是独立于分支的。</li>
<li><strong>版本库</strong>：存放所有已经提交到本地仓库的代码版本</li>
<li><strong>版本结构</strong>：树结构，树中每一个节点代表一个版本</li>
</ul>
<h4 id="全局设置">3.全局设置</h4>
<ol type="1">
<li><code>git config --global user.name xxx</code>：设置全局用户名，信息记录在<code>~/.gitconfig</code>文件中</li>
<li><code>git config --global user.email xxx@xxx.com</code>：设置全局邮箱地址，信息记录在<code>~/.gitconfig</code>文件中</li>
<li><code>git init</code>：将当前目录配置成git仓库，信息记录在隐藏的.git文件夹中</li>
</ol>
<h4 id="常用命令">4.常用命令</h4>
<ol type="1">
<li><code>git add XX</code>：将XX文件添加到暂存区</li>
<li><code>git commit -m"给自己看的备注信息"</code>：将暂存区的内容提交到当前分支</li>
<li><code>git status</code>：查看仓库状态</li>
<li><code>git log</code>：查看当前分支的所有版本</li>
<li><code>git push -u (第一次需要-u以后不需要)</code>：将当前分支推送到远程仓库</li>
<li><code>git clone git@git.acwing.com:xxx/XXX.git</code>：将远程仓库XXX下载到当前目录下</li>
<li><code>git branch</code>：查看所有分支和当前所处分支</li>
</ol>
<h4 id="查看命令">5.查看命令</h4>
<ol type="1">
<li><code>git diff XX</code>：查看XX文件相对于暂存区修改了哪些内容
<ul>
<li>当工作区有改动，暂存区为空时，<code>diff</code>对比的是<code>工作区与最后一次commit提交的仓库的共同文件</code></li>
<li>当工作区有改动，暂存区不为空，<code>diff</code>对比的是<code>工作区与暂存区的共同文件</code></li>
</ul></li>
<li><code>git status</code>：查看仓库状态</li>
<li><code>git log</code>：查看当前分支的所有版本 -&gt;
<code>tips：git log太多的时候会进入翻页状态，命令行会消失，通过PgDn能够向下翻页，按q退出翻页状态</code>
<ul>
<li><code>git log --pretty=oneline</code>：用一行来显示</li>
</ul></li>
<li><code>git reflog</code>：查看HEAD指针的移动历史（包括被回滚的版本）</li>
<li><code>git branch</code>：查看所有分支和当前所处分支</li>
<li><code>git pull</code>：将远程仓库的当前分支与本地仓库的当前分支合并</li>
</ol>
<h4 id="删除命令">6.删除命令</h4>
<ol type="1">
<li><code>git rm --cached XX</code>：将文件从仓库索引目录中删掉，不希望管理这个文件</li>
<li><code>git restore --staged xx</code>：将xx从暂存区里移除</li>
<li><code>it checkout — XX或git restore XX</code>：将XX文件尚未加入暂存区的修改全部撤销</li>
</ol>
<h4 id="代码回滚">7.代码回滚</h4>
<ol type="1">
<li><code>git reset --hard HEAD^</code> 或
<code>git reset --hard HEAD~</code>：将代码库回滚到上一个版本</li>
<li><code>git reset --hard HEAD^^</code>：往上回滚两次，以此类推</li>
<li><code>git reset --hard HEAD~100</code>：往上回滚100个版本</li>
<li><code>git reset --hard 版本号</code>：回滚到某一特定版本</li>
</ol>
<h4 id="远程仓库">8.远程仓库</h4>
<ol type="1">
<li><code>git remote add origin git@git.acwing.com:xxx/XXX.git</code>：将本地仓库关联到远程仓库</li>
<li><code>git push -u (第一次需要-u以后不需要)</code>：将当前分支推送到远程仓库
<ul>
<li><code>git push origin branch_name</code>：将本地的某个分支推送到远程仓库</li>
</ul></li>
<li><code>git clone git@git.acwing.com:xxx/XXX.git</code>：将远程仓库XXX下载到当前目录下</li>
<li><code>git push --set-upstream origin branch_name</code>：设置本地的<code>branch_name</code>分支对应远程仓库的<code>branch_name</code>分支</li>
<li><code>git push -d origin branch_name</code>：删除远程仓库的<code>branch_name</code>分支</li>
<li><code>git checkout -t origin/branch_name</code>：将远程的<code>branch_name</code>分支拉取到本地</li>
<li><code>git pull</code>：将远程仓库的当前分支与本地仓库的当前分支合并
<ul>
<li><code>git pull origin branch_name</code>：将远程仓库的<code>branch_name</code>分支与本地仓库的当前分支合并</li>
</ul></li>
<li><code>git branch --set-upstream-to=origin/branch_name1 branch_name2</code>：将远程的<code>branch_name1</code>分支与本地的<code>branch_name2</code>分支对应</li>
</ol>
<h4 id="分支命令">9.分支命令</h4>
<ol type="1">
<li><code>git branch branch_name</code>：创建新分支</li>
<li><code>git branch</code>：查看所有分支和当前所处分支</li>
<li><code>git checkout -b branch_name</code>：创建并切换到<code>branch_name</code>这个分支</li>
<li><code>git checkout branch_name</code>：切换到<code>branch_name</code>这个分支</li>
<li><code>git merge branch_name</code>：将分支<code>branch_name</code>合并到当前分支上</li>
<li><code>git branch -d branch_name</code>：删除本地仓库的<code>branch_name</code>分支</li>
<li><code>git push --set-upstream origin branch_name</code>：设置本地的<code>branch_name</code>分支对应远程仓库的<code>branch_name</code>分支</li>
<li><code>git push -d origin branch_name</code>：删除远程仓库的<code>branch_name</code>分支</li>
<li><code>git checkout -t origin/branch_name</code>：将远程的<code>branch_name</code>分支拉取到本地</li>
<li><code>git pull</code>：将远程仓库的当前分支与本地仓库的当前分支合并
<ul>
<li><code>git pull origin branch_name</code>：将远程仓库的<code>branch_name</code>分支与本地仓库的当前分支合并</li>
</ul></li>
<li><code>git branch --set-upstream-to=origin/branch_name1 branch_name2</code>：将远程的<code>branch_name1</code>分支与本地的<code>branch_name2</code>分支对应</li>
</ol>
<h4 id="stash暂存">10.stash暂存</h4>
<ol type="1">
<li><code>git stash</code>：将工作区和暂存区中尚未提交的修改存入栈中</li>
<li><code>git stash apply</code>：将栈顶存储的修改恢复到当前分支，但不删除栈顶元素</li>
<li><code>git stash drop</code>：删除栈顶存储的修改</li>
<li><code>git stash pop</code>：将栈顶存储的修改恢复到当前分支，同时删除栈顶元素</li>
<li><code>git stash list</code>：查看栈中所有元素</li>
</ol>
</blockquote>
<h2 id="thrift引莫凡笔记">6.thrift(引莫凡笔记)</h2>
<p>​ <strong>描述：</strong>多敲多敲多敲多敲</p>
<blockquote>
<p>本文thrift引用他人笔记：<a
target="_blank" rel="noopener" href="https://git.acwing.com/fashen/thrift_learning/-/blob/master/readme.md">莫凡thrift学习</a></p>
</blockquote>
<h3 id="目录">目录</h3>
<ul>
<li><a href="#第六讲-thrift">第六讲 thrift</a>
<ul>
<li><a href="#简介">简介</a></li>
<li><a href="#thrift-idl">Thrift IDL</a></li>
<li><a href="#如何创建一个thrift服务">如何创建一个Thrift服务?</a></li>
</ul></li>
<li><a
href="#接下来写个栗子来熟悉thrift的使用">接下来写个栗子来熟悉thrift的使用</a>
<ul>
<li><a href="#一个游戏的匹配服务分析">一个游戏的匹配服务分析</a>
<ul>
<li><a href="#分析总结">分析总结:</a></li>
</ul></li>
<li><a href="#实现一个游戏的匹配服务">实现一个游戏的匹配服务</a>
<ul>
<li><a href="#名字空间namespace">① 名字空间NameSpace</a></li>
<li><a href="#结构体struct">② 结构体struct</a></li>
<li><a href="#-服务定义类型service">③ 服务定义类型Service</a></li>
<li><a href="#-定义服务接口之后先实现match-server">④
定义服务接口之后，先实现match-server</a></li>
<li><a href="#-如何编译thrift生成的c代码">⑤
如何编译thrift生成的C++代码?</a></li>
<li><a href="#-实现match-client">⑥ 实现match-client</a></li>
<li><a href="#-将match-client的代码改成从标准输入中获取信息">⑦
将match-client的代码改成从标准输入中获取信息</a></li>
<li><a href="#-完善match-server">⑧ 完善match-server</a></li>
<li><a href="#-实现save_client">⑨ 实现save_client</a></li>
<li><a href="#-升级match-server">⑩ 升级match-server</a></li>
<li><a href="#-将thrift的单独server模式改成多线程server模式">⑪
将thrift的单独Server模式改成多线程Server模式</a></li>
<li><a href="#-添加match-server的规则">⑫ 添加match-server的规则</a></li>
</ul></li>
</ul></li>
<li><a href="#知识点">知识点:</a>
<ul>
<li><a href="#c-头文件">C 头文件</a></li>
<li><a href="#using-namespace-std的作用">using namespace
std的作用</a></li>
<li><a href="#localhost127001-和-本机ip-三者的区别">localhost，127.0.0.1
和 本机IP 三者的区别</a></li>
<li><a href="#端口">端口)</a></li>
<li><a
href="#include-thread"><code>#include &lt;thread&gt;</code></a></li>
<li><a href="#互斥锁">互斥锁</a></li>
<li><a href="#include-condition_variable">#include
<condition_variable></a></li>
<li><a href="#c中类的定义">C++中类的定义</a></li>
<li><a
href="#vector的size是无符号整数类型">vector的size()是无符号整数类型。</a></li>
<li><a
href="#vector的erase是左闭右开">vector的erase()是左闭右开。</a></li>
<li><a href="#求一个字符串的md5值">求一个字符串的md5值。</a></li>
<li><a href="#英语知识">英语知识</a></li>
</ul></li>
</ul>
<blockquote>
<p>我们写一个应用时，这个应用程序并不止一个服务，而且不同的服务分配到不同服务器(或者进程)上，也就是我们常说的<a
target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%BE%AE%E6%9C%8D%E5%8A%A1/18758759?fr=aladdin">微服务</a>
。</p>
</blockquote>
<h3 id="简介">简介</h3>
<p><a target="_blank" rel="noopener" href="https://thrift.apache.org/">thrift官网</a>
<strong>官网教程:进入官网-&gt;Tutorial-&gt;tutorial.thrift</strong></p>
<p><strong>Apache
Thrift</strong>软件框架用于可伸缩的跨语言服务开发，它将<strong>软件栈</strong>和<strong>代码生成引擎</strong>结合在一起，以构建在C++、Java、Python、PHP、Ruby、Erlang、Perl、Haskell、C#、Cocoa、JavaScript、Node.js、Smalltalk、OCaml和Delphi等语言之间高效、无缝地工作的服务。</p>
<p><strong>Thrift使用C++进行编写</strong>，在安装使用的时候需要安装依赖，windows安装方式见官网即可。安装方式：<a
target="_blank" rel="noopener" href="http://thrift.apache.org/docs/install/">thrift官网介绍安装方式</a></p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs d">thrift -<span class="hljs-keyword">version</span> <span class="hljs-comment">//查看thrift版本</span><br></code></pre></td></tr></table></figure>
<hr />
<h3 id="thrift-idl">Thrift IDL</h3>
<p>Thrift 采用IDL（Interface Definition
Language）来定义通用的服务接口，然后通过Thrift提供的编译器，可以将服务接口编译成不同语言编写的代码，通过这个方式来实现跨语言的功能。</p>
<ul>
<li>通过命令调用Thrift提供的编译器将服务接口编译成不同语言编写的代码。</li>
<li>这些代码又分为服务端和客户端，将所在不同进程(或服务器)的功能连接起来。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">thrift -r --gen <span class="hljs-tag">&lt;<span class="hljs-name">language</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">Thrift</span> <span class="hljs-attr">filename</span>&gt;</span><br></code></pre></td></tr></table></figure>
<hr />
<h3 id="如何创建一个thrift服务">如何创建一个Thrift服务?</h3>
<ol type="1">
<li>定义服务接口(存放接口的文件夹就是thrift文件)</li>
<li>作为服务端的服务，需要生成server。</li>
<li>作为请求端的服务，需要生成client。</li>
</ol>
<hr />
<h3
id="接下来写个栗子来熟悉thrift的使用">接下来写个栗子来熟悉thrift的使用</h3>
<h4 id="一个游戏的匹配服务分析">一个游戏的匹配服务分析</h4>
<p><strong>一般情况如图所示</strong></p>
<figure>
<img
src="https://cdn.acwing.com/media/article/image/2021/10/05/97206_32d5aa8525-无标题.png" srcset="/img/loading.gif" lazyload
alt="无标题.png" />
<figcaption aria-hidden="true">无标题.png</figcaption>
</figure>
<p><strong>分析图示内容</strong>
这个游戏的功能可能运行在一个或多个服务器(或进程)上，而thrift就是将不同服务器不同语言的功能连接起来。
图中的三个节点(功能)是完全独立的，既可以在同一个服务器上，也可以在不同服务器上。
每一个节点就是一个进程，每个进程可以使用不同的语言来实现。</p>
<ul>
<li>在GAME节点上实现客户端通过调用匹配系统的服务端中实现的两个服务接口函数获取功能，实现跨语言跨服务的工作。</li>
<li>每个节点(功能)之间通过thrift定义的服务接口作为有向边进行连接。
弧尾所在的节点创建客户端，弧头所在的节点创建服务端。</li>
<li>匹配系统节点实现服务端，其中有一个匹配池：不断的接收玩家和删除玩家，同时根据一定的规则给每个玩家安排一局游戏。</li>
<li>匹配系统节点实现客户端，通过调用数据存储节点的服务端中实现的一个服务接口函数获取功能，实现跨语言跨服务的工作。</li>
<li>每个功能(节点)之间通过thrift定义的服务接口作为有向边进行连接。
弧尾所在的节点创建客户端，弧头所在的节点创建服务端。</li>
<li>数据存储节点实现服务端。别人已经将服务接口和服务端实现好了。</li>
<li>服务接口功能介绍: add_user：向匹配池中添加玩家。
remove_user：从匹配池中删除玩家。 save_data：将匹配信息存储起来。</li>
</ul>
<p><strong>补充</strong></p>
<ul>
<li>有向边也称弧,边的始点称为弧尾,终点称为弧头。</li>
<li>当做项目时，可能有人已经将服务接口实现好了，即将服务端实现了，我们只需要创建客户端即可。</li>
</ul>
<h4 id="分析总结">分析总结:</h4>
<p>在实现服务之前，最好先画个图分析，这样目标明确、思路清晰。</p>
<p><strong>图中的要素</strong></p>
<ol type="1">
<li>不同服务作为节点</li>
<li>每个服务是在哪个服务器上实现的</li>
<li>每个服务通过什么语言实现</li>
<li>服务之间通过怎样的服务接口进行连接。</li>
<li>通过业务逻辑确认每个服务需要创建哪些服务端和客户端。</li>
</ol>
<hr />
<h3 id="实现一个游戏的匹配服务">实现一个游戏的匹配服务</h3>
<p>这里为了方便我们需要创建两个文件夹表示game节点(game)和匹配服务节点(match_system)，其实也可以放在不同的服务器上，不过条件不允许啊😉，而数据存储节点的服务端已经实现好了，只要调用服务接口实现的函数即可。</p>
<p>接下来创建一个thrift文件夹存储.thrift文件，.thrift文件定义服务接口。其中有两个.thrift文件分别表示两条有向边，一条有向边可以包含多个服务接口。</p>
<p>先定义服务接口。 定义添加玩家和删除玩家的两个接口。
在thrift文件夹中，创建match.thrift文件。然后进行接下来的内容。</p>
<hr />
<h4 id="名字空间namespace">①名字空间NameSpace</h4>
<p>Thrift中的命名空间类似于C++中的namespace和java中的package，它们提供了一种组织（隔离）代码的简便方式。名字空间也可以用于解决类型定义中的名字冲突。</p>
<p>由于每种语言均有自己的命名空间定义方式（如:python中有module）,
thrift允许开发者针对特定语言定义namespace。</p>
<p>简单的demo：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">namespace</span> java com.xtxxtx.test<br></code></pre></td></tr></table></figure>
<p>转换成</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">package</span> <span class="hljs-title">com.xtxxtx.test</span><br></code></pre></td></tr></table></figure>
<p><strong>教程中的介绍:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Thrift files can namespace, package, or prefix their output in various</span><br><span class="hljs-comment"> * target languages.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">namespace</span> <span class="hljs-symbol">cl</span> <span class="hljs-symbol">tutorial</span><br><span class="hljs-symbol">namespace</span> <span class="hljs-symbol">cpp</span> <span class="hljs-symbol">tutorial</span>  <br><span class="hljs-symbol">namespace</span> <span class="hljs-symbol">d</span> <span class="hljs-symbol">tutorial</span><br><span class="hljs-symbol">namespace</span> <span class="hljs-symbol">dart</span> <span class="hljs-symbol">tutorial</span><br><span class="hljs-symbol">namespace</span> <span class="hljs-symbol">java</span> <span class="hljs-symbol">tutorial</span><br><span class="hljs-symbol">namespace</span> <span class="hljs-symbol">php</span> <span class="hljs-symbol">tutorial</span><br><span class="hljs-symbol">namespace</span> <span class="hljs-symbol">perl</span> <span class="hljs-symbol">tutorial</span><br><span class="hljs-symbol">namespace</span> <span class="hljs-symbol">haxe</span> <span class="hljs-symbol">tutorial</span><br><span class="hljs-symbol">namespace</span> <span class="hljs-symbol">netstd</span> <span class="hljs-symbol">tutorial</span><br><br>//匹配系统我们用<span class="hljs-symbol">C</span>++实现。<br>//语法:<span class="hljs-symbol">namespace</span> 使用的语言 空间名称<br><span class="hljs-symbol">namespace</span> <span class="hljs-symbol">cpp</span> <span class="hljs-symbol">match_dao</span><br></code></pre></td></tr></table></figure>
<hr />
<h4 id="结构体struct">②结构体struct</h4>
<p>数据类型在结构体中定义。 struct有以下一些约束：</p>
<ol type="1">
<li>struct不能继承，但是可以嵌套，不能嵌套自己。(0.12.0版本可以支持嵌套自己本身)</li>
<li>其成员都是有明确类型</li>
<li>成员是被正整数编号过的，其中的编号使不能重复的，这个是为了在传输过程中编码使用。</li>
<li>成员分割符可以是逗号（,）或是分号（;），而且可以混用</li>
<li>字段会有optional和required之分和protobuf一样，但是如果不指定则为无类型–可以不填充该值，但是在序列化传输的时候也会序列化进去，optional是不填充则部序列化，required是必须填充也必须序列化。</li>
<li>每个字段可以设置默认值</li>
<li>同一文件可以定义多个struct，也可以定义在不同的文件，进行include引入。</li>
</ol>
<p><strong>教程中介绍:</strong></p>
<figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs thrift"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Structs are the basic complex data structures. They are comprised of fields</span><br><span class="hljs-comment"> * which each have an integer identifier, a type, a symbolic name, and an</span><br><span class="hljs-comment"> * optional default value.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Fields can be declared &quot;optional&quot;, which ensures they will not be included</span><br><span class="hljs-comment"> * in the serialized output if they aren&#x27;t set.  Note that this requires some</span><br><span class="hljs-comment"> * manual management in some languages.</span><br><span class="hljs-comment"> */</span><br> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Work</span> </span>&#123;<br>  <span class="hljs-number">1</span>: <span class="hljs-type">i32</span> num1 = <span class="hljs-number">0</span>, <span class="hljs-comment">//默认值</span><br>  <span class="hljs-number">2</span>: <span class="hljs-type">i32</span> num2, <span class="hljs-comment">//默认字段类型是optional</span><br>  <span class="hljs-number">3</span>: Operation op,<br>  <span class="hljs-number">4</span>: <span class="hljs-keyword">optional</span> <span class="hljs-type">string</span> comment,<br>  <span class="hljs-number">5</span>: <span class="hljs-keyword">required</span> <span class="hljs-type">string</span> name, <span class="hljs-comment">//本字段必须填充</span><br>&#125;<br><br><span class="hljs-comment">//这里我们定义结构体用来存储用户信息。其中i32表示int，string表示字符串。</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-number">1</span>: <span class="hljs-type">i32</span> id,<br>    <span class="hljs-number">2</span>: <span class="hljs-type">string</span> name,<br>    <span class="hljs-number">3</span>: <span class="hljs-type">i32</span> score,<br>&#125;<br></code></pre></td></tr></table></figure>
<p>规则：</p>
<ul>
<li>如果required标识的域没有赋值，Thrift将给予提示；</li>
<li>如果optional标识的域没有赋值，该域将不会被序列化传输；</li>
<li>如果某个optional标识域有缺省值而用户没有重新赋值，则该域的值一直为缺省值；</li>
<li>如果某个optional标识域有缺省值或者用户已经重新赋值，而不设置它的__isset为true，也不会被序列化传输。</li>
</ul>
<hr />
<h4 id="服务定义类型service">③ 服务定义类型Service</h4>
<p>服务的定义方法在语义上等同于面向对象语言中的接口。比如java中的接口，只是参数需要加上编号。</p>
<p><strong>教程中介绍:</strong></p>
<figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs thrift"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Ahh, now onto the cool part, defining a service. Services just need a name</span><br><span class="hljs-comment"> * and can optionally inherit from another service using the extends keyword.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">service</span> <span class="hljs-title">Calculator</span> extends shared.SharedService </span>&#123;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * A method definition looks like C code. It has a return type, arguments,</span><br><span class="hljs-comment">   * and optionally a list of exceptions that it may throw. Note that argument</span><br><span class="hljs-comment">   * lists and exception lists are specified using the exact same syntax as</span><br><span class="hljs-comment">   * field lists in struct or exception definitions.</span><br><span class="hljs-comment">   */</span><br><br>   <span class="hljs-keyword">void</span> ping(),<br><br>   <span class="hljs-type">i32</span> add(<span class="hljs-number">1</span>:<span class="hljs-type">i32</span> num1, <span class="hljs-number">2</span>:<span class="hljs-type">i32</span> num2),<br><br>   <span class="hljs-type">i32</span> calculate(<span class="hljs-number">1</span>:<span class="hljs-type">i32</span> logid, <span class="hljs-number">2</span>:Work w) throws (<span class="hljs-number">1</span>:InvalidOperation ouch),<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * This method has a oneway modifier. That means the client only makes</span><br><span class="hljs-comment">    * a request and does not listen for any response at all. Oneway methods</span><br><span class="hljs-comment">    * must be void.</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">oneway</span> <span class="hljs-keyword">void</span> zip()<br><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 我们需要定义两个接口方法:add_user(), remove_user()</span><br><span class="hljs-comment">  * 其中`2: string info`表示额外信息。</span><br><span class="hljs-comment">  * 作用:以后想要更改接口时，不用更改接口，你可以直接将想传的信息传入到info中，</span><br><span class="hljs-comment">  * 然后对info进行序列化一个jinsen即可。</span><br><span class="hljs-comment">  */</span><br><span class="hljs-class"><span class="hljs-keyword">service</span> <span class="hljs-title">Match</span> </span>&#123;<br>    <span class="hljs-type">i32</span> add_user(<span class="hljs-number">1</span>: User user, <span class="hljs-number">2</span>: <span class="hljs-type">string</span> info),<br><br>    <span class="hljs-type">i32</span> remove_user(<span class="hljs-number">1</span>: User user, <span class="hljs-number">2</span>: <span class="hljs-type">string</span> info),<br>&#125;<br></code></pre></td></tr></table></figure>
<hr />
<h4 id="定义服务接口之后先实现match-server">④
定义服务接口之后，先实现match-server</h4>
<p><strong>如何通过接口生成C++版本的服务端?</strong></p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-comment">//通过这个命令就可以实现，不过在此之前需要做一些准备工作。</span><br><span class="hljs-comment">//tutorial.thrift表示从当前目录到定义接口的路径。</span><br>thrift -r --<span class="hljs-keyword">gen</span> cpp <span class="hljs-keyword">tutorial</span>.thrift<br></code></pre></td></tr></table></figure>
<p>具体操作如图所示: <img
src="https://cdn.acwing.com/media/article/image/2021/10/03/97206_24b6e98123-2021-10-02_213443.png" srcset="/img/loading.gif" lazyload
alt="2021-10-02_213443.png" /></p>
<ul>
<li>做到这里我们发现:有了接口之后，通过命令就可以生成C++版本的服务端相关的代码。但是具体业务我们还是需要具体写哦!</li>
<li><span
class="math inline">\(\color{red}{好习惯:写thrift服务的时候，先编译成功，然后再逐步向文件中添加模块。}\)</span></li>
</ul>
<hr />
<h4 id="如何编译thrift生成的c代码">⑤ 如何编译thrift生成的C++代码?</h4>
<p>因为<span
class="math inline">\(Thrift\)</span>由<code>C++</code>编写，所以编译的过程与<code>C++</code>一样。
本质就是编译一堆<code>C++</code>源文件(.cpp)。 <span
class="math inline">\(\color{green}{C++编译过程:}\)</span> <span
class="math inline">\(\color{red}{①编译}\)</span> <img
src="https://cdn.acwing.com/media/article/image/2021/10/03/97206_13c8927a23-2021-10-03_092958.png" srcset="/img/loading.gif" lazyload
alt="2021-10-03_092958.png" /> <span
class="math inline">\(\color{red}{②链接}\)</span> <img
src="https://cdn.acwing.com/media/article/image/2021/10/03/97206_26c2852823-2021-10-03_095345.png" srcset="/img/loading.gif" lazyload
alt="2021-10-03_095345.png" /> <img
src="https://cdn.acwing.com/media/article/image/2021/10/03/97206_5ee3260f23-2021-10-03_100004.png" srcset="/img/loading.gif" lazyload
alt="2021-10-03_100004.png" /> <img
src="https://cdn.acwing.com/media/article/image/2021/10/03/97206_d47a471223-2021-10-03_103957.png" srcset="/img/loading.gif" lazyload
alt="2021-10-03_103957.png" /></p>
<ul>
<li>好习惯:可执行文件和编译好的文件最好不要加进去，只加.cpp和.h文件。</li>
</ul>
<p>C++编译很慢，链接很快。所以每次修改项目，重新编译时，只需要编译修改过的.cpp文件即可，防止编译时间过长。
即修改哪个文件就编译哪个文件。
基于这一点考虑就有了make和cmake工具。但没啥用。</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coq">//前面加上<span class="hljs-built_in">time</span>查看编译和链接的时间。<br><span class="hljs-built_in">time</span> g++ -c .cpp文件<br><span class="hljs-built_in">time</span> g++ -o .o文件 -lthrift -pthread<br></code></pre></td></tr></table></figure>
<hr />
<h4 id="实现match-client">⑥ 实现match-client</h4>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-comment">//使用该命令创建python版本的服务端，然后通过修改得到客户端。</span><br><span class="hljs-comment">//这个命令python2和python3是兼容的。</span><br>thrift -r --<span class="hljs-keyword">gen</span> py <span class="hljs-keyword">tutorial</span>.thrift<br></code></pre></td></tr></table></figure>
<p><img
src="https://cdn.acwing.com/media/article/image/2021/10/03/97206_48b9a10724-2021-10-03_152548.png" srcset="/img/loading.gif" lazyload
alt="2021-10-03_152548.png" /> <img
src="https://cdn.acwing.com/media/article/image/2021/10/04/97206_0dfd243725-2021-10-03_131330.png" srcset="/img/loading.gif" lazyload
alt="2021-10-03_131330.png" /> <img
src="https://cdn.acwing.com/media/article/image/2021/10/03/97206_90e9ef8424-2021-10-03_154417.png" srcset="/img/loading.gif" lazyload
alt="2021-10-03_154417.png" /> <img
src="https://cdn.acwing.com/media/article/image/2021/10/03/97206_e47583d524-2021-10-03_155550.png" srcset="/img/loading.gif" lazyload
alt="2021-10-03_155550.png" /></p>
<ul>
<li><span
class="math inline">\(\color{red}{好习惯:每完成一个客户(服务)端时，推荐使用git进行持久化。}\)</span></li>
</ul>
<hr />
<blockquote>
<p>现在client端还不是很方便。因为每次都需要运行一下代码，而且代码是写死的。</p>
</blockquote>
<h4 id="将match-client的代码改成从标准输入中获取信息">⑦
将match-client的代码改成从标准输入中获取信息</h4>
<p><img
src="https://cdn.acwing.com/media/article/image/2021/10/03/97206_c14535c824-2021-10-03_161948.png" srcset="/img/loading.gif" lazyload
alt="2021-10-03_161948.png" />
至此，game的client端就完成了。最后将其持久化作为最终版。</p>
<ul>
<li><span
class="math inline">\(\color{red}{好习惯:在编译和运行时，产生的文件都不要持久化，这没有意义，只会占用网络带宽，会显得你的仓库不专业。}\)</span></li>
</ul>
<hr />
<blockquote>
<p>写server端需要分析业务模型。
需要进行监控，支持增加用户和删除用户。同时还要有一个线程去不停地进行匹配。
这个时候，我们发现需要实现两个功能，添加删除用户和匹配用户，根据微服务的概念需要开两个进程实现两个功能。</p>
</blockquote>
<h4 id="完善match-server">⑧ 完善match-server</h4>
<p>完善server端需要并利用<code>C++</code>实现多线程。视频定位：55:30</p>
<p>项目代码中有注解。</p>
<p>编译C++时，如果你用到了线程，需要加上线程的动态链接库的参数<code>-pthread</code>。
<code>-lthrift</code>参数将所有thrift动态连接文件连接起来。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">g++ *<span class="hljs-selector-class">.o</span> -o <span class="hljs-selector-tag">main</span> -lthrift -pthread<br></code></pre></td></tr></table></figure>
<hr />
<h4 id="实现save_client">⑨ 实现save_client</h4>
<p>因为一个节点(功能)只能由一个main方法作为程序的入口，所以匹配系统中的客户端和服务端写在同一个main方法中。我们这里根据逻辑将其实现在一个函数中。</p>
<ul>
<li>注意:复制教程中的代码时，一些细节需要更改。例如:其中带Calculator的字段都需要更改。</li>
<li>一些thrift接口和服务端有人会帮我们实现，这时我们只需调用接口实现的函数即可。例如:这里使用已经实现好的save_data()接口。</li>
</ul>
<hr />
<blockquote>
<p>我们现在的匹配系统是傻瓜式匹配，从队头逮到两个人就匹配成功，所以需要制定一些规则进行升级。
这里我们指定分差50以内的进行匹配。</p>
</blockquote>
<h4 id="升级match-server">⑩ 升级match-server</h4>
<hr />
<blockquote>
<p>一个线程处理输入输出，如果以后要处理并发量时，需要开多个线程处理。</p>
</blockquote>
<h4 id="将thrift的单独server模式改成多线程server模式">⑪
将thrift的单独Server模式改成多线程Server模式</h4>
<figure>
<img
src="https://cdn.acwing.com/media/article/image/2021/10/05/97206_d6beb85525-2021-10-05_092449.png" srcset="/img/loading.gif" lazyload
alt="2021-10-05_092449.png" />
<figcaption aria-hidden="true">2021-10-05_092449.png</figcaption>
</figure>
<hr />
<h4 id="添加match-server的规则">⑫ 添加match-server的规则</h4>
<p>匹配机制：等待时间越长，阈值越大。即匹配的范围随时间的推移而变大
故需要记录当前玩家在匹配池中等待的秒数。</p>
<p>至此，游戏的匹配服务就全部完成了。</p>
<hr />
<hr />
<hr />
<h3 id="知识点">知识点</h3>
<h4 id="c-头文件"><a
target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-header-files.html">C
头文件</a></h4>
<p>C 语言中 include &lt;&gt; 与include "" 的区别?
<code>#include &lt; &gt;</code>:引用的是编译器的类库路径里面的头文件。
<code>#include " "</code>:引用的是你程序目录的相对路径中的头文件，如果在程序目录没有找到引用的头文件则到编译器的类库路径的目录下找该头文件。</p>
<h4 id="using-namespace-std的作用"><a
target="_blank" rel="noopener" href="https://baike.baidu.com/item/using%20namespace%20std/10360651?fr=aladdin">using
namespace std的作用</a></h4>
<p>C++标准程序库中的所有标识符都被定义于一个名为std的namespace中。
由于namespace的概念，使用C++标准程序库的任何标识符时，可以有三种选择，具体看百度百科。
但是如果加上这段代码，就不用前缀。 比如:
<code>std::cout &lt;&lt; std::endl;</code>加上using namespace
std后，就可以写成这样<code>cout &lt;&lt; endl</code>。
<code>std::ios::sync_with_stdio(false);</code>加上using namespace
std后，就可以写成这样<code>ios::sync_with_stdio(false);</code>。(想了解<a
target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_51333606/article/details/116738816">ios::sync_with_stdio(false);</a>
用法开这篇文章)</p>
<h4 id="localhost127.0.0.1-和-本机ip-三者的区别">localhost，127.0.0.1 和
本机IP 三者的区别</h4>
<h5 id="端口"><a
target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%AB%AF%E5%8F%A3/103505?fr=aladdin">端口</a>)</h5>
<p>如果把IP地址比作一间房子
，端口就是出入这间房子的门。真正的房子只有几个门，但是一个IP地址的端口可以有65536（即：2^16）个之多！端口是通过端口号来标记的，端口号只有整数，范围是从0
到65535（2^16-1）。
同一个端口只能由一个进程来监听。所以我们一旦启动了一个服务，那么这个服务就不能在被另一个进程启动了。
服务器的端口号要与客户端的端口号相同。</p>
<hr />
<blockquote>
<p>每执行一个程序就是开了一个进程。每一个进程可以开一堆线程。
开多线程的开销是很小的，开多进程的开销是很大的。</p>
</blockquote>
<h4 id="include-thread"><code>#include &lt;thread&gt;</code></h4>
<p>C++中有一个thread的库，可以用来开线程。
通过定义一个变量将函数名作为参数，就能开一个线程了。
首先定义线程的操作。 并行中经典的生产者和消费者模型。
生产者、消费者是两个线程。 生产者:add_user()、remove_user()
消费者:匹配用户的功能。 生产者和消费者之间需要一个媒介。
这个媒介可以有很多种方法。比如:消费队列。
很多语言都有自己实现的消费队列，也可以自己实现消费队列。
实现消费队列，就需要用到一些锁(mutex)。 并行编程的基本概念:锁。</p>
<hr />
<h4 id="互斥锁">互斥锁</h4>
<p>在编程中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。每个对象都对应于一个可称为"
互斥锁"
的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。</p>
<p>锁🔒有两个操作。一个P操作(上锁)，一个V操作(解锁)。 定义互斥锁:mutex
m;
锁一般使用信号量来实现的，mutex其实就是一个信号量(它特殊也叫互斥量)。互斥量就是同一时间能够分给一个人，即S=1。
信号量S:S=10表示可以将信号量分给10个人来用。</p>
<p>P操作的主要动作是: ①S减1；
②若S减1后仍大于或等于0，则进程继续执行；<br />
③若S减1后小于0，则该进程被阻塞后放入等待该信号量的等待队列中，然后转进程调度。<br />
V操作的主要动作是： ①S加1； ②若相加后结果大于0，则进程继续执行；
③若相加后结果小于或等于0，则从该信号的等待队列中释放一个等待进程，然后再返回原进程继续执行或转进程调度。</p>
<p>对于P和V都是原子操作，就是在执行P和V操作时，不会被插队。从而实现对共享变量操作的原子性。
特殊:S=1表示互斥量，表示同一时间，信号量只能分配给一个线程。</p>
<p>多线程为啥要用锁?
因为多线程可能共享一个内存空间，导致出现重复读取并修改的现象。</p>
<hr />
<h4 id="include">#include <condition_variable></h4>
<hr />
<h4 id="c中类的定义">C++中类的定义</h4>
<hr />
<h4
id="vector的size是无符号整数类型">vector的size()是无符号整数类型。</h4>
<hr />
<h4 id="vector的erase是左闭右开">vector的erase()是左闭右开。</h4>
<hr />
<h4 id="求一个字符串的md5值">求一个字符串的md5值。</h4>
<p>输入命令"md5sum"，输入字符串回车然后<code>Ctrl + d</code>就行了。
md5加密</p>
<hr />
<blockquote>
<p>随着学习的深入，用到英语的地方越来越多，很多技术都是外国实现，中国的计算机技术还需要我辈去完善创新。
先从英语开始吧。每篇一记。</p>
</blockquote>
<h4 id="英语知识">英语知识</h4>
<ul>
<li>IDL:接口定义语言（Interface Definition Language）</li>
<li>RPC:远程过程调用（Remote Procedure Call）</li>
<li>client:客户，客户端</li>
</ul>
<p><font face="楷书" color=red>最后说一句，会了英语学编程真香，不说了，我去学英语了。</font></p>
<h2 id="管道环境变量与常用命令">7.管道、环境变量与常用命令</h2>
<p>​ <strong>描述：</strong>多敲多敲多敲多敲</p>
<blockquote>
<h3 id="管道">管道</h3>
<p><strong>概念：</strong></p>
<p>管道类似于文件重定向，可以将前一个命令的<code>stdout</code>重定向到下一个命令的<code>stdin</code>。</p>
<hr />
<p><strong>要点：</strong></p>
<ol type="1">
<li>管道命令仅处理<code>stdout</code>，会忽略<code>stderr</code>。</li>
<li>管道右边的命令必须能接受<code>stdin</code>。</li>
<li>多个管道命令可以串联。</li>
</ol>
<hr />
<p><strong>与文件重定向的区别：</strong></p>
<ul>
<li>文件重定向左边为命令，右边为文件。</li>
<li>管道左右两边均为命令，左边有<code>stdout</code>，右边有<code>stdin</code>。</li>
</ul>
<hr />
<p><strong>举例：</strong></p>
<p>统计当前目录下所有<code>python</code>文件的总行数，其中<code>find</code>、<code>xargs</code>、<code>wc</code>等命令可以参考常用命令这一节内容。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find . -name &#x27;*.py&#x27; | xargs cat | wc -l<br></code></pre></td></tr></table></figure>
<h3 id="环境变量">环境变量</h3>
<p><strong>概念：</strong>
Linux系统中会有很多环境变量来记录<strong>配置信息</strong></p>
<p>环境变量类似于全局变量，可以被各个进程访问到。我们可以通过修改环境变量来方便地修改系统变量。</p>
<hr />
<p><strong>查看：</strong></p>
<p>列出当前环境下的所有环境变量：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">env # 显示当前用户的变量<br>set #显示当前shell的变量，包括当前用户的变量<br>export # 显示当前导出成用户变量的shell变量<br></code></pre></td></tr></table></figure>
<p>输出某个环境变量的值：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo $PATH<br></code></pre></td></tr></table></figure>
<hr />
<p><strong>修改：</strong></p>
<p>环境变量的定义、修改、删除操作可以参考<a
href="#3.shell语法">3.shell语法——变量</a>这一节的内容。</p>
<p>为了将对环境变量的修改应用到未来所有环境下，可以将修改应用到当前的<code>~/.bashrc</code>文件中。</p>
<p>修改完<code>~/.bashrc</code>文件后，记得执行<code>source ~/.bashrc</code>,来将修改应用到当前的<code>bash</code>环境下。</p>
<p>为何将修改命令放到<code>~/.bashrc</code>文件后，就可以确保修改会影响未来所有的环境呢？</p>
<ul>
<li>每次启动<code>bash</code>，都会先执行<code>~/.bashrc</code>。</li>
<li>每次<code>ssh</code>登录远程服务器，都会启动一个<code>bash</code>命令行给我们。</li>
<li>每次<code>tmux</code>新开一个<code>pane</code>,都会启动一个<code>bash</code>命令行给我们。</li>
<li>所有未来所有新开的环境都会加载我们修改的内容。</li>
</ul>
<hr />
<p><strong>常见环境变量：</strong></p>
<ol type="1">
<li><code>HOME</code>:用户的家目录。</li>
<li><code>PATH</code>:可执行文件（命令）的存储路径之间用<code>:</code>分隔。当某个可执行文件同时出现在多个路径中时，会选择从左到右数第一个路径中的执行。<strong>下列所有存储路径的环境变量，均采用从左到右的优先顺序。</strong></li>
<li><code>LD_LIBRARY_PATH</code>:用于指定动态链接库(.so文件)的路径，其内容是以冒号分割的路径列表。</li>
<li><code>C_INCLUDE_PATH</code>:C语言的头文件路径，内容是以冒号分隔的路径列表</li>
<li><code>CPLUS_INCLUDE_PATH</code>:CPP的头文件路径，内容是以冒号分隔的路径列表。</li>
<li><code>PYTHONPATH</code>:Python导入包的路径，内容是以冒号分隔的路径列表。</li>
<li><code>JAVA_HOME</code>:jdk的安装目录。</li>
<li><code>CLASS_PATH</code>:存放Java导入类的路径，内容是以冒号分隔的路径列表。</li>
</ol>
<h3 id="常用命令-1">常用命令</h3>
<p>Linux命令非常多，本节讲解几个常用的命令。其他命令依赖于大家根据实际操作系统，边用边查。</p>
<hr />
<p><strong>系统状况：</strong></p>
<ol type="1">
<li><code>top</code>:查看所有进程的信息（Linux的任务管理器）
<ul>
<li>打开后，输入<code>M</code>:按使用内存排序</li>
<li>打开后，输入<code>P</code>:按使用CPU排序</li>
<li>打开后，输入<code>q</code>:退出</li>
</ul></li>
<li><code>df -h</code>:查看硬盘使用情况</li>
<li><code>free -h</code>:查看内存使用情况</li>
<li><code>du -sh</code>:查看当前目录占用的硬盘空间</li>
<li><code>ps aux</code>:查看所有进程</li>
<li><code>kill -9 pid</code>:杀死编号为<code>pid</code>的进程
<ul>
<li>传递某个具体的信号：<code>kill -s SIGTERM pid</code></li>
</ul></li>
<li><code>netstat -nt</code>:查看所有的网络连接</li>
<li><code>w</code>:列出当前登陆的用户</li>
<li><code>ping www.baidu.com</code>:查看是否联网</li>
</ol>
<hr />
<p><strong>文件权限：</strong></p>
<ol type="1">
<li><code>chmod</code>:修改文件权限
<ul>
<li><code>chmod +x xxx</code>:给<code>xxx</code>添加可执行权限</li>
<li><code>chmod -x xxx</code>:去掉<code>xxx</code>的可执行权限</li>
<li><code>chmod 777 xxx</code>:将<code>xxx</code>的权限改为777</li>
<li><code>chmod 777 xxx -R</code>:递归修改整个文件夹的权限</li>
</ul></li>
</ol>
<hr />
<p><strong>文件检索：</strong></p>
<ol type="1">
<li><code>find /path/to/directory/ -name '*.py'</code>:搜索某个文件路径下的所有`*.py'文件</li>
<li><code>grep xxx</code>:从<code>stdin</code>中读入若干行数据，如果某行中包含<code>xxx</code>，则输出该行；否则忽略改行。</li>
<li><code>wc</code>:统计行数、单词数、字节数
<ul>
<li>即可以从<code>stdin</code>中直接读入内容；也可以在命令行参数中传入文件名列表；</li>
<li><code>wc -l</code>:统计行数</li>
<li><code>wc -w</code>:统计单词数</li>
<li><code>wc -c</code>:统计字节数</li>
</ul></li>
<li><code>tree</code>:展示当前目录的文件结构
<ul>
<li><code>tree /path/to/directory/</code>:展示某个目录的文件结构</li>
<li><code>tree -a</code>:展示隐藏文件</li>
</ul></li>
<li><code>ag xxx</code>:搜索当前目录下的所有文件，检索<code>xxx</code>字符串</li>
<li><code>cut</code>:分割一行内容
<ul>
<li>从<code>stdin</code>中读入多行数据</li>
<li><code>echo $PATH | cut -d ':' -f 3,5</code>:输出<code>PATH</code>用<code>:</code>分割后第3、5行数据</li>
<li><code>echo $PATH | cut -d ':' -f 3-5</code>:输出<code>PATH</code>用<code>:</code>分割后第3-5行数据</li>
<li><code>echo $PATH | cut -c 3,5</code>:输出<code>PATH</code>的第3、5个字符</li>
<li><code>echo $PATH | cut -c 3-5</code>:输出<code>PATH</code>的第3-5个字符</li>
</ul></li>
<li><code>sort</code>：将每行内容按字典序排序
<ul>
<li>可以从<code>stdin</code>中读取多行数据</li>
<li>可以从命令行参数中读取文件名列表</li>
</ul></li>
<li><code>xargs</code>：将<code>stdin</code>中的数据用空格或回车分割成命令行参数
<ul>
<li><code>find . -name '*.py' | xargs cat | wc -1</code>:统计当前目录下所有python文件的总行数</li>
</ul></li>
</ol>
<hr />
<p><strong>查看文件内容：</strong></p>
<ol type="1">
<li><code>more</code>:浏览文件内容
<ul>
<li>回车：下一行</li>
<li>空格：下一页</li>
<li><code>b</code>:上一页</li>
<li><code>q</code>:退出</li>
</ul></li>
<li><code>less</code>：与<code>more</code>类似，功能更全
<ul>
<li>回车：下一行</li>
<li><code>y</code>:上一行</li>
<li><code>Page Down</code>:上一页</li>
<li><code>q</code>:退出</li>
</ul></li>
<li><code>head -3 xxx</code>:展示<code>xxx</code>的前3行内容
<ul>
<li>同时支持从<code>stdin</code>读入内容</li>
</ul></li>
<li><code>tail -3 xxx</code>:展示<code>xxx</code>末尾3行内容
<ul>
<li>同时支持从<code>stdin</code>读入内容</li>
</ul></li>
</ol>
<hr />
<p><strong>用户相关：</strong></p>
<ol type="1">
<li><code>md5sum</code>:计算<code>md5</code>哈希值
<ul>
<li>可以从<code>stdin</code>读入内容</li>
<li>也可以在命令行参数中传入文件名列表</li>
</ul></li>
<li><code>time command</code>:统计<code>command</code>命令的执行时间</li>
<li><code>ipython</code>:交互式python3环境。可以当作计算器，或者批量管理文件
<ul>
<li><code>! echo "Hello World"</code>:<code>!</code>表示<code>shell</code>脚本</li>
</ul></li>
<li><code>watch -n 0.1 command</code>:每0.1秒执行一次<code>command</code>命令</li>
<li><code>tar</code>：压缩文件
<ul>
<li><code>tar -zcvf xxx.tar.gz /path/to/file/*</code>:压缩</li>
<li><code>tar -zxvf xxx.tar.gz</code>:解压缩</li>
</ul></li>
<li><code>diff xxx yyy</code>:查找文件<code>xxx</code>和<code>yyy</code>的不同点</li>
</ol>
<hr />
<p><strong>安装软件：</strong></p>
<ol type="1">
<li><code>sudo command</code>:以<code>root</code>身份执行<code>command</code>命令</li>
<li><code>apt-get install xxx</code>:安装软件</li>
<li><code>pip install xxx --user --upgrade</code>:安装python包</li>
</ol>
</blockquote>
<h2 id="租云服务器及配置环境">8.租云服务器及配置环境</h2>
<p>​ <strong>描述：</strong>多练多练多练多练</p>
<blockquote>
<p><strong>云平台的作用:</strong></p>
<ol type="1">
<li><p>存放我们的docker容器，让计算跑在云端。</p></li>
<li><p>获得公网IP地址，让每个人可以访问到我们的服务。</p></li>
</ol>
<hr />
<p><strong>任选一个云平台即可，推荐配置：</strong></p>
<ol type="1">
<li>1核 2GB（后期可以动态扩容，前期配置低一些没关系）</li>
<li>网络带宽采用按量付费，最大带宽拉满即可（费用取决于用量，与最大带宽无关）</li>
<li>系统版本：ubuntu 20.04
LTS（推荐用统一版本，避免后期出现配置不兼容的问题）</li>
</ol>
</blockquote>
<blockquote>
<p>阿里云地址：<a
target="_blank" rel="noopener" href="https://www.aliyun.com/">https://www.aliyun.com/</a></p>
<p><strong>创建工作用户<code>andii</code>并赋予<code>sudo</code>权限</strong></p>
<p>登陆到新服务器，打开AC Terminal，然后：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh root@xxx.xxx.xxx.xxx # xxx.xxx.xxx.xxx替换成新服务器的公网IP<br></code></pre></td></tr></table></figure>
<p>创建<code>andii</code>用户：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">adduser andii # 创建用户<br>usermod -aG sudo andii # 给用户andii分配sudo权限<br></code></pre></td></tr></table></figure>
<p>删除<code>andii</code>用户：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">userdel andii # 删除用户<br></code></pre></td></tr></table></figure>
<hr />
<p><strong>配置免密登录方式</strong></p>
<p>退回AC
Terminal，然后配置<code>andii</code>用户的别名和免密登录，可参考<a
href="#4.ssh">4.ssh</a>。</p>
<hr />
<p><strong>配置新服务器上的工作环境</strong></p>
<p>将AC Terminal的配置传到新的服务器上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ssh">scp .bashrc .vimrc .tmux.conf server_name: # server_name需要换成自己配置的别名<br></code></pre></td></tr></table></figure>
<hr />
<p><strong>安装<code>tmux</code>和<code>docker</code></strong></p>
<p>登录到自己的服务器，然后安装<code>tmux</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get update<br>sudo apt-get install tmux<br></code></pre></td></tr></table></figure>
<p>打开<code>tmux</code>。（养成好习惯，所有工作都在<code>tmux</code>里进行，防止意外关闭终端后，工作进度丢失）</p>
<p>然后在<code>tmux</code>中根据<a
target="_blank" rel="noopener" href="https://docs.docker.com/engine/install/ubuntu/">docker安装教程</a>安装<code>docker</code>即可。</p>
</blockquote>
<h3 id="docker教程">docker教程</h3>
<blockquote>
<p><strong>将当前用户添加到<code>docker</code>用户组</strong></p>
<p>为了避免每次使用<code>docker</code>命令都需要加上<code>sudo</code>权限，可以将当前用户加入安装中自动创建的<code>docker</code>用户组（可以参照<a
target="_blank" rel="noopener" href="https://docs.docker.com/engine/install/linux-postinstall/">官方文档</a>)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo usermod -aG docker $USER<br></code></pre></td></tr></table></figure>
<p>执行完此操作后，需要退出服务器，在重新登陆回来，才可以省去<code>sudo</code>权限</p>
<hr />
<p><strong>镜像（imgaes）</strong></p>
<ol type="1">
<li><code>docker pull ubuntu:20.04</code>：拉取一个镜像</li>
<li><code>docker images</code>：列出本地的所有镜像</li>
<li><code>docker image rm ubuntu:20.04</code>或<code>docker rmi ubuntu:20.04</code>：删除镜像<code>ubuntu:20.04</code></li>
<li><code>docker [container] commit CONTAINER IMAGE_NAME:TAG</code>：创建某个<code>container</code>镜像</li>
<li><code>docker save -o ubuntu_20_04.tar ubuntu:20.04</code>：将镜像<code>ubuntu:20.04</code>导出到本地文件夹<code>ubuntu_20_04.tar</code>中</li>
<li><code>docker load -i ubuntu_20_04.tar :</code>：将镜像<code>ubuntu:20.04</code>从本地文件<code>ubuntu_20_04.tar</code>中加载出来</li>
</ol>
<hr />
<p><strong>容器（container）</strong></p>
<ol type="1">
<li><code>docker [container] create -it ubuntu:20.04</code>：利用镜像<code>ubuntu:20.04</code>创建一个容器</li>
<li><code>docker ps -a</code>：查看本地的所有容器
<ol type="1">
<li><code>docker [container] start CONTAINER</code>：启动容器</li>
</ol></li>
<li><code>docker [container] stop CONTAINER</code>：停止容器</li>
<li><code>docker [container] restart CONTAINER</code>：重启容器</li>
<li><code>docker [container] run -itd ubuntu:20.04</code>：创建并启动一个容器</li>
<li><code>docker [container] attach CONTAINER</code>：进入容器
<ul>
<li>先按住<code>Ctrl+p</code>，再按<code>Ctrl+q</code>可以挂起容器</li>
</ul></li>
<li><code>docker [container] exec CONTAINER COMMAND</code>：在容器中执行命令</li>
<li><code>docker [container] rm CONTAINER</code>：删除容器</li>
<li><code>docker container prune</code>：删除所有已经停止的容器</li>
<li><code>docker export -o xxx.tar CONTAINER</code>：将容器<code>CONTAINER</code>导出到本地文件<code>xxx.tar</code>中</li>
<li><code>docker import xxx.tar image_name:tag</code>：将本地文件<code>xxx.tar</code>导入成镜像，并将镜像命名为<code>image_name:tag</code></li>
<li><code>docker export/import</code>与<code>docker save/load</code>的区别：
<ul>
<li><code>export/import</code>会丢失历史记录和元数据信息，仅保存容器当时的快照状态</li>
<li><code>save/load</code>会保存完整记录，体积会更大</li>
</ul></li>
<li><code>docker top CONTAINER</code>：查看某个容器内的进程</li>
<li><code>docker stats</code>：查看所有容器的统计信息，包括CPU、内存、网络等信息</li>
<li><code>docker cp xxx CONTAINER:xxx</code>或<code>docker cp CONTAINER:xxx xxx</code>：在本地和容器之间复制文件</li>
<li><code>docker rename CONTAINER1　CONTAINER2</code>：重命名容器</li>
<li><code>docker update CONTAINER --mermory 500MB</code>：修改容器限制</li>
</ol>
<hr />
<p><strong>实战</strong>：<font color='green'>使用同一个docker镜像可以保证减少环境不一致导致的开发的耗时</font></p>
<p>进入AC Terminal，然后：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp /var/lib/acwing/docker/images/docker_lesson_1_0.tar server_name:  # 将镜像上传到自己租的云端服务器<br>ssh server_name  # 登录自己的云端服务器<br><br>docker load -i docker_lesson_1_0.tar  # 将镜像加载到本地<br>docker run -p 20000:22 --name my_docker_server -itd docker_lesson:1.0  # 创建并运行docker_lesson:1.0镜像<br><br>docker attach my_docker_server  # 进入创建的docker容器<br>passwd  # 设置root密码<br></code></pre></td></tr></table></figure>
<p>去云平台控制台中修改安全组配置，放行端口<code>20000</code>。</p>
<p>返回AC
Terminal，即可通过<code>ssh</code>登录自己的<code>docker</code>容器：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh root@xxx.xxx.xxx.xxx -p 20000  # 将xxx.xxx.xxx.xxx替换成自己租的服务器的IP地址<br></code></pre></td></tr></table></figure>
<p>然后，可以仿照上节课内容，创建工作账户<code>acs</code>。</p>
<p>最后，可以参考<a
href="#4.ssh">4.ssh</a>登录配置<code>docker</code>容器的别名和免密登录。</p>
<hr />
<p><strong>小Tips</strong></p>
<p>如果<code>apt-get</code>下载软件速度较慢，可以参考<a
target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">清华大学开源软件镜像站</a>中的内容，修改软件源。</p>
</blockquote>
<blockquote>
<p>注意：
本次作业的3个题目不是独立的，每个题目会依赖于前一个题目，因此评测时如果当前题目错误，则不再评测后续题目。</p>
<p>创建好作业后，先进入文件夹/home/acs/homework/lesson_8/，然后：</p>
<ol start="0" type="1">
<li>进入homework_0文件夹，然后： [1] 租一台云服务器 [2]
配置服务器别名及免密登录 [3]
将服务器别名写在当前目录下的server_name.txt文件中</li>
<li>进入homework_1文件夹，然后： [1] 在租好的云服务器中安装docker</li>
<li>进入homework_2文件夹，然后： [1] 将AC
Terminal中的/var/lib/acwing/docker/images/docker_lesson_1_0.tar镜像上传到租好的服务器中
[2] 登录到租好的服务器 [3] 将上传的镜像提取出来 [4]
创建该镜像的容器，设置端口映射：20000:22。 [5]
去云平台控制台中修改安全组配置，放行端口20000。 [6]
进入该容器，创建新账户acs [7] 返回AC
Terminal。配置容器中acs账户的别名及免密登录。 [8]
将别名写在当前目录下的server_name.txt文件中</li>
</ol>
</blockquote>
<h1 id="linux-c-编译连接问题">Linux C++ 编译连接问题</h1>
<h2 id="链接出问题">1.链接出问题：</h2>
<ol type="1">
<li>自定义类函数没有重载操作符</li>
<li>判断是否所有的头文件都已经被编译过生成了<code>.o</code>文件</li>
<li>检车一下是否是服务器掉线了</li>
<li>一个可执行文件的编译保证只有一个<code>.cpp</code>文件中有<code>main</code>函数</li>
<li>仔细查看调用的接口的<code>ip</code>地址和端口号是否写错</li>
</ol>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/acwing/" class="category-chain-item">acwing</a>
  
  
    <span>></span>
    
  <a href="/categories/acwing/%E5%B7%A5%E7%A8%8B/" class="category-chain-item">工程</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/acwing/" class="print-no-link">#acwing</a>
      
        <a href="/tags/%E5%AD%A6%E4%B9%A0/" class="print-no-link">#学习</a>
      
        <a href="/tags/%E5%B7%A5%E7%A8%8B/" class="print-no-link">#工程</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>acwing_linux基础</div>
      <div>https://example.com/2023/08/08/acwing_linux基础/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Andy</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年8月8日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/09/15/acwing_django%E6%A1%86%E6%9E%B6%E8%AF%BE/" title="acwing_django框架课">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">acwing_django框架课</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/07/23/acwing_%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/" title="acwing_基础算法">
                        <span class="hidden-mobile">acwing_基础算法</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
